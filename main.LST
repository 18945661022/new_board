C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*========================================
   2          1、本板编号0x10 版本号1.0
   3          2、本机组成说明:
   4                 MCU                              stc125a60s2
   5                 时钟                             11.0592MHZ
   6                 EEPROM                           512*2 byte
   7                 timer                            timer0 16位
   8                 串口                             串口2(BAUD 9600)
   9                
  10                 wifi                             usr-wifi-232-t(AP/APSTA)
  11                 ADC                              p1.1
  12                 数据类                           p1.0
  13                 LCD                              1602/14432
  14           3、本机主要功能:
  15                1)模拟传感器或数据类数据采集。
  16                2)对采集的数据进行的必要处理(报警等)。
  17                3)WIFI AP模式下与手机端进行数据交换。
  18                4)WIFI STA模式下与服务器进行数据交换。
  19          ========================================*/
  20          
  21          #include "COM_Fun.h"
  22          #include "LCD_Fun.h"
  23          #include "eeprom_fun.h"
  24          #include "18b20_Fun.h"
  25          #include "Delay_Fun.h"
  26          #include "ADC_Fun.h"
  27          #include "Stc_Math.h"
  28          #include "AM2305.h"
  29          #include "WDT_Fun.h"
  30          
  31          typedef unsigned char BYTE;
  32          typedef unsigned int WORD;
  33          
  34          /*============EEPROM设计==================
  35          总体设计：
  36          -----------------------------------------------
  37          |  0-7  |                 本机信息            |
  38          -----------------------------------------------
  39          |  8-15 |               定时器类设置          |
  40          -----------------------------------------------
  41          |  16-23|               串口类设置            |
  42          -----------------------------------------------
  43          |  24-47|               LCD类设置             |
  44          -----------------------------------------------
  45          | 48-103|               ADC类设置             |
  46          -----------------------------------------------
  47          |104-159|               数据类设置            |
  48          -----------------------------------------------
  49          |160-295|               WIFI类设置            |
  50          -----------------------------------------------
  51          |296-335|               用户逻辑类            |
  52          -----------------------------------------------
  53          |336-375|               显示字符类设置        |
  54          -----------------------------------------------
  55          | 剩余  |               扩展区                |
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 2   

  56          -----------------------------------------------
  57          
  58          本机信息说明：
  59          ----------------------------------------------------------------------------------
  60          |   0     |   1      |   2     |   3     |   4       |   5      |   6   |   7    |
  61          ----------------------------------------------------------------------------------
  62          | TYPE    | LCD      |  WIFI    |  ADC    | DATA     |初始化时间|补充类 |通信协议|
  63          ----------------------------------------------------------------------------------
  64          TYPE: 板型，填0x10
  65          LCD: 显示器类  1602:0x13  14432:0x14  12864:0x15  16032：0x16  无：0x00或0xff
  66          wifi: WIFI 工作类  0x11
  67          ADC:ADC工作类 
  68          DATA：DATA工作类 
  69          初始化时间：初始化所需时间
  70          补充类：ADC或DATA数据的补充，若设置的话必须等于这两个类的ID值
  71          协议: FF:http1.1（chunked包）;  00：http1.0      智能解析
  72          
  73          
  74          定时器类设置
  75          -----------------------------------------------------------------------
  76          |   8   |   9   |   10   |   11   |   12   |   13   |   14   |   15   |
  77          -----------------------------------------------------------------------
  78          |  步长 |位数   |电源ADC修正值    |                传感器补充         |
  79          -----------------------------------------------------------------------
  80          步长：定时时间 = 125ms*定时步长   默认值是8
  81          位数：16位
  82          
  83          串口类设置
  84          -----------------------------------------------------------------------
  85          |   16  |  17   |   18   |   19   |   20   |   21   |   22   |   23   |
  86          -----------------------------------------------------------------------
  87          |波特率 |数据位 |校验方式|停止位  |CTSRTS  |                          |
  88          -----------------------------------------------------------------------
  89          波特率： 0:9600  1:115200 3....
  90          数据位： 8
  91          校验方式：0：无校验 1：奇校验 2：偶校验 3、MARK校验
  92          CTSRTS：0：无握手 1：有握手
  93          
  94          LCD类设置
  95          -----------------------------------------------------------------------
  96          |   24  |  25   |   26   |   27   |   28   |   29   |   30   |   31   |
  97          -----------------------------------------------------------------------
  98          |行数   |行字符数|行地址0|行地址1 |行地址2 |行地址3 |行0位置 |行1位置 |
  99          -----------------------------------------------------------------------
 100          
 101          -----------------------------------------------------------------------
 102          |   32  |  33   |   34   |   35   |   36   |   37   |   38   |   39   |
 103          -----------------------------------------------------------------------
 104          |行2位置|行3位置|行0刷新 |行1刷新 |行2刷新 |行3刷新 |                                                    |
 105          -----------------------------------------------------------------------
 106          
 107          -----------------------------------------------------------------------
 108          |   40  |  41   |   42   |   43   |   44   |   45   |   46   |   47   |
 109          -----------------------------------------------------------------------
 110          |                        保留                                         |
 111          -----------------------------------------------------------------------
 112          
 113          行数：行数量
 114          行字符数：每行可显示的字符数量  
 115          行地址：每行的显示屏显示初始地址
 116          行位置：每行显示EEPROM位置
 117          
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 3   

 118          ADC类设置1（P1.1脚）
 119          -------------------------------------------------------------------------------
 120          |   48   |  49    |   50    |   51    |   52    |   53    |   54    |   55    |
 121          -------------------------------------------------------------------------------
 122          |采集方式|采集时长|上传方式 |上传时长 |报警检测 |报警标识 |报警模式 |报警方式 |
 123          -------------------------------------------------------------------------------
 124          
 125          -------------------------------------------------------------------------------
 126          |   56   |  57    |   58    |   59    |   60    |   61    |   62    |   63    |
 127          -------------------------------------------------------------------------------
 128          |         低门限值                    |           高门限值                    |
 129          -------------------------------------------------------------------------------
 130          
 131          -------------------------------------------------------------------------------              
 132          |   64   |  65    |   66    |   67    |   68    |   69    |   70    |   71    |
 133          ------------------------------------------------------------------------------- 
 134          |                     占行模式                                                |
 135          -------------------------------------------------------------------------------
 136          
 137          -------------------------------------------------------------------------------
 138          |   72   |  73    |   74    |   75    |   76    |   77    |   78    |   79    |
 139          ------------------------------------------------------------------------------- 
 140          |                               占行模式                                      |
 141          -------------------------------------------------------------------------------
 142                                      
 143          -------------------------------------------------------------------------------
 144          |   80   |  81    |   82    |   83    |   84    |   85    |   86    |   87    |
 145          ------------------------------------------------------------------------------- 
 146          |14432占行模式    |08类判决间隔|启动时间|故障警告 |引脚参数 |启动时间缓存值|采集时间缓存值|
 147          -------------------------------------------------------------------------------
 148          
 149          -------------------------------------------------------------------------------
 150          |   88         |  89    |   90    |   91    |   92    |   93    |   94    |   95    |
 151          ------------------------------------------------------------------------------- 
 152          |上传时间缓存值|采集状态|上传状态 |        断路特征值                     |上传计数值                     
             -                                                    |
 153          -------------------------------------------------------------------------------
 154          
 155          -------------------------------------------------------------------------------
 156          |   96   |  97    |   98    |   99    |  100       |  101       |  102    |  103    |
 157          ------------------------------------------------------------------------------- 
 158          |百分比顶值修订   |百分比低值修订     |08类电平意义|08类判决次数|08类电平判决值|08类次数门限              
             -                                         |
 159          -------------------------------------------------------------------------------
 160          
 161          数据类设置（P1.0脚）
 162          -------------------------------------------------------------------------------
 163          |  104   | 105    |  106    |  107    |  108    |  109    |  110    |  111    |
 164          -------------------------------------------------------------------------------
 165          |采集方式|采集时长|上传方式 |上传时长 |报警检测 |报警标识 |报警模式 |报警方式 |
 166          -------------------------------------------------------------------------------
 167          
 168          -------------------------------------------------------------------------------
 169          |  112   | 113    |  114    |  115    |  116    |  117    |  118    |  119    |
 170          -------------------------------------------------------------------------------
 171          |         低门限值                    |           高门限值                    |
 172          -------------------------------------------------------------------------------
 173          
 174          -------------------------------------------------------------------------------              
 175          |  120   | 121    |  122    |  123    |  124    |  125    |  126    |  127    |
 176          ------------------------------------------------------------------------------- 
 177          |                     占行模式                                                |
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 4   

 178          -------------------------------------------------------------------------------
 179          
 180          -------------------------------------------------------------------------------
 181          |  128   | 129    |  130    |  131    |  132    |  133    |  134    |  135    |
 182          ------------------------------------------------------------------------------- 
 183          |                               占行模式                                      |
 184          -------------------------------------------------------------------------------
 185                                      
 186          -------------------------------------------------------------------------------
 187          |  136   | 137    |  138    |  139    |  140    |  141    |  142    |  143    |
 188          ------------------------------------------------------------------------------- 
 189          |14432占行模式    |显示生命期|启动时间|故障警告 |引脚参数 |启动时间缓存值|采集时间缓存值                  
             -          |
 190          -------------------------------------------------------------------------------
 191                                                                                                                                             
 192          -------------------------------------------------------------------------------
 193          |   144        |  145   |  146    |  147    |  148    |  149    |  150    |  151|
 194          ------------------------------------------------------------------------------- 
 195          |上传时间缓存值|采集状态|上传状态 |   断路特征值                          |上传计数值                     
             -                                                     |
 196          -------------------------------------------------------------------------------
 197          
 198          -------------------------------------------------------------------------------
 199          |  152   | 153    |  154    |  155    |  156    |  157    |  158    |  159    |
 200          ------------------------------------------------------------------------------- 
 201          |                                                                              |
 202          -------------------------------------------------------------------------------
 203          
 204          采集方式：0xff 无意义 0x00 不采集 0xfb 循环采集   其他值（<=250） 采集次数
 205          采集时长：定时采集时长 默认1s
 206          上传方式：
 207          -------------------------------------------------------------------------
 208          |  7     |  6     |  5     |  4     |  3     |  2     |  1     |  0     | 
 209          -------------------------------------------------------------------------
 210          | x      |  x     | x      | x      |故障上传|告警上传|定时上传|单次上传|
 211          -------------------------------------------------------------------------
 212          上传时长：定时上传时长 默认1s 可设置
 213          报警检测：0 不检测报警 1 检测报警
 214          报警标识：报警识别位，1有效，可手动清零。
 215          报警模式：01高门限报警，02低门限报警，03双门限报警
 216          报警方式：01持续报警，00单次报警
 217          低门限值：前面2字节整数部分，后面两字节小数部分
 218          高门限值：前面2字节整数部分，后面两字节小数部分
 219          占行模式：把要显示的字符放在相应的位置，其中0x30表示符号位，0x31-0x35表示整数部分相应的字节数，0x36-0x39表
             -示小数部分相应字节数
 220          显示生命期：数据显示的时间长度，默认为10.
 221          启动时间：设备启动到稳定工作的时间
 222          故障警告：设备故障说明。
 223          引脚参数：1.1脚就是0x02
 224          -------------------------------------------------------------------------
 225          |  7     |  6     |  5     |  4     |  3     |  2     |  1     |  0     | 
 226          -------------------------------------------------------------------------
 227          ||                                                                                                                         |设备断路|
 228          -------------------------------------------------------------------------
 229          
 230          WIFI类设置
 231          -------------------------------------------------------------------------------
 232          |  160   | 161    |  162    |  163    |  164    |  165    |  166    |  167    |
 233          ------------------------------------------------------------------------------- 
 234          |初始标识|MODE    |    设备地址       |            AP SSID前缀                |        
 235          -------------------------------------------------------------------------------
 236          
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 5   

 237          -------------------------------------------------------------------------------
 238          |  168   | 169    |  170    |  171    |  172    |  173    |  174    |  175    |
 239          ------------------------------------------------------------------------------- 
 240          |                      AP密码                                                 |
 241          -------------------------------------------------------------------------------
 242          
 243          -------------------------------------------------------------------------------
 244          |  176   | 177    |  178    |  179    |  180    |  181    |  182    |  183    |
 245          ------------------------------------------------------------------------------- 
 246          |   CH   |NET_MODE|ENC_MODE |WPA_ENC  |A_PRO    |A_PORT_N | A_PORT1 | A_PORT2 |                           
             -                               |
 247          -------------------------------------------------------------------------------
 248          
 249          -------------------------------------------------------------------------------
 250          |  184   | 185    |  186    |  187    |  188    |  189    |  190    |  191    |
 251          ------------------------------------------------------------------------------- 
 252          |A_PORT3 |A_PORT4 |A_PORT5  |A_IP_N   |A_IP1    |A_IP2    |A_IP3    |A_IP4    |
 253          -------------------------------------------------------------------------------
 254          
 255          -------------------------------------------------------------------------------
 256          |  192   | 193    |  194    |  195    |  196    |  197    |  198    |  199    |
 257          ------------------------------------------------------------------------------- 
 258          |A_IP5   |A_IP6   |A_IP7    |A_IP8    |A_IP9    |A_IP10   |A_IP11   |A_IP12   |
 259          -------------------------------------------------------------------------------
 260          
 261          -------------------------------------------------------------------------------
 262          |  200   | 201    |  202    |  203    |  204    |  205    |  206    |  207    |
 263          ------------------------------------------------------------------------------- 
 264          |A_IP13  |A_IP14  |A_IP15   |A_TIMEOUT_N|A_TIMEOUT1|A_TIMEOUT2|A_TIMEOUT3|                                
             -       |
 265          -------------------------------------------------------------------------------
 266          
 267          ----------------------------------------------------------------------------------
 268          |  208     | 209     |  210    |  211    |  212    |  213    |  214    |  215    |
 269          ----------------------------------------------------------------------------------
 270          |STA_SSID_N|STA_SSID1|STA_SSID2|STA_SSID3|STA_SSID4|STA_SSID5|STA_SSID6|STA_SSID7|
 271          ----------------------------------------------------------------------------------
 272          
 273          ----------------------------------------------------------------------------------------
 274          |  216     | 217      |  218     |  219     |  220     |  221     |  222     |  223     |
 275          ----------------------------------------------------------------------------------------
 276          |STA_SSID8 |STA_SSID9 |STA_SSID10|STA_SSID11|STA_SSID12|STA_SSID13|STA_SSID14|STA_SSID15|
 277          ----------------------------------------------------------------------------------------
 278          
 279          -------------------------------------------------------------------------------
 280          |  224   | 225    |  226    |  227    |  228    |  229    |  230    |  231    |
 281          ------------------------------------------------------------------------------- 
 282          |STA_P_N |STA_P1  |STA_P2   |STA_P3   |STA_P4   |STA_P5   |STA_P6   |STA_P7   |
 283          -------------------------------------------------------------------------------
 284          
 285          -------------------------------------------------------------------------------
 286          |  232   | 233    |  234    |  235    |  236    |  237    |  238    |  239    |
 287          ------------------------------------------------------------------------------- 
 288          |STA_P8  |STA_P9  |STA_P10  |STA_P11  |STA_P12  |STA_P13  |STA_P14  |STA_P15  |
 289          -------------------------------------------------------------------------------
 290          
 291          -------------------------------------------------------------------------------
 292          |  240   | 241    |  242    |  243    |  244    |  245    |  246    |  247    |
 293          ------------------------------------------------------------------------------- 
 294          |STA_P16 |STA_P17 |STA_P18  |STA_P19  |STA_P20  |STA_P21  |STA_P22  |STA_P23  |
 295          -------------------------------------------------------------------------------
 296          
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 6   

 297          --------------------------------------------------------------------------------------
 298          |  248       | 249       |  250    |  251    |  252    |  253    |  254    |  255    |
 299          -------------------------------------------------------------------------------------- 
 300          |STA_ENC_MODE|STA_WPA_ENC|B_PRO    |B_PORT_N | B_PORT1 | B_PORT2 |B_PORT3  |B_PORT4  |
 301          --------------------------------------------------------------------------------------
 302          
 303          -------------------------------------------------------------------------------
 304          |  256   | 257    |  258    |  259    |  260    |  261    |  262    |  263    |
 305          ------------------------------------------------------------------------------- 
 306          |B_PORT5 |B_IP_N  |B_IP1    |B_IP2    |B_IP3    |B_IP4    |B_IP5    |B_IP6    |
 307          -------------------------------------------------------------------------------
 308          
 309          -------------------------------------------------------------------------------
 310          |  264   | 265    |  266    |  267    |  268    |  269    |  270    |  271    |
 311          ------------------------------------------------------------------------------- 
 312          |B_IP7   |B_IP8   |B_IP9    |B_IP10   |B_IP11   |B_IP12   |B_IP13   |B_IP14   |
 313          -------------------------------------------------------------------------------
 314          
 315          --------------------------------------------------------------------------------------
 316          |  272   | 273       |  274     |  275     |  276     |  277     |  278    |  279    |
 317          -------------------------------------------------------------------------------------- 
 318          |B_IP15  |B_TIMEOUT_N|B_TIMEOUT1|B_TIMEOUT2|B_TIMEOUT3|B_TIMEOUT4|         |服务器ip |
 319          --------------------------------------------------------------------------------------
 320          
 321          -------------------------------------------------------------------------------
 322          |  280   | 281    |  282    |  283    |  284    |  285    |  286    |  287    |
 323          ------------------------------------------------------------------------------- 
 324          |                      服务器ip                                               |
 325          -------------------------------------------------------------------------------
 326          
 327          -------------------------------------------------------------------------------
 328          |  288   | 289    |  290    |  291    |  292    |  293    |  294    | 295     |
 329          ------------------------------------------------------------------------------- 
 330          | 服务器ip                  |                     服务器端口                          |
 331          -------------------------------------------------------------------------------
 332          
 333          初始标识：0表示未进行初始化   1表示已经初始化
 334          MODE：1 AP模式  2 STA模式 4 APSTA模式  8 AP一定时间再转STA模式
 335          设备地址：设备通信地址  1-65534    0xff为广播地址
 336          AP参数
 337          AP SSID前缀：通信前缀 4字节 默认USR_
 338          AP密码 ：8字节 
 339          CH：AP信道 0 自动 手动 1-11.
 340          NET_MODE：0 11bgn
 341          ENC_MODE：0 WPA2PSK 1 none
 342          WPA_ENC：0 AES 
 343          
 344          SOCKET A参数：
 345          A_PRO：0 TCP 1 UDP
 346          A_PORT_N：端口字符数
 347          A_PORT？：端口字符，无意义部分用0Xff表示
 348          A_IP_N：IP字符数
 349          A_IP?:IP字符，无意义部分用0xff表示
 350          A_TIMEOUT_N:超时时间字符数
 351          A_TIMEOUT？：超时时间字符，无意义部分用0xff表示
 352          
 353          STA参数
 354          STA_SSID_N：STA模式外部路由器SSID的字符数
 355          STA_SSID？：STA模式外部路由器SSID，无意义部分用0xff表示
 356          STA_P_N：STA模式外部路由器密码字符数
 357          STA_P？：TA模式外部路由器密码，无意义部分用0xff表示
 358          STA_ENC_MODE：0 WPA2PSK  ......
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 7   

 359          STA_WPA_ENC：
 360          
 361          SOCKETB参数
 362          B_PRO：0 TCP 1 UDP
 363          B_PORT_N：端口字符数
 364          B_PORT？：端口字符，无意义部分用0Xff表示
 365          B_IP_N：IP字符数
 366          B_IP?:IP字符，无意义部分用0xff表示
 367          B_TIMEOUT_N:超时时间字符数
 368          B_TIMEOUT？：超时时间字符，无意义部分用0xff表示
 369          
 370          服务器IP：    279-290     如192.168.0.36    192168000036
 371          服务器端口：  291-295     如805             00805  
 372          
 373          用户逻辑类
 374          -------------------------------------------------------------------------------
 375          | 296    |  297    |  298    |  299    |  300    |  301    |  302    |303     |
 376          ------------------------------------------------------------------------------- 
 377          |心跳设置|心跳时间           |心跳地址           | 心跳计数|
 378          -------------------------------------------------------------------------------
 379          -------------------------------------------------------------------------------
 380          | 304    |  305    |  306    |  307    |  308    |  309    |  310    |311     |
 381          ------------------------------------------------------------------------------- 
 382          |                                                                             |
 383          -------------------------------------------------------------------------------
 384          -------------------------------------------------------------------------------
 385          |  312   | 313    |  314    |  315    |  316    |  317    |  318    |  319    |
 386          ------------------------------------------------------------------------------- 
 387          |                                                         |       补充类提示                      显示字符类
 388          -------------------------------------------------------------------------------
 389          -------------------------------------------------------------------------------
 390          |  320   | 321    |  322    |  323    |  324    |  325    |  326    |  327    |
 391          ------------------------------------------------------------------------------- 
 392          |                      补充类提示                                             |
 393          -------------------------------------------------------------------------------
 394          -------------------------------------------------------------------------------
 395          |  328   | 329    |  330    |  331    |  332    |  333    |  334    |  335    |
 396          ------------------------------------------------------------------------------- 
 397          |                      补充类提示                                             |
 398          -------------------------------------------------------------------------------
 399          
 400          
 401          -------------------------------------------------------------------------------
 402          |  336   | 337    |  338    |  339    |  340    |  341    |  342    |  343    |
 403          ------------------------------------------------------------------------------- 
 404          |                            ADC类提示1                                        |
 405          -------------------------------------------------------------------------------
 406          
 407          -------------------------------------------------------------------------------
 408          |  344   | 345    |  346    |  347    |  348    |  349    |  350    |  351    |
 409          ------------------------------------------------------------------------------- 
 410          |                            ADC类提示1                                        |
 411          -------------------------------------------------------------------------------
 412          
 413          -------------------------------------------------------------------------------
 414          |  352   | 353    |  354    |  355    |  356    |  357    |  358    |  359    |
 415          ------------------------------------------------------------------------------- 
 416          |                 |        数据类提示1                                        |
 417          -------------------------------------------------------------------------------
 418          
 419          -------------------------------------------------------------------------------
 420          |  360   | 361    |  362    |  363    |  364    |  365    |  366    |  367    |
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 8   

 421          ------------------------------------------------------------------------------- 
 422          |                          数据类提示1                                        |
 423          -------------------------------------------------------------------------------
 424          
 425          -------------------------------------------------------------------------------
 426          |  368   | 369    |  370    |  371    |  372    |  373    |  374    |  375    |
 427          ------------------------------------------------------------------------------- 
 428          |          数据类提示1                |       wifi类提示1                     |
 429          -------------------------------------------------------------------------------
 430          
 431          -------------------------------------------------------------------------------
 432          |  376   | 377    |  378    |  379    |  380    |  381    |  382    |  383    |
 433          ------------------------------------------------------------------------------- 
 434          |                                                wifi类提示1                                  |
 435          -------------------------------------------------------------------------------
 436          
 437          -------------------------------------------------------------------------------
 438          |  384   | 385    |  386    |  387    |  388    |  389    |  390    |  391    |
 439          ------------------------------------------------------------------------------- 
 440          |              wifi类提示1                                |     开机LOGO文字      |
 441          -------------------------------------------------------------------------------
 442          
 443          -------------------------------------------------------------------------------
 444          |  392   | 393    |  394    |  395    |  396    |  397    |  398    |  399    |
 445          ------------------------------------------------------------------------------- 
 446          |                                               开机LOGO文字                                  |
 447          -------------------------------------------------------------------------------
 448          
 449          -------------------------------------------------------------------------------
 450          |  400   | 401    |  402    |  403    |  404    |  405    |  406    |  407    |
 451          ------------------------------------------------------------------------------- 
 452          |                                 开机LOGO文字                                |
 453          -------------------------------------------------------------------------------
 454          
 455          296:心跳设置 0x02:设置心跳  0x01:开机心跳   0x00:无心跳  0x03：both
 456          
 457          扩展区
 458          -------------------------------------------------------------------------------
 459          |  408   | 409    |  410    |  411    |  412    |  413    |  414    |  415    |
 460          ------------------------------------------------------------------------------- 
 461          |上传方式|上传时长|报警检测 |报警标识 |报警模式 |报警方式 |    低门限值           |
 462          -------------------------------------------------------------------------------
 463          |  416   | 417    |  418    |  419    |  420    |  421    |  422    |  423    |
 464          ------------------------------------------------------------------------------- 
 465          |地门限值         |高门限值                                                       |补充类显示缓存         |
 466          -------------------------------------------------------------------------------
 467          |  424   | 425    |  426    |  427    |  428    |  429    |  430    |  431    |
 468          ------------------------------------------------------------------------------- 
 469                                                             补充类显示缓存
 470          -------------------------------------------------------------------------------
 471          |  432   | 433    |  434    |  435    |  436    |  437    |  438    |  439    |
 472          ------------------------------------------------------------------------------- 
 473                                                             补充类显示缓存
 474          -------------------------------------------------------------------------------
 475          |  440   | 441    |  442    |  443    |  444    |  445    |  446    |  447    |
 476          ------------------------------------------------------------------------------- 
 477                                             LCD显示缓存0 
 478          -------------------------------------------------------------------------------
 479          |  448   | 449    |  450    |  451    |  452    |  453    |  454    |  455    |
 480          ------------------------------------------------------------------------------- 
 481                                             LCD显示缓存0 
 482          -------------------------------------------------------------------------------
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 9   

 483          |  456   | 457    |  458    |  459    |  460    |  461    |  462    |  463    |
 484          ------------------------------------------------------------------------------- 
 485          |                 |                      LCD显示缓存1                             |
 486          -------------------------------------------------------------------------------
 487          
 488          -------------------------------------------------------------------------------
 489          |  464   | 465    |  466    |  467    |  468    |  469    |  470    |  471    |
 490          ------------------------------------------------------------------------------- 
 491          |                        LCD显示缓存1                                         |
 492          -------------------------------------------------------------------------------   
 493          
 494          -------------------------------------------------------------------------------
 495          |  472   | 473    |  474    |  475    |  476    |  477    |  478    |  479    |
 496          ------------------------------------------------------------------------------- 
 497          |        LCD显示缓存1                             |         数据类待显示缓存1             |
 498          -------------------------------------------------------------------------------
 499          
 500          -------------------------------------------------------------------------------
 501          |  480   | 481    |  482    |  483    |  484    |  485    |  486    |  487    |
 502          ------------------------------------------------------------------------------- 
 503          |                    数据类待显示缓存1                                        |
 504          -------------------------------------------------------------------------------
 505          
 506          -------------------------------------------------------------------------------
 507          |  488   | 489    |  490    |  491    |  492    |  493    |  494    |  495    |
 508          ------------------------------------------------------------------------------- 
 509          |                      数据类待显示缓存1                             |ADC类待显示缓存1|
 510          -------------------------------------------------------------------------------
 511          
 512          -------------------------------------------------------------------------------
 513          |  496   | 497    |  498    |  499    |  500    |  501    |  502    |  503    |
 514          ------------------------------------------------------------------------------- 
 515          |                               ADC类待显示缓存1                              |
 516          -------------------------------------------------------------------------------
 517          
 518          -------------------------------------------------------------------------------
 519          |  504   | 505    |  506    |  507    |  508    |  509    |  510    |  511    |
 520          ------------------------------------------------------------------------------- 
 521          |                               ADC类待显示缓存1                              |
 522          -------------------------------------------------------------------------------
 523          
 524          ========================================*/
 525          
 526          //256--275
 527          BYTE code INFO_14432[][18] = {
 528                  {0x20,0x20,0x20,0x20,0x20,0x20,0xc9,0xe8,0xb1,0xb8,0xb9,0xca,0xd5,0xcf,0x20,0x20,0x20,0x20},
 529                  {0x20,0x20,0x20,0x20,0xb5,0xb9,0xbc,0xc6,0xca,0xb1,0x00,0x00,0x00,0x53,0x20,0x20,0x20,0x20},
 530                  {0x20,0x20,0x20,0x20,0xb5,0xb9,0xbc,0xc6,0xca,0xb1,0x00,0x00,0x00,0x53,0x20,0x20,0x20,0x20},
 531                  {0x20,0x20,0x20,0x20,0xc7,0xeb,0xd6,0xd8,0xd0,0xc2,0xc6,0xf4,0xb6,0xaf,0x20,0x20,0x20,0x20},
 532                  {0x20,0x20,0x20,0x20,0x20,0x20,0xc9,0xe8,0xd6,0xc3,0xb3,0xc9,0xb9,0xa6,0x20,0x20,0x20,0x20},
 533                  {0x20,0x20,0x20,0x20,0xc9,0xe8,0xb1,0xb8,0xb2,0xbb,0xc6,0xa5,0xc5,0xe4,0x20,0x20,0x20,0x20},
 534                  {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
 535                  {0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xc1,0xac,0xbd,0xd3,0xb3,0xc9,0xb9,0xa6,0x20,0x20},
 536                  {0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xc1,0xac,0xbd,0xd3,0xca,0xa7,0xb0,0xdc,0x20,0x20},
 537                  {0x20,0x20,0xd6,0xd8,0xd0,0xc2,0xc5,0xe4,0xd6,0xc3,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9},
 538                  {0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xb3,0xc9,0xb9,0xa6},
 539                  {0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xd6,0xd8,0xd6,0xc3},
 540                  {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
 541                  {0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xca,0xa7,0xb0,0xdc},
 542                  {0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xd6,0xf7,0xbb,0xfa,0xb4,0xed,0xce,0xf3,0x20,0x20},
 543                  {0x20,0x20,0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xb3,0xac,0xca,0xb1,0x20,0x20,0x20,0x20},
 544                  {0x20,0x20,0x20,0x20,0xbb,0xd8,0xb8,0xb4,0xb4,0xed,0xce,0xf3,0x20,0x20,0x20,0x20,0x20,0x20},
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 10  

 545                  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
 546                  {0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0xce,0xd5,0xca,0xd6,0xd0,0xc5,0xcf,0xa2,0x20,0x20},
 547                  {0x20,0x20,0x20,0x20,0x20,0x20,0xbb,0xd8,0xb8,0xb4,0xb3,0xc9,0xb9,0xa6,0x20,0x20,0x20,0x20},
 548                  {0x20,0x20,0x20,0x20,0x20,0x20,0xbb,0xf0,0xc7,0xe9,0xcc,0xe1,0xca,0xbe,0x20,0x20,0x20,0x20}
 549          };
 550          
 551          BYTE code INFO_1620[][16] = {
 552                  {0x20,0x20,'S','E','N','S','O','R',' ','F','A','U','L','T',0x20,0x20},
 553                  {'C','O','U','N','T','D','O','W','N',':',' ',0x00,0x00,0x00,0x20,0x20},
 554                  {'C','O','U','N','T','D','O','W','N',':',' ',0x00,0x00,0x00,0x20,0x20},
 555                  {' ','P','L','E','A','S','E',' ','R','E','S','T','A','R','T',' '},
 556                  {'S','E','T',' ','S','U','C','C','E','S','S','F','U','L','L','Y'},
 557                  {' ',' ',' ','M','I','S','M','A','T','C','H','I','N','G',' ',' '},
 558                  {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '},
 559                  {' ',' ',' ',' ','C','O','N','N','E','C','T','E','D',' ',' ',' '},
 560                  {' ',' ','D','I','S','C','O','N','N','E','C','T','E','D',' ',' '},
 561                  {' ',' ','W','I','F','I',' ',' ','C','O','N','F','I','G',' ',' '},
 562                  {' ',' ','W','I','F','I','C','O','N','N','E','C','T','E','D',' '},
 563                  {' ','W','I','F','I','R','E','C','O','N','N','E','C','T','E','D'},
 564                  {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '},
 565                  {'W','I','F','I','D','I','S','C','O','N','N','E','C','T','E','D'},
 566                  {' ',' ',' ','H','O','S','T',' ','E','R','R','O','R',' ',' ',' '},
 567                  {' ','S','E','R','V','E','R',' ','T','I','M','E','O','U','T',' '},
 568                  {' ',' ','R','E','T','U','R','N',' ','E','R','R','O','R',' ',' '},
 569                  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,' ',' ',' ',' ',' ',' ',' ',' '},
 570                  {0x20,0x00,0x00,0x00,0x00,0x00,'H','A','N','D','S','H','A','K','E',0x20},
 571                  {0x20,0x20,0x20,'R','E','C','V',0x20,0x20,'D','A','T','A',0x20,0x20,0x20}
 572          };
 573          
 574          BYTE xdata EEPROM_Buffer[512];
 575          
 576          #define FOSC 11059200L              //System frequency
 577          #define T1MS 19455//50ms  12分频
 578          //(65536-FOSC/12/1000) 1ms timer calculation method in 1T mode
 579          //(65536-FOSC/1000) 1ms timer calculation method in 1T mode
 580          #define BAUD0 9600                  //UART baudrate 9600
 581          #define BAUD1 115200                //UART baudrate 115200
 582          
 583          sbit rs485_wr = P2^2;
 584          
 585          //串口接收
 586          #define MaxRecvBuff1   4
 587          #define MaxRecvBuff2   59         
 588          //#define Recv_DelayTime1 200
 589          
 590          BYTE xdata Recv_Buff2[MaxRecvBuff2];  //
 591          BYTE xdata Recv_Buff1[MaxRecvBuff1];
 592          bit recv2;//
 593          bit recv1;                                 
 594          BYTE Recv_Num2;//
 595          BYTE Recv_Num1;
 596          bit busy2;//
 597          bit busy1;
 598          //串口发送
 599          /*********优先级定义**************   
 600                 0        1       2        3       4      5
 601          上传   √       √       ×        ×       ×      ×
 602          心跳   √       √       √        ×       ×      ×
 603          回复   √       √              √               √              ×      ×
 604          .....  √       √              √               √       √        ×
 605          **********************************/
 606          BYTE xdata Send_Buff2[MaxRecvBuff2]; 
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 11  

 607          BYTE xdata Send_Buff1[MaxRecvBuff1];
 608          BYTE Send_Num2;
 609          BYTE Send_Pri2;       
 610          
 611          BYTE xdata Send_Buff1[MaxRecvBuff1]; 
 612          BYTE Send_Num1;     
 613                  
 614          //定时器
 615          WORD Timer_Count0,TimerNum0;
 616          WORD Timer_Step; 
 617          bit Timer_Up0;
 618          bit ding;                                     //一次计数
 619          void Start_Timer0(WORD count,bit Mode);
 620          BYTE Get_Buff1(BYTE * Buffer);
 621          BYTE Get_Buff2(BYTE * Buffer);
 622          void ClearBuff1();
 623          void ClearBuff2();
 624          
 625          //===================ADC类特定设置==============
 626          void ADC_P_Init();
 627          BYTE ADC_P;
 628          BYTE ADC_ID;
 629          BYTE ADC[10];
 630          BYTE ADC_Average;
 631          WORD ADC_Integer,ADC_Decimal;
 632          BYTE ADC_sign;                     //暂未使用
 633          WORD ADC_REF;                  //adc修正值
 634          WORD ADC_100,ADC_0;            //百分比修正值
 635          BYTE ADC_Count;                //ADC计数值
 636          bit sign_08;
 637          
 638          
 639          bit fire_sign;
 640          sbit test_315m = P2^1; 
 641                      
 642          
 643          //===================数据类特定设置==============
 644          void DATA_P_Init();
 645          BYTE DATA_ID;
 646          BYTE TPL,TPH;                    //18b20参数
 647          BYTE AM2305_Data[5];             //am2305参数        
 648          WORD DATA_Integer,DATA_Decimal;
 649          BYTE DATA_sign;
 650          WORD DATA_100,DATA_0;            //百分比修正值
 651          BYTE DATA_Count;                 //数据计数值
 652          BYTE YES_NO[2];
 653          
 654          //===================补充类特定设置==============
 655          void EXTRA_P_Init();
 656          BYTE EXTRA_ID;
 657          BYTE EXTRA_sign;
 658          WORD EXTRA_Integer,EXTRA_Decimal;
 659          //===================字符串处理============
 660          void WordToStr(unsigned int integer,BYTE num);
 661          BYTE xdata str_i[5],str_d[5];
 662          
 663          //===================WIFI SET==============
 664          void Wifi_CMode();
 665          void Wifi_TMode();
 666          BYTE GetSockBStatus();
 667          void Wifi_ReStart();
 668          void Wifi_ReStart2();
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 12  

 669          void Wifi_AP();
 670          void Wifi_STA();
 671          void Wifi_APSTA();
 672          BYTE Wifi_STATUS();
 673          BYTE Get_Mode();
 674          BYTE Get_WSLK();
 675          void Wifi_MDCH();
 676          
 677          #define Recv_DelayTime2 200
 678          BYTE Wifi_status_flag;
 679          sbit wifi_reset = P2^0; 
 680          /*==================LCD处理================
 681                           
 682          =========================================*/
 683          BYTE LCD_ID;
 684          BYTE Show_ID;                                 //马上显示
 685          BYTE Screen_Array[3],Screen_Num,Screen_Count;  //分屏显示资源数组和分屏显示资源数量及计数
 686          BYTE Screen_Fresh = 3;                                  //刷新周期（ding）数量
 687          BYTE Screen_Fresh_Count;
 688          bit Screen_Fresh_flag=0;
 689          BYTE SChar_Line,SChar_Start,SChar_Time;        //提示字符显示行和起始位置及驻屏时间
 690          void Screen_refresh();                         //分屏显示资源重新统计
 691          void ShowLine(BYTE line,WORD start);
 692          //RAM缓冲区
 693          //BYTE xdata LCDScreen[64];                       //兼容1602 14432 12864
 694          
 695          /*==================协议解析================
 696          错误码                    意义
 697            0                       成功
 698            1                       头错误
 699            2                                       地址错误
 700            3                       序列号错误
 701            4                       指令地址值错误
 702            5                       指令载荷数错误
 703            6                       没有匹配的资源
 704          ==========================================*/
 705          BYTE Src_Addr[2];
 706          BYTE Remote_Addr[2];
 707          
 708          typedef struct Pro_0_0
 709          {
 710                  BYTE Mark_Head[2];
 711                  BYTE Des_Addr[2];
 712                  BYTE Src_Addr[2];
 713                  BYTE Seq_Num;
 714                  BYTE Command;
 715                  BYTE Payload_Num;
 716                  BYTE Payload[MaxRecvBuff2-9];
 717          }Pro_0_0;
 718          
 719          typedef union protocol
 720          {
 721                  Pro_0_0 Pro_Struct;
 722                  BYTE Pro_Buff[MaxRecvBuff2];
 723          }protocol;
 724          
 725          void ClearPro_Buffer();
 726          
 727          protocol xdata pro;
 728          
 729          BYTE Seq_Number;
 730          BYTE Parse(BYTE HAddr,BYTE LAddr,BYTE num);
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 13  

 731          
 732          void Command_01();
 733          BYTE Command_07();
 734          BYTE Command_09();
 735          BYTE Command_0F();
 736          BYTE Command_11();
 737          BYTE Command_13();
 738          BYTE Command_15();
 739          BYTE Command_17();
 740          BYTE Command_19();
 741          BYTE Command_1b();
 742          BYTE Command_1d();
 743          BYTE Command_1f();                          //传输失败可能没用
 744          
 745          /*=================用户逻辑================
 746                           
 747          =========================================*/
 748          WORD Heart_Time;               //心跳定时时间
 749          WORD Heart_Count;              //心跳定时计数
 750          bit Server_Flag;               //服务器连接标识
 751          void Heart_Process();          //心跳处理
 752          
 753          
 754          void main()
 755          {
 756   1              WORD i,j,integer,decimal;
 757   1              BYTE num,k;
 758   1              Pro_0_0* p;
 759   1              p = &(pro.Pro_Struct);
 760   1              //EEPROM操作  
 761   1              Delayms(500);                         
 762   1              GetSector(0,EEPROM_Buffer);                   //EEPROM读取
 763   1              EEPROM_Buffer[278] = 1;
 764   1              //EEPROM_Buffer[318] = 0x20;                                      //空格
 765   1              //EEPROM_Buffer[319] = 0x20;
 766   1              //EEPROM_Buffer[336] = 0x20;
 767   1              //EEPROM_Buffer[337] = 0x20;
 768   1              //EEPROM_Buffer[354] = 0x20;
 769   1              //EEPROM_Buffer[355] = 0x20;
 770   1              Server_Flag = 0;
 771   1              LCD_ID = EEPROM_Buffer[1];
 772   1              ADC_ID = EEPROM_Buffer[3];
 773   1              DATA_ID = EEPROM_Buffer[4];
 774   1              EXTRA_ID = EEPROM_Buffer[6];
 775   1              ADC_REF = ((WORD)EEPROM_Buffer[10]<<8)+(WORD)EEPROM_Buffer[11];           //ADC参考电压
 776   1              if((EEPROM_Buffer[296]&0x02)==0x02)
 777   1              {
 778   2                      Heart_Time = ((WORD)(EEPROM_Buffer[297])<<8)+(WORD)EEPROM_Buffer[298];
 779   2                      Heart_Count = 0;
 780   2              }
 781   1              Screen_refresh();                            //资源计数
 782   1              EEPROM_Buffer[440] = 0xff;                                       //避免开机不显示  不重要
 783   1          EEPROM_Buffer[458] = 0xff;
 784   1              Src_Addr[0] = EEPROM_Buffer[162];
 785   1              Src_Addr[1] = EEPROM_Buffer[163];
 786   1              Seq_Number = 0;
 787   1              Timer_Step = (WORD)EEPROM_Buffer[8];//*125;
 788   1              LcdInit1();                                    //14432和1602暂同使用一个初始化程序
 789   1              rs485_wr = 1;
 790   1              EEPROM_Buffer[34] = 0;                                       //初始状态各行都不刷新
 791   1              EEPROM_Buffer[35] = 0;
 792   1              EEPROM_Buffer[36] = 0;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 14  

 793   1              EEPROM_Buffer[37] = 0;
 794   1              Delayms(500);
 795   1              ShowLine(0,390);
 796   1              //while(1);
 797   1              Timer_Uart_Init();
 798   1              Send_Pri2 = 0;                         //最低优先级
 799   1              Send_Num2 = 0;                         //没有数据装载
 800   1              //检查是否有ADC类初始化
 801   1              ADC_P = 0x00;
 802   1              if(ADC_ID != 0xff)
 803   1              {       
 804   2                      ADC_P_Init();
 805   2                      switch(ADC_ID)
 806   2                      {
 807   3                              case 0x01:
 808   3                                      ADC_P |= EEPROM_Buffer[85];                  //默认值为0x01 0x31  045 3个脚
 809   3                                      InitADC(ADC_P);
 810   3                                      break;
 811   3                              case 0x02:
 812   3                                      ADC_P |= EEPROM_Buffer[85];                  //默认值为0x01
 813   3                                      InitADC(ADC_P);
 814   3                                      break;                   
 815   3                      /*      case 0x05:
 816   3                                      DS18B20_Init();
 817   3                                      break;   */
 818   3                              case 0x08:
 819   3                                      ADC_P |= EEPROM_Buffer[85];                  //默认值为0x02
 820   3                                      InitADC(ADC_P);
 821   3                                      sign_08 = 0;                             //初始化默认为0
 822   3                                      EEPROM_Buffer[89] = 1;
 823   3                                      Show_ID = 3;
 824   3                                      break;
 825   3                              case 0x09:
 826   3                                      ADC_P |= EEPROM_Buffer[85];                  //默认值为0x02
 827   3                                      InitADC(ADC_P);
 828   3                                      break;
 829   3                              default:
 830   3                                      break;  
 831   3                      }       
 832   2              }
 833   1                      
 834   1              //检查数据类 初始化
 835   1              ADC_P = 0x00;
 836   1              if(DATA_ID != 0xff)
 837   1              {
 838   2                      DATA_P_Init();
 839   2                      switch(DATA_ID)
 840   2                      {
 841   3                      /*      case 0x01:
 842   3                                      ADC_P |= EEPROM_Buffer[141];                 //默认值为0x02
 843   3                                      InitADC(ADC_P);
 844   3                                      break;
 845   3                              case 0x02:
 846   3                                      ADC_P |= EEPROM_Buffer[141];                 //默认值为0x02
 847   3                                      InitADC(ADC_P);
 848   3                                      break;          */
 849   3                              case 0x05:
 850   3                                      DS18B20_Init();
 851   3                                      break;
 852   3                      /*      case 0x08:
 853   3                                      break;     */
 854   3                              default:
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 15  

 855   3                                      break;  
 856   3                      }       
 857   2              }
 858   1              //扩充类的初始化
 859   1              if(EXTRA_ID != 0xff)
 860   1              {
 861   2              }
 862   1              //补充传感器   火警
 863   1          if(EEPROM_Buffer[12] != 0xff){
 864   2                      fire_sign = 0;
 865   2                      IT0 = 1;                        //set INT0 int type (1:Falling 0:Low level)
 866   2              EX0 = 1;   
 867   2              }
 868   1              
 869   1              //保证wifi芯片完全启动
 870   1              Delayms(5000);
 871   1      
 872   1              Wifi_status_flag = 0;
 873   1              //ShowLine(0,273);
 874   1      
 875   1              if(EEPROM_Buffer[160] == 0)
 876   1              {
 877   2                      if(EEPROM_Buffer[161]>0)
 878   2                      {
 879   3                              //ShowLine(0,372);
 880   3                              //进入命令模式
 881   3                              //Wifi_CMode();
 882   3                              //换算出AP SSID和密码 ,默认WAP2PSK
 883   3                              i = ((WORD)Src_Addr[0]<<8)+(WORD)Src_Addr[1];                                                            
 884   3                              WordToStr(i,0);
 885   3                              /***
 886   3                              //根据模式做出相应操作
 887   3                              if((EEPROM_Buffer[161]|0x01)==0x01)                     //ap模式
 888   3                              {
 889   3                                  //2、设置AP参数，部分参数直接填写默认值
 890   3                                  Wifi_AP();
 891   3                                      Wifi_ReStart();
 892   3                              } 
 893   3                              if(EEPROM_Buffer[161]|0x02)                     //STA模式
 894   3                              {
 895   3                                      //暂未处理
 896   3      
 897   3                              } 
 898   3                              if((EEPROM_Buffer[161]|0x04)==0x04)                     //APSTA模式
 899   3                              {
 900   3                                      Wifi_APSTA();
 901   3                                      Wifi_ReStart();
 902   3                              }       ***/
 903   3                              if((EEPROM_Buffer[161]|0x08)==0x08)
 904   3                              {
 905   4                                      /*** /
 906   4                                      Wifi_AP();
 907   4                                      Delayms(200);
 908   4                                      Wifi_ReStart();
 909   4                                      Delayms(3000);
 910   4                                      //Wifi_CMode();
 911   4                                      /**/
 912   4                                      //Wifi_MDCH();
 913   4                                      //while(1);
 914   4                              //Wifi_status_flag = Wifi_STATUS();
 915   4                              }
 916   3                      }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 16  

 917   2                      //EEPROM_Buffer[160] = 1;
 918   2                  //EEPROM_Buffer[5] = EEPROM_Buffer[5] - 10;           //初始化时间缩短了 
 919   2                      //IapEraseSector(0);                                 //先擦后写
 920   2                      //WriteSector(0,EEPROM_Buffer);                      //EEPROM写入       
 921   2                      Delayms(3000);
 922   2                      ClearBuff2();
 923   2                      //if(Wifi_status_flag == 20){
 924   2                              //Command_01();
 925   2                      //}
 926   2                      Delayms(15000);
 927   2              }else                                        //不做初始化
 928   1              {
 929   2                      Delayms(10000);
 930   2              }
 931   1              
 932   1              Start_Timer0(Timer_Step,1);
 933   1          //变量初始化为0
 934   1              SChar_Line = 0;
 935   1              SChar_Time = 0;
 936   1              SChar_Start = 0;
 937   1              ding = 0;
 938   1              //9S一次喂狗
 939   1              //WDT_CONTR = 0x3f; 
 940   1              while(1)
 941   1              {
 942   2      /*************************************数据采集处理**************************************/
 943   2                      //先判断是否设置了数据类  03 04 05 06 07  可以处理
 944   2                      if(DATA_ID != 0xff)
 945   2                      {
 946   3                              //再判断初始化时间是否结束
 947   3                              if((EEPROM_Buffer[142]==0)&&(EEPROM_Buffer[145]>0))
 948   3                              {
 949   4                                      //再判断采集是否打开 
 950   4                                      switch(EEPROM_Buffer[104])
 951   4                                      {
 952   5                                              case 0x00:
 953   5                                                      break;
 954   5                                              //循环采集
 955   5                                              case 0xfb:
 956   5                                                      if(EEPROM_Buffer[111]==0)               //非持续报警
 957   5                                                      {
 958   6                                                              EEPROM_Buffer[109] = 0;     //清警
 959   6                                                              EEPROM_Buffer[140] = 0;         //清障  
 960   6                                                      }
 961   5                                                      if(DATA_ID == EXTRA_ID-1)
 962   5                                                      {
 963   6                                                              if(EEPROM_Buffer[413]==0)               //非持续报警
 964   6                                                              {
 965   7                                                                      EEPROM_Buffer[411] = 0;     //清警      
 966   7                                                              }       
 967   6                                                      }
 968   5                                                      switch(DATA_ID)
 969   5                                                      {
 970   6                                                              case 0x01:
 971   6                                                                      break;
 972   6                                                              case 0x02:
 973   6                                                                      break;
 974   6                                                              case 0x03:                     //DHT11
 975   6                                                                      EA = 0;
 976   6                                                                      k = AM2305_Start(18);
 977   6                                                                      if(k==0)
 978   6                                                                      {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 17  

 979   7                                                                              for(i=0;i<5;i++)
 980   7                                                                              {
 981   8                                                                                      AM2305_Data[i] = AM2305_ReadByte();     
 982   8                                                                              }
 983   7                                                                              j = (WORD)AM2305_Data[0] + (WORD)AM2305_Data[1] + (WORD)(AM2305_Data[2]) + (WORD)AM2305_Data[3]; 
 984   7                                                                              if((BYTE)j==AM2305_Data[4])
 985   7                                                                              {
 986   8                                                                                      DATA_Integer = AM2305_Data[0];
 987   8                                                                                      DATA_Decimal = AM2305_Data[1];
 988   8                                                                              EXTRA_Integer = AM2305_Data[2];
 989   8                                                                                      EXTRA_Decimal = AM2305_Data[3];
 990   8                                                                                      if(AM2305_Data[2]&0x80)
 991   8                                                                                      {
 992   9                                                                                              EXTRA_sign = 0x2d;
 993   9                                                                                      }else
 994   8                                                                                      {
 995   9                                                                                              EXTRA_sign = 0x2b;
 996   9                                                                                      }
 997   8                                                                              }
 998   7                                                                              else
 999   7                                                                              {
1000   8                                                                                      EEPROM_Buffer[140] |= 0x01;               //断路？？？
1001   8                                                                              }
1002   7                                                                      }
1003   6                                                                      else
1004   6                                                                      {
1005   7                                                                              EEPROM_Buffer[140] |= 0x01;               //断路？？
1006   7                                                                      }
1007   6                                                                      EA = 1;
1008   6                                                                      break;
1009   6                                                              case 0x05:                                     //18b20
1010   6                                                                      DS18B20_Init();
1011   6                                                                      TPL = DS18B20_ReadByte();                     //读温度低字节
1012   6                                                                      TPH = DS18B20_ReadByte();                     //读温度高字节
1013   6                                                              DATA_Integer = Get_Integer(TPH,TPL);
1014   6                                                                      DATA_Decimal = Get_Decimal(TPL);
1015   6                                                                      if((TPH == 0x05)&&(TPL==0x50))
1016   6                                                                      {
1017   7                                                                              EEPROM_Buffer[140] |= 0x02;               //初始化未完成造成？
1018   7                                                                      }
1019   6                                                                      if((TPH&0x07==0x07)&&(TPL==0xff))
1020   6                                                                      {
1021   7                                                                              EEPROM_Buffer[140] |= 0x01;               //断路
1022   7                                                                      }
1023   6                                                                      if((TPH>>8)&0x01)
1024   6                                                                      {
1025   7                                                                              DATA_sign = 0x2d;
1026   7                                                                              DATA_Integer |= 0x8000;
1027   7                                                                              DATA_Decimal |= 0x8000; 
1028   7                                                                      }
1029   6                                                                      else
1030   6                                                                      {
1031   7                                                                              DATA_sign = 0x2b;       
1032   7                                                                      }
1033   6                                                                      break;
1034   6                                                              case 0x06:                                        //am2305,注意填充补充类
1035   6                                                                      EA = 0;
1036   6                                                                      k = AM2305_Start(2);
1037   6                                                                      if(k==0)
1038   6                                                                      {
1039   7                                                                              for(i=0;i<5;i++)
1040   7                                                                              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 18  

1041   8                                                                                      AM2305_Data[i] = AM2305_ReadByte();     
1042   8                                                                              }
1043   7                                                                              j = (WORD)AM2305_Data[0] + (WORD)AM2305_Data[1] + (WORD)(AM2305_Data[2]) + (WORD)AM2305_Data[3]; 
1044   7                                                                              if((BYTE)j==AM2305_Data[4])
1045   7                                                                              {
1046   8                                                                                      DATA_Integer = ((WORD)AM2305_Data[0]<<8)+((WORD)AM2305_Data[1]);
1047   8                                                                                      DATA_Decimal = 0;
1048   8                                                                              EXTRA_Integer = ((WORD)AM2305_Data[2]<<8)+((WORD)AM2305_Data[3]);
1049   8                                                                                      EXTRA_Decimal = 0;
1050   8                                                                                      if(AM2305_Data[2]&0x80)
1051   8                                                                                      {
1052   9                                                                                              EXTRA_sign = 0x2d;
1053   9                                                                                      }else
1054   8                                                                                      {
1055   9                                                                                              EXTRA_sign = 0x2b;
1056   9                                                                                      }
1057   8                                                                              }
1058   7                                                                              else
1059   7                                                                              {
1060   8                                                                                      EEPROM_Buffer[140] |= 0x01;               //断路？？？
1061   8                                                                              }
1062   7                                                                      }
1063   6                                                                      else
1064   6                                                                      {
1065   7                                                                              EEPROM_Buffer[140] |= 0x01;               //断路？？
1066   7                                                                      }
1067   6                                                                      EA = 1;
1068   6                                                                      break;
1069   6                                                              case 0x08:
1070   6                                                                      break;
1071   6                                                              case 0x09:
1072   6                                                                      break;
1073   6                                                              default:
1074   6                                                                      break;
1075   6                                                       }
1076   5                                                      break;
1077   5                                              //0xfc--0xfe保留
1078   5                                              case 0xfc:
1079   5                                                      break;
1080   5                                              case 0xfd:
1081   5                                                      break;
1082   5                                              case 0xfe:
1083   5                                                      break;
1084   5                                              //0xff 不处理
1085   5                                              case 0xff:
1086   5                                                      break;
1087   5                                              default:
1088   5                                                      //EEPROM_Buffer[104] = EEPROM_Buffer[104]-1;
1089   5                                                      break;
1090   5                                      }       
1091   4                              }
1092   3                              else                                                    //没有初始化完毕
1093   3                              {
1094   4                              }
1095   3                      }
1096   2      
1097   2                      //再判断是否设置了ADC类                         01 02 08 09 可以处理
1098   2                      if(ADC_ID != 0xff)
1099   2                      {
1100   3                              //再判断初始化时间是否结束
1101   3                              if((EEPROM_Buffer[86]==0)&&(EEPROM_Buffer[89]>0))
1102   3                              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 19  

1103   4                                      //再判断采集是否打开
1104   4                                      switch(EEPROM_Buffer[48])
1105   4                                      {
1106   5                                              case 0x00:
1107   5                                                      break;
1108   5                                              //循环采集
1109   5                                              case 0xfb:
1110   5                                                      if(EEPROM_Buffer[55]==0)        //非持续报警
1111   5                                                      {
1112   6                                                              EEPROM_Buffer[53] = 0;      //清警
1113   6                                                              EEPROM_Buffer[84] = 0;          //清障  
1114   6                                                      }
1115   5                                                      switch(ADC_ID)
1116   5                                                      {
1117   6                                                              //高于高的，低于低的认为断路
1118   6                                                              case 0x01:
1119   6                                                                      for(i=0;i<10;i++)
1120   6                                                                      {
1121   7                                                                              ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
1122   7                                                                              Delayms(EEPROM_Buffer[82]);
1123   7                                                                      }
1124   6                                                                      ADC_Average = Average(ADC);
1125   6                                                                      ADC_Integer = Vin_8(ADC_Average,ADC_REF);
1126   6                                                                      ADC_Decimal = 0;
1127   6                                                                      integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
1128   6                                                                      i = Compare(ADC_Integer,integer);
1129   6                                                                      if(i == 1)
1130   6                                                                      {
1131   7                                                                              //EEPROM_Buffer[84]|=0x01;
1132   7                                                                      }
1133   6                                                                      else if(i==0)
1134   6                                                                      {
1135   7                                                                              decimal = (((WORD)EEPROM_Buffer[93])<<8)+(WORD)EEPROM_Buffer[94];
1136   7                                                                              i = Compare(ADC_Integer,decimal);
1137   7                                                                              if(i == 1)
1138   7                                                                              {
1139   8                                                                                      //EEPROM_Buffer[84]|=0x01;
1140   8                                                                              }
1141   7                                                                      }
1142   6                                                                      break;
1143   6                                                              case 0x02:
1144   6                                                                      for(i=0;i<10;i++)
1145   6                                                                      {
1146   7                                                                              ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
1147   7                                                                              Delayms(EEPROM_Buffer[82]);
1148   7                                                                      }
1149   6                                                                      ADC_Average = Average(ADC);
1150   6                                                                      j = Vin_8(ADC_Average,ADC_REF);              //j应该大于1000
1151   6                                                                      EA = 0;
1152   6                                                                      //i = (ADC_100-ADC_0)/100;
1153   6                                                                      if(j>=ADC_100)
1154   6                                                                      {
1155   7                                                                              ADC_Integer = 1000;
1156   7                                                                      }else if(j<=ADC_0)
1157   6                                                                      {
1158   7                                                                              ADC_Integer = 0;
1159   7                                                                      }else
1160   6                                                                      {
1161   7                                                                              ADC_Integer = ((j-ADC_0)*10)>>5;//i;    
1162   7                                                                      }
1163   6                                                                      ADC_Decimal = 0;
1164   6                                                                      EA = 1;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 20  

1165   6                                                                      integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
1166   6                                                                      i = Compare(j,integer);
1167   6                                                                      if(i == 2)
1168   6                                                                      {
1169   7                                                                              EEPROM_Buffer[84]|=0x01;
1170   7                                                                      }
1171   6                                                                      else if(i==0)
1172   6                                                                      {
1173   7                                                                              EEPROM_Buffer[84]|=0x01;
1174   7                                                                      }
1175   6                                                                      break;
1176   6                                                              case 0x08:
1177   6                                                                      num = 0;
1178   6                                                                      k = 0;
1179   6                                                                      if(EEPROM_Buffer[100]==0x00)
1180   6                                                                      {
1181   7                                                                              for(i=0;i<EEPROM_Buffer[101];i++)
1182   7                                                                              {
1183   8                                                                                      ADC_Average = GetADCResult(EEPROM_Buffer[85]-1);
1184   8                                                                                      if(ADC_Average<EEPROM_Buffer[102])                 //判决值，低电平有效
1185   8                                                                                      {
1186   9                                                                                              k++;
1187   9                                                                                      }
1188   8                                                                                      Delayms(EEPROM_Buffer[82]);
1189   8                                                                              }
1190   7                                                                              if(k>=EEPROM_Buffer[103])   //判决次数门限，表示有动作
1191   7                                                                              {
1192   8                                                                                      num = 1;
1193   8                                                                                      //低电平报警
1194   8                                                                                  if(EEPROM_Buffer[54]&0x02){
1195   9                                                                                              EEPROM_Buffer[53]|=0x02;
1196   9                                                                                      }
1197   8                                                                                      if((EEPROM_Buffer[50]&0x04) == 0x04)                //报警上传
1198   8                                                                                      {
1199   9                                                                                              if(EEPROM_Buffer[53]!=0)
1200   9                                                                                              {
1201  10                                                                                                      EEPROM_Buffer[90]=1;                             //需要上传     
1202  10                                                                                              }
1203   9                                                                                      }       
1204   8                                                                              }
1205   7                                                                              else
1206   7                                                                              {
1207   8                                                                                      num = 0;
1208   8                                                                              }                       
1209   7                                                                      }else 
1210   6                                                                      if(EEPROM_Buffer[100]==0x01)
1211   6                                                                      {
1212   7                                                                              for(i=0;i<EEPROM_Buffer[101];i++)
1213   7                                                                              {
1214   8                                                                                      ADC_Average = GetADCResult(EEPROM_Buffer[85]-1);
1215   8                                                                                      if(ADC_Average>EEPROM_Buffer[102])                 //判决值,高电平有效
1216   8                                                                                      {
1217   9                                                                                              k++;
1218   9                                                                                      }
1219   8                                                                                      Delayms(EEPROM_Buffer[82]);
1220   8                                                                              }
1221   7                                                                              if(k>=EEPROM_Buffer[103])   //判决次数门限，表示有动作
1222   7                                                                              {
1223   8                                                                                      num = 1;
1224   8                                                                              }
1225   7                                                                              else
1226   7                                                                              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 21  

1227   8                                                                                      num = 0;
1228   8                                                                              }                       
1229   7                                                                      }
1230   6      
1231   6                                                                      
1232   6                                                                      if(num==1)
1233   6                                                                      {
1234   7                                                                              ADC_Integer = 10;
1235   7                                                                              ADC_Decimal = 0;
1236   7                                                                              if(LCD_ID == 0x14)                 //有 
1237   7                                                                              {
1238   8                                                                                      YES_NO[0] = 0xd3;
1239   8                                                                                      YES_NO[1] = 0xd0;
1240   8                                                                              }else 
1241   7                                                                              if(LCD_ID == 0x13)               //Y 
1242   7                                                                              {
1243   8                                                                                      YES_NO[0] = 0x59;
1244   8                                                                                      YES_NO[1] = 0x20;
1245   8                                                                              }
1246   7                                                                              if(sign_08 == 0)                                   //状态翻转
1247   7                                                                              {
1248   8                                                                                      sign_08 = 1;
1249   8                                                                                      Show_ID = 3;                   //特别提示要显示 
1250   8                                                                              }
1251   7                                                                              num = 0;
1252   7                                                                      }
1253   6                                                                      else
1254   6                                                                      {
1255   7                                                                              ADC_Integer = 5;
1256   7                                                                              ADC_Decimal = 0;
1257   7                                                                              if(LCD_ID == 0x14)                 // 无
1258   7                                                                              {
1259   8                                                                                      YES_NO[0] = 0xce;
1260   8                                                                                      YES_NO[1] = 0xde;
1261   8                                                                              }else 
1262   7                                                                              if(LCD_ID == 0x13)               // N
1263   7                                                                              {
1264   8                                                                                      YES_NO[0] = 0x4e;
1265   8                                                                                      YES_NO[1] = 0x20;
1266   8                                                                              }
1267   7                                                                              if(sign_08 == 1)                                   //状态翻转
1268   7                                                                              {
1269   8                                                                                      sign_08 = 0;
1270   8                                                                                      Show_ID = 3;                   //特别提示要显示 
1271   8                                                                              }       
1272   7                                                                      }
1273   6                                                                      break;
1274   6                                                              case 0x09:
1275   6                                                                      for(i=0;i<9;i++)
1276   6                                                                      {
1277   7                                                                              ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
1278   7                                                                              Delayms(EEPROM_Buffer[82]);
1279   7                                                                      }
1280   6                                                                      ADC_Average = Average(ADC);
1281   6                                                                      j = Vin_8(ADC_Average,ADC_REF);              //j应该大于0          千位
1282   6                                                                      EA = 0;
1283   6                                                                      if(j>=ADC_100)
1284   6                                                                      {
1285   7                                                                              ADC_Integer = 0;
1286   7                                                                      }else if(j<=ADC_0)
1287   6                                                                      {
1288   7                                                                              ADC_Integer = 100;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 22  

1289   7                                                                      }else
1290   6                                                                      {
1291   7                                                                              ADC_Integer = ((ADC_100-j)*10)>>9;      
1292   7                                                                      }
1293   6                                                                      ADC_Decimal = 0;
1294   6                                                                      EA = 1;
1295   6                                                              /*      integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
1296   6                                                                      i = Compare(j,integer);
1297   6                                                                      if(i == 2)
1298   6                                                                      {
1299   6                                                                              EEPROM_Buffer[84]|=0x01;
1300   6                                                                      }
1301   6                                                                      else if(i==0)
1302   6                                                                      {
1303   6                                                                              EEPROM_Buffer[84]|=0x01;
1304   6                                                                      }  */
1305   6                                                                      break;
1306   6                                                              default:
1307   6                                                                      break;
1308   6                                                       }
1309   5                                                      break;
1310   5                                              //0xfc--0xfe保留
1311   5                                              case 0xfc:
1312   5                                                      break;
1313   5                                              case 0xfd:
1314   5                                                      break;
1315   5                                              case 0xfe:
1316   5                                                      break;
1317   5                                              //0xff 不处理
1318   5                                              case 0xff:
1319   5                                                      break;
1320   5                                              default:
1321   5                                                      break;
1322   5                                      }       
1323   4                              }
1324   3                              else                                                    //没有初始化完毕
1325   3                              {
1326   4                              }
1327   3                      }
1328   2      /*************************************数据报警处理************************************************/
1329   2                      //先判断是否设置了数据类
1330   2                      if(DATA_ID != 0xff)
1331   2                      {
1332   3                              //再判断初始化时间是否结束
1333   3                              if(EEPROM_Buffer[142]==0)
1334   3                              {
1335   4                                      if((EEPROM_Buffer[145]==1)&&(EEPROM_Buffer[108]==1))                         //是否进行采集+报警检测是否开启
1336   4                                      {
1337   5                                              //故障判断               只能检查断路,低门限值断路
1338   5                                              //18b20采集时自行判断
1339   5                                              if(EEPROM_Buffer[106]&0x08 == 0x08)
1340   5                                              {
1341   6                                                      if(EEPROM_Buffer[140]!=0x00)
1342   6                                                              EEPROM_Buffer[146]=1;                                               //需要上传
1343   6                                              }
1344   5                                              //低门限值判断
1345   5                                              if(EEPROM_Buffer[110]&0x02)                                                     
1346   5                                              {
1347   6                                                      integer = (((WORD)EEPROM_Buffer[112])<<8)+(WORD)EEPROM_Buffer[113];
1348   6                                                      i = Compare(DATA_Integer,integer);
1349   6                                                      if(i == 2)
1350   6                                                      {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 23  

1351   7                                                              EEPROM_Buffer[109]|=0x02;
1352   7                                                      }
1353   6                                                      else if(i == 0)
1354   6                                                      {
1355   7                                                              decimal = (((WORD)EEPROM_Buffer[114])<<8)+(WORD)EEPROM_Buffer[115];
1356   7                                                              i = Compare(DATA_Decimal,decimal);
1357   7                                                              if(i != 1)
1358   7                                                              {
1359   8                                                                      EEPROM_Buffer[109]|=0x02;
1360   8                                                              }
1361   7                                                      } 
1362   6                                              }
1363   5                                              //高门限值判断
1364   5                                              if(EEPROM_Buffer[110]&0x01)                                      
1365   5                                              {
1366   6                                                      integer = (((WORD)EEPROM_Buffer[116])<<8)+(WORD)EEPROM_Buffer[117];
1367   6                                                      i = Compare(DATA_Integer,integer);
1368   6                                                      if(i == 1)
1369   6                                                      {
1370   7                                                              EEPROM_Buffer[109]|=0x01;
1371   7                                                      }
1372   6                                                      else if(i == 0)
1373   6                                                      {
1374   7                                                              decimal = (((WORD)EEPROM_Buffer[118])<<8)+(WORD)EEPROM_Buffer[119];
1375   7                                                              i = Compare(DATA_Decimal,decimal);
1376   7                                                              if(i != 2)
1377   7                                                              {
1378   8                                                                      EEPROM_Buffer[109]|=0x01;
1379   8                                                              }
1380   7                                                      } 
1381   6                                              }
1382   5                                              if((EEPROM_Buffer[106]&0x04)==0x04)                 //报警上传
1383   5                                              {
1384   6      
1385   6                                                      if(EEPROM_Buffer[109]!=0)
1386   6                                                      {
1387   7                                                              EEPROM_Buffer[146]=1;                            //需要上传
1388   7                                                      }
1389   6                                              }
1390   5                                      }
1391   4                              }
1392   3                      }
1393   2      
1394   2                      //再判断是否设置了ADC类           08自行判断
1395   2                      if((ADC_ID != 0xff)&&(ADC_ID!=0x08))
1396   2                      {
1397   3                              //再判断初始化时间是否结束
1398   3                              if(EEPROM_Buffer[86]==0)
1399   3                              {
1400   4                                      if((EEPROM_Buffer[89]==1)&&(EEPROM_Buffer[52]==1))                           //是否进行采集+报警检测是否开启
1401   4                                      {
1402   5                                              //出现故障是否上传
1403   5                                              if(EEPROM_Buffer[50]&0x08 == 0x08)
1404   5                                              {
1405   6                                                      if(EEPROM_Buffer[84]!=0x00)
1406   6                                                              EEPROM_Buffer[90]=1;                                                //需要上传
1407   6                                              }
1408   5                                              //低门限值判断
1409   5                                              if(EEPROM_Buffer[54]&0x02)                                                      
1410   5                                              {
1411   6                                                      integer = (((WORD)EEPROM_Buffer[56])<<8)+(WORD)EEPROM_Buffer[57];
1412   6                                                      i = Compare(ADC_Integer,integer);
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 24  

1413   6                                                      if(i == 2)
1414   6                                                      {
1415   7                                                              EEPROM_Buffer[53]|=0x02;
1416   7                                                      }
1417   6                                                      else if(i == 0)
1418   6                                                      {
1419   7                                                              decimal = (((WORD)EEPROM_Buffer[58])<<8)+(WORD)EEPROM_Buffer[59];
1420   7                                                              i = Compare(ADC_Decimal,decimal);
1421   7                                                              if(i != 1)
1422   7                                                              {
1423   8                                                                      EEPROM_Buffer[53]|=0x02;
1424   8                                                              }
1425   7                                                      } 
1426   6                                              }
1427   5                                              //高门限值判断
1428   5                                              if(EEPROM_Buffer[54]&0x01)                                       
1429   5                                              {
1430   6                                                      integer = (((WORD)EEPROM_Buffer[60])<<8)+(WORD)EEPROM_Buffer[61];
1431   6                                                      i = Compare(ADC_Integer,integer);
1432   6                                                      if(i == 1)
1433   6                                                      {
1434   7                                                              EEPROM_Buffer[53]|=0x01;
1435   7                                                      }
1436   6                                                      else if(i == 0)
1437   6                                                      {
1438   7                                                              decimal = (((WORD)EEPROM_Buffer[62])<<8)+(WORD)EEPROM_Buffer[63];
1439   7                                                              i = Compare(ADC_Decimal,decimal);
1440   7                                                              if(i != 2)
1441   7                                                              {
1442   8                                                                      EEPROM_Buffer[53]=1;
1443   8                                                              }
1444   7                                                      } 
1445   6                                              }
1446   5                                              if((EEPROM_Buffer[50]&0x04) == 0x04)                //报警上传
1447   5                                              {
1448   6                                                      if(EEPROM_Buffer[53]!=0)
1449   6                                                      {
1450   7                                                              EEPROM_Buffer[90]=1;                             //需要上传     
1451   7                                                      }
1452   6                                              }       
1453   5                                      }
1454   4                              }
1455   3                      }
1456   2      
1457   2                      //先判断是否设置了补充类
1458   2                      if((EXTRA_ID == DATA_ID+1)&&(EXTRA_ID !=0xff))
1459   2                      {
1460   3                              //再判断初始化时间是否结束
1461   3                              if(EEPROM_Buffer[142]==0)
1462   3                              {
1463   4                                      if((EEPROM_Buffer[145]==1)&&(EEPROM_Buffer[410]==1))                         //是否进行采集+报警检测是否开启
1464   4                                      {
1465   5                                              //补充类故障报警
1466   5                                              if(EEPROM_Buffer[408]&0x08 == 0x08)
1467   5                                              {
1468   6                                                      if(EEPROM_Buffer[140]!=0x00)
1469   6                                                              EEPROM_Buffer[146]=1;                                               //需要上传
1470   6                                              } 
1471   5                                              //低门限值判断
1472   5                                              if(EEPROM_Buffer[412]&0x02)                                                     
1473   5                                              {
1474   6                                                      integer = (((WORD)EEPROM_Buffer[414])<<8)+(WORD)EEPROM_Buffer[415];
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 25  

1475   6                                                      i = Compare(EXTRA_Integer,integer);
1476   6                                                      if(i == 2)
1477   6                                                      {
1478   7                                                              EEPROM_Buffer[411]|=0x02;
1479   7                                                      }
1480   6                                                      else if(i == 0)
1481   6                                                      {
1482   7                                                              decimal = (((WORD)EEPROM_Buffer[416])<<8)+(WORD)EEPROM_Buffer[417];
1483   7                                                              i = Compare(EXTRA_Decimal,decimal);
1484   7                                                              if(i != 1)
1485   7                                                              {
1486   8                                                                      EEPROM_Buffer[411]|=0x02;
1487   8                                                              }
1488   7                                                      } 
1489   6                                              }
1490   5                                              //高门限值判断
1491   5                                              if(EEPROM_Buffer[412]&0x01)                                      
1492   5                                              {
1493   6                                                      integer = (((WORD)EEPROM_Buffer[418])<<8)+(WORD)EEPROM_Buffer[419];
1494   6                                                      i = Compare(EXTRA_Integer,integer);
1495   6                                                      if(i == 1)
1496   6                                                      {
1497   7                                                              EEPROM_Buffer[411]|=0x01;
1498   7                                                      }
1499   6                                                      else if(i == 0)
1500   6                                                      {
1501   7                                                              decimal = (((WORD)EEPROM_Buffer[420])<<8)+(WORD)EEPROM_Buffer[421];
1502   7                                                              i = Compare(EXTRA_Decimal,decimal);
1503   7                                                              if(i != 2)
1504   7                                                              {
1505   8                                                                      EEPROM_Buffer[411]|=0x01;
1506   8                                                              }
1507   7                                                      } 
1508   6                                              }
1509   5                                              if((EEPROM_Buffer[408]&0x04) == 0x04)               //报警上传
1510   5                                              {
1511   6                                                      if(EEPROM_Buffer[411]!=0)
1512   6                                                      {
1513   7                                                              EEPROM_Buffer[146]=1;                            //需要上传     
1514   7                                                      }
1515   6                                              }
1516   5                                      }
1517   4                              }
1518   3                      }
1519   2      /*************************************报警上传准备************************************************/
1520   2                      num = 0;  //上传初始计数
1521   2                      //先判断是否设置了数据类
1522   2                      if(DATA_ID != 0xff)
1523   2                      {
1524   3                              //再判断初始化时间是否结束,是否有新上传
1525   3                              if((EEPROM_Buffer[142]==0)&&(EEPROM_Buffer[146]!=0))
1526   3                              {
1527   4                                      p->Payload[num] = DATA_ID;
1528   4                                      num++;
1529   4                                  p->Payload[num] = (EEPROM_Buffer[140]<<4)+ EEPROM_Buffer[109];
1530   4                                      num++;
1531   4                                      p->Payload[num] = (BYTE)(DATA_Integer>>8);
1532   4                                      num++;
1533   4                                      p->Payload[num] = (BYTE)(DATA_Integer);
1534   4                                      num++;
1535   4                                      p->Payload[num] = (BYTE)(DATA_Decimal>>8);
1536   4                                      num++;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 26  

1537   4                                      p->Payload[num] = (BYTE)(DATA_Decimal);
1538   4                                      num++;
1539   4                                      //补充类
1540   4                                      if(EXTRA_ID == DATA_ID+1)
1541   4                                      {
1542   5                                              p->Payload[num] = EXTRA_ID;
1543   5                                              num++;
1544   5                                          p->Payload[num] = (EEPROM_Buffer[140]<<4)+ EEPROM_Buffer[411];
1545   5                                              num++;
1546   5                                              p->Payload[num] = (BYTE)(EXTRA_Integer>>8);
1547   5                                              num++;
1548   5                                              p->Payload[num] = (BYTE)(EXTRA_Integer);
1549   5                                              num++;
1550   5                                              p->Payload[num] = (BYTE)(EXTRA_Decimal>>8);
1551   5                                              num++;
1552   5                                              p->Payload[num] = (BYTE)(EXTRA_Decimal);
1553   5                                              num++;
1554   5                                      }
1555   4                              }
1556   3                      }
1557   2                      //再判断是否设置了ADC类
1558   2                      if(ADC_ID != 0xff)
1559   2                      {
1560   3                              //再判断初始化时间是否结束,是否有新上传
1561   3                              if((EEPROM_Buffer[86]==0)&&(EEPROM_Buffer[90]==1))
1562   3                              {
1563   4                                      p->Payload[num] = ADC_ID;
1564   4                                      num++;
1565   4                                  p->Payload[num] = (EEPROM_Buffer[84]<<4)+ EEPROM_Buffer[53];
1566   4                                      num++;
1567   4                                      p->Payload[num] = (BYTE)(ADC_Integer>>8);
1568   4                                      num++;
1569   4                                      p->Payload[num] = (BYTE)(ADC_Integer);
1570   4                                      num++;
1571   4                                      p->Payload[num] = (BYTE)(ADC_Decimal>>8);
1572   4                                      num++;
1573   4                                      p->Payload[num] = (BYTE)(ADC_Decimal);
1574   4                                      num++;
1575   4                              }
1576   3                              
1577   3                      }
1578   2      
1579   2                      //加插一个火警报警补充
1580   2                      if(EEPROM_Buffer[12] != 0xff){
1581   3                              if(test_315m == 0 && fire_sign==1){
1582   4      
1583   4                                      fire_sign = 0;
1584   4      
1585   4                                      SChar_Line = 0;                               
1586   4                                      SChar_Start = (BYTE)(276-256);
1587   4                                      SChar_Time = 10; 
1588   4                                      ShowLine(0,276);
1589   4                              
1590   4      
1591   4                                      p->Payload[num] = 0x0c;
1592   4                                      num++;
1593   4                                  p->Payload[num] = 0x01;
1594   4                                      num++;
1595   4                                      p->Payload[num] = 0;
1596   4                                      num++;
1597   4                                      p->Payload[num] = 0;
1598   4                                      num++;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 27  

1599   4                                      p->Payload[num] = 0;
1600   4                                      num++;
1601   4                                      p->Payload[num] = 0;
1602   4                                      num++;  
1603   4      
1604   4                                      Send_Buff1[0] = 0x32;
1605   4                                      Send_Buff1[1] = 0x37;
1606   4                                      Send_Num1 = 2;
1607   4                                      for(i=0;i<Send_Num1;i++)
1608   4                                      {
1609   5                                              SendData1(Send_Buff1[i]);
1610   5                                      }
1611   4                                      Send_Num1 = 0;
1612   4                              }
1613   3                      }
1614   2      
1615   2                       /** /
1616   2                      //有数据要发送
1617   2                  if(num>0)
1618   2                      {
1619   2                               //头处理
1620   2                               p->Mark_Head[0] = 0xa5;
1621   2                               p->Mark_Head[1] = 0x5a;
1622   2                               //目的地址需要计算
1623   2                               p->Des_Addr[0] = EEPROM_Buffer[301];
1624   2                               p->Des_Addr[1] = EEPROM_Buffer[302];
1625   2                               //本地地址写入
1626   2                               p->Src_Addr[0] = Src_Addr[0];
1627   2                               p->Src_Addr[1] = Src_Addr[1];
1628   2                               p->Seq_Num = Seq_Number;
1629   2                               Seq_Number++;
1630   2                               p->Command = 0xc;                                         //上传数据
1631   2                               p->Payload_Num = num;                                             //载荷长度
1632   2                               if(Send_Pri2<=1)
1633   2                               {
1634   2                                      for(i=0;i<num+9;i++)
1635   2                                      {
1636   2                                              Send_Buff2[i] = pro.Pro_Buff[i]; 
1637   2                                      }
1638   2                                      Send_Num2 = num +9;
1639   2                                      Send_Pri2 = 1;
1640   2                               }
1641   2                      }
1642   2                      /**/
1643   2      /*************************************数据发送处理************************************************/
1644   2                      if(ding)
1645   2                      {
1646   3                              if(Send_Pri2>0)
1647   3                              {                                                          
1648   4                                      //ShowLine(0,258);
1649   4                                      for(i=0;i<Send_Num2;i++)
1650   4                                      {
1651   5                                              SendData2(Send_Buff2[i]);
1652   5                                      }
1653   4                                      Send_Num2 = 0;
1654   4                                      Send_Pri2 = 0;  
1655   4                              }       
1656   3                      }
1657   2      /*************************************准备数据显示************************************************/
1658   2                      //先判断是否设置了数据类
1659   2                      if(DATA_ID != 0xff)
1660   2                      {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 28  

1661   3                              //再判断初始化时间是否结束,是否有新采集
1662   3                              if((EEPROM_Buffer[142]==0)&&((EEPROM_Buffer[145]==1)))
1663   3                              {
1664   4                                      //根据显示模式填写显示数据         0   12345   6789?
1665   4                                      integer = (DATA_Integer&0x7fff);
1666   4                                      decimal = (DATA_Decimal&0x7fff);
1667   4                                      WordToStr(integer,0);
1668   4                                  WordToStr(decimal,1);
1669   4                                      k = 0;
1670   4                                      for(i=0;i<EEPROM_Buffer[25];i++)
1671   4                                      {
1672   5                                              //处理显示行0 354 440
1673   5                                              //处理显示行1
1674   5                                              if(EEPROM_Buffer[i+120]==0x00)
1675   5                                              {
1676   6                                                      EEPROM_Buffer[i+476] = YES_NO[k];          //                            有无YN
1677   6                                                      k++;
1678   6                                                      if(k==2)
1679   6                                                              k=0;
1680   6                                              }
1681   5                                              else if((EEPROM_Buffer[i+120]<0x30)||(EEPROM_Buffer[i+120]>0x39))
1682   5                                  {
1683   6                                                      EEPROM_Buffer[i+476] = EEPROM_Buffer[i+120];
1684   6                                              }
1685   5                                              else if(EEPROM_Buffer[i+120] == 0x30)
1686   5                                              {
1687   6                                                      EEPROM_Buffer[i+476] = DATA_sign;       
1688   6                                              } else if((EEPROM_Buffer[i+120]>0x30)&&(EEPROM_Buffer[i+120]<=0x35))
1689   5                                              {
1690   6                                                      j = EEPROM_Buffer[i+120] -0x30-1;
1691   6                                                      EEPROM_Buffer[i+476] = str_i[j];
1692   6                                              }else if((EEPROM_Buffer[i+120]>0x35)&&(EEPROM_Buffer[i+120]<=0x39))
1693   5                                              {
1694   6                                                      j = EEPROM_Buffer[i+120]-5-0x30-1;                //6--str_d[1]
1695   6                                                      EEPROM_Buffer[i+476] = str_d[j];
1696   6                                              }
1697   5                                      }
1698   4                                      //补充，是否填写后两位报警和上传状态
1699   4                                      if(EEPROM_Buffer[109]==0)
1700   4                                      {
1701   5                                              j = EEPROM_Buffer[25]-1-3;
1702   5                                              EEPROM_Buffer[j+476] = 0x20;
1703   5                                              EEPROM_Buffer[j+477] = 0x20;    
1704   5                                      }
1705   4                                      if(EEPROM_Buffer[146]==0)
1706   4                                      {
1707   5                                              j = EEPROM_Buffer[25]-1-1;
1708   5                                              EEPROM_Buffer[j+476] = 0x20;
1709   5                                              EEPROM_Buffer[j+477] = 0x20;    
1710   5                                      }
1711   4                                      //补充类
1712   4                                      if(EXTRA_ID == DATA_ID+1)
1713   4                                      {
1714   5                                              //根据显示模式填写显示数据         0   12345   6789?
1715   5                                              integer = EXTRA_Integer;
1716   5                                              decimal = DATA_Decimal;
1717   5                                              WordToStr(integer,0);
1718   5                                          WordToStr(decimal,1);
1719   5                                              k = 0;
1720   5                                              for(i=0;i<EEPROM_Buffer[25];i++)
1721   5                                              {       
1722   6                                                      //处理显示行1
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 29  

1723   6                                                      if(EEPROM_Buffer[i+318]==0x00)
1724   6                                                      {
1725   7                                                              EEPROM_Buffer[i+422] = YES_NO[k];
1726   7                                                              k++;
1727   7                                                              if(k==2)
1728   7                                                                      k=0;
1729   7                                                      }else
1730   6                                                      if((EEPROM_Buffer[i+318]<0x30)||(EEPROM_Buffer[i+318]>0x39))
1731   6                                          {
1732   7                                                              EEPROM_Buffer[i+422] = EEPROM_Buffer[i+318];
1733   7                                                      }
1734   6                                                      else if(EEPROM_Buffer[i+318] == 0x30)
1735   6                                                      {
1736   7                                                              EEPROM_Buffer[i+422] = EXTRA_sign;      
1737   7                                                      } else if((EEPROM_Buffer[i+318]>0x30)&&(EEPROM_Buffer[i+318]<=0x35))
1738   6                                                      {
1739   7                                                              j = EEPROM_Buffer[i+318] -0x30-1;
1740   7                                                              EEPROM_Buffer[i+422] = str_i[j];
1741   7                                                      }else if((EEPROM_Buffer[i+318]>0x35)&&(EEPROM_Buffer[i+318]<=0x39))
1742   6                                                      {
1743   7                                                              j = EEPROM_Buffer[i+318]-5-0x30-1;                //6--str_d[1]
1744   7                                                              EEPROM_Buffer[i+422] = str_d[j];
1745   7                                                      }
1746   6                                              }
1747   5                                              //补充，是否填写后两位报警和上传状态
1748   5                                              if(EEPROM_Buffer[411]==0)
1749   5                                              {
1750   6                                                      j = EEPROM_Buffer[25]-1-3;
1751   6                                                      EEPROM_Buffer[j+422] = 0x20;
1752   6                                                      EEPROM_Buffer[j+423] = 0x20;    
1753   6                                              }
1754   5                                              if(EEPROM_Buffer[146]==0)
1755   5                                              {
1756   6                                                      j = EEPROM_Buffer[25]-1-1;
1757   6                                                      EEPROM_Buffer[j+422] = 0x20;
1758   6                                                      EEPROM_Buffer[j+423] = 0x20;    
1759   6                                              }       
1760   5                                      }//if(EXTRA_ID == DATA_ID)
1761   4                              }
1762   3                      }
1763   2      
1764   2                      //再判断是否设置了ADC类
1765   2                      if(ADC_ID != 0xff)
1766   2                      {
1767   3                              //再判断初始化时间是否结束,是否有新采集
1768   3                              if((EEPROM_Buffer[86]==0)&&((EEPROM_Buffer[89]==1)))
1769   3                              {
1770   4                                      //根据显示模式填写显示数据         0   12345   6789?
1771   4                                      WordToStr(ADC_Integer,0);
1772   4                                  WordToStr(ADC_Decimal,1);
1773   4                                      ADC_sign = 0x2b;
1774   4                                      k = 0;
1775   4                                      for(i=0;i<EEPROM_Buffer[25];i++)
1776   4                                      {
1777   5                                              //处理显示行0  336 458
1778   5                                              //处理显示行1
1779   5                                              if(EEPROM_Buffer[i+64]==0x00)
1780   5                                              {
1781   6                                                      EEPROM_Buffer[i+494] = YES_NO[k];
1782   6                                                      k++;
1783   6                                                      if(k==2)
1784   6                                                              k=0;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 30  

1785   6                                              }
1786   5                                              else if((EEPROM_Buffer[i+64]<0x30)||(EEPROM_Buffer[i+64]>0x39))
1787   5                                  {
1788   6                                                      EEPROM_Buffer[i+494] = EEPROM_Buffer[i+64];
1789   6                                              }
1790   5                                              else if(EEPROM_Buffer[i+64] == 0x30)
1791   5                                              {
1792   6                                                      EEPROM_Buffer[i+494] = ADC_sign;        
1793   6                                              } 
1794   5                                              else if((EEPROM_Buffer[i+64]>0x30)&&(EEPROM_Buffer[i+64]<=0x35))
1795   5                                              {
1796   6                                                      j = EEPROM_Buffer[i+64] -0x30-1;
1797   6                                                      EEPROM_Buffer[i+494] = str_i[j];
1798   6                                              }
1799   5                                              else if((EEPROM_Buffer[i+64]>0x35)&&(EEPROM_Buffer[i+64]<=0x39))
1800   5                                              {
1801   6                                                      j = EEPROM_Buffer[i+64]-5-0x30-1;                 //6--str_d[1]
1802   6                                                      EEPROM_Buffer[i+494] = str_d[j];
1803   6                                              }
1804   5                                      }
1805   4                                      //补充，是否填写后两位报警和上传状态
1806   4                                      if(EEPROM_Buffer[53]==0)
1807   4                                      {
1808   5                                              j = EEPROM_Buffer[25]-1-3;
1809   5                                              EEPROM_Buffer[j+494] = 0x20;
1810   5                                              EEPROM_Buffer[j+495] = 0x20;    
1811   5                                      }
1812   4                                      if(EEPROM_Buffer[90]==0)
1813   4                                      {
1814   5                                              j = EEPROM_Buffer[25]-1-1;
1815   5                                              EEPROM_Buffer[j+494] = 0x20;
1816   5                                              EEPROM_Buffer[j+495] = 0x20;    
1817   5                                      }       
1818   4                              }
1819   3                      }
1820   2                      
1821   2      /*************************************显示处理数据************************************************/
1822   2                      if(LCD_ID != 0xff)
1823   2                      {
1824   3                              k = 0;
1825   3                              //分屏处理
1826   3                              if(Screen_Num>0)                
1827   3                              {
1828   4                                      //准备要显示的数据,并布置屏幕（12864屏幕暂没有布置）
1829   4                                      if(Screen_Fresh_flag)
1830   4                                      {
1831   5                                              k = Screen_Array[Screen_Count]; 
1832   5                                              Screen_Fresh_flag = 0;
1833   5                                      }
1834   4                              }
1835   3                              //不分屏，只是要求显示时处理
1836   3                          else if(Show_ID>0)
1837   3                              {   
1838   4                                      k = Show_ID;
1839   4                                      Show_ID = 0;
1840   4                              }
1841   3                                      if(k>0)           //有变化
1842   3                                      {
1843   4                                              switch(k)
1844   4                                              {
1845   5                                                      case 3:
1846   5                                                              if(ADC_ID != 0xff)
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 31  

1847   5                                                              {
1848   6                                                                      if(EEPROM_Buffer[86]==0)
1849   6                                                                      {
1850   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1851   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1852   7                                                                              EEPROM_Buffer[30] = (BYTE)(336-256);
1853   7                                                                              if(EEPROM_Buffer[84]==0)
1854   7                                                                              {
1855   8                                                                                      //EEPROM_Buffer[30] = (BYTE)(458 - 256);
1856   8                                                                                      EEPROM_Buffer[31] = (BYTE)(494 - 256);              //刷新位置
1857   8                                                                              }else
1858   7                                                                              {
1859   8                                                                                      //EEPROM_Buffer[30] = 6;                                                        //显示空白
1860   8                                                                                      EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
1861   8                                                                              }
1862   7                                                                      }
1863   6                                                                      else
1864   6                                                                      {
1865   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1866   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1867   7                                                                              //EEPROM_Buffer[30] = 6;
1868   7                                                                              EEPROM_Buffer[30] = (BYTE)(336-256);
1869   7                                                                              EEPROM_Buffer[31] = 2;                                  //虚拟行显示,倒计时处理
1870   7                                                                      }
1871   6                                                              }
1872   5                                                              break;
1873   5                                                      case 4:
1874   5                                                              if(DATA_ID != 0xff)
1875   5                                                              {
1876   6                                                                      if(EEPROM_Buffer[142]==0)
1877   6                                                                      {
1878   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1879   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1880   7                                                                              EEPROM_Buffer[30] = (BYTE)(354-256);
1881   7                                                                              switch(EEPROM_Buffer[140])
1882   7                                                                              {
1883   8                                                                                      case 0x00:
1884   8                                                                                              //EEPROM_Buffer[30] = (BYTE)(440 - 256);             //刷新位置
1885   8                                                                                              EEPROM_Buffer[31] = (BYTE)(476 - 256);             //刷新位置
1886   8                                                                                              break;
1887   8                                                                                      case 0x01:
1888   8                                                                                              //EEPROM_Buffer[30] = 0; 
1889   8                                                                                              EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
1890   8                                                                                              break;
1891   8                                                                                      case 0x02:                                                                                               //85°问题
1892   8                                                                                              //EEPROM_Buffer[30] = 0; 
1893   8                                                                                              EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
1894   8                                                                                              break;       
1895   8                                                                                      default:
1896   8                                                                                              break;
1897   8                                                                              }
1898   7                                                                      }
1899   6                                                                      else
1900   6                                                                      {
1901   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1902   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1903   7                                                                              EEPROM_Buffer[30] = (BYTE)(354-256);
1904   7                                                                              //EEPROM_Buffer[30] = 6;
1905   7                                                                              EEPROM_Buffer[31] = 1;
1906   7                                                                      }
1907   6                                                              }
1908   5                                                              break;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 32  

1909   5                                                      case 6:
1910   5                                                              if((EXTRA_ID != 0xff)&&(DATA_ID==EXTRA_ID-1))
1911   5                                                              {
1912   6                                                                      if(EEPROM_Buffer[142]==0)
1913   6                                                                      {
1914   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1915   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1916   7                                                                              EEPROM_Buffer[30] = 354;
1917   7                                                                              switch(EEPROM_Buffer[140])
1918   7                                                                              {
1919   8                                                                                      case 0x00:
1920   8                                                                                              //EEPROM_Buffer[30] = (BYTE)(440 - 256);             //刷新位置
1921   8                                                                                              EEPROM_Buffer[31] = (BYTE)(422 - 256);             //刷新位置
1922   8                                                                                              break;
1923   8                                                                                      case 0x01:
1924   8                                                                                              //EEPROM_Buffer[30] = 0; 
1925   8                                                                                              EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
1926   8                                                                                              break;
1927   8                                                                                      case 0x02:                                                                                               //85°问题
1928   8                                                                                              //EEPROM_Buffer[30] = 0; 
1929   8                                                                                              EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
1930   8                                                                                              break;       
1931   8                                                                                      default:
1932   8                                                                                              break;
1933   8                                                                              }
1934   7                                                                      }
1935   6                                                                      else
1936   6                                                                      {
1937   7                                                                              EEPROM_Buffer[34] = 1;                                  //行0要求刷新
1938   7                                                                              EEPROM_Buffer[35] = 1;                                  //行1要求刷新
1939   7                                                                              EEPROM_Buffer[30] = (BYTE)(354-256);
1940   7                                                                              //EEPROM_Buffer[30] = 6;
1941   7                                                                              EEPROM_Buffer[31] = 1;
1942   7                                                                      }
1943   6                                                              }       
1944   5                                                              break;
1945   5                                                      default:
1946   5                                                              break;
1947   5                                              } 
1948   4                                              //特殊提示显示
1949   4                                              if(SChar_Time>0)
1950   4                                              {
1951   5                                                      EEPROM_Buffer[SChar_Line+34] = 1;
1952   5                                                      EEPROM_Buffer[SChar_Line+30] = SChar_Start;
1953   5                                                      SChar_Time =SChar_Time -1; 
1954   5                                              }
1955   4                                      }
1956   3                                      //逐行扫描是否需要刷新，并显示刷新内容
1957   3                                      for(i=0;i<4;i++)
1958   3                                      {
1959   4                                              if(EEPROM_Buffer[i+34]==1)                   //需要刷新
1960   4                                              {
1961   5                                                      j =  (WORD)EEPROM_Buffer[i+30] + 256;
1962   5                                                      ShowLine((BYTE)i,j);
1963   5                                                      EEPROM_Buffer[i+34] = 0;
1964   5                                              }       
1965   4                                      }
1966   3                              }
1967   2                      
1968   2      
1969   2                              
1970   2      /*************************************采集标志清零************************************************/
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 33  

1971   2                      if(DATA_ID != 0xff)
1972   2                      {
1973   3                              EEPROM_Buffer[145] = 0;
1974   3                              EEPROM_Buffer[146] = 0;
1975   3                      }       
1976   2                                                                 
1977   2                      if(ADC_ID != 0xff)
1978   2                      {
1979   3                              if(ADC_ID != 0x08)                 //08类特殊
1980   3                                      EEPROM_Buffer[89] = 0;
1981   3                              EEPROM_Buffer[90] = 0;
1982   3                      }
1983   2                      ding = 0;
1984   2                      /*************************************定时器定时中断到来处理**************************************/
1985   2                      if(Timer_Up0)   
1986   2                      {
1987   3                              Timer_Up0 = 0;
1988   3                              ding = 1;                                     //一次计数
1989   3                              
1990   3                              if(Screen_Fresh_Count<Screen_Fresh){
1991   4                                      Screen_Fresh_Count++;
1992   4                              }else{
1993   4                                      Screen_Fresh_Count = 0; 
1994   4                                      //分屏计数计算
1995   4                                      if(Screen_Num>0)
1996   4                                      {
1997   5                                              if(Screen_Count<Screen_Num-1)
1998   5                                              {
1999   6                                                      Screen_Count =  Screen_Count+1;
2000   6                                              }
2001   5                                              else
2002   5                                              {
2003   6                                                      Screen_Count = 0;       
2004   6                                              }
2005   5                                              Screen_Fresh_flag = 1;
2006   5                                      }
2007   4                              }
2008   3                              
2009   3                              if(ADC_ID != 0xff)
2010   3                              {
2011   4                                      if(EEPROM_Buffer[86]>0)
2012   4                                      {
2013   5                                              EEPROM_Buffer[86] = EEPROM_Buffer[86] - 1;      
2014   5                                      }
2015   4                                      if(EEPROM_Buffer[86]==0)
2016   4                                      {
2017   5                                              
2018   5                                              //采集处理
2019   5                                              if(ADC_Count>0)
2020   5                                              {
2021   6                                                      ADC_Count=ADC_Count-1;             //倒计时
2022   6                                              }
2023   5                                              else
2024   5                                              {
2025   6                                                      ADC_Count = EEPROM_Buffer[49];
2026   6                                                      //判断采集是否进行
2027   6                                                      if((EEPROM_Buffer[48]>0)&&(EEPROM_Buffer[48]<0xfc))
2028   6                                                      {
2029   7                                                              EEPROM_Buffer[89] = 1;  
2030   7                                                      }       
2031   6                                              }
2032   5                                              //上传处理
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 34  

2033   5                                              if(EEPROM_Buffer[88]>0)
2034   5                                              {
2035   6                                                      EEPROM_Buffer[88] = EEPROM_Buffer[88]-1;                   //倒计时
2036   6                                              }
2037   5                                              else
2038   5                                              {
2039   6                                                      EEPROM_Buffer[88] = EEPROM_Buffer[51];
2040   6                                                      if((EEPROM_Buffer[50]&0x02)==0x02)
2041   6                                                      {
2042   7                                                              //if((EEPROM_Buffer[95]>0)&&(EEPROM_Buffer[95]<0xfc))
2043   7                                                              {
2044   8                                                                      //EEPROM_Buffer[90] =1;
2045   8                                                                      //EEPROM_Buffer[95] = EEPROM_Buffer[95]-1;
2046   8                                                              }//else if(EEPROM_Buffer[95]==0xfc)
2047   7                                                              {
2048   8                                                                      EEPROM_Buffer[90] = 1;
2049   8                                                              }       
2050   7                                                      }               
2051   6                                              }               
2052   5                                      }
2053   4                              }
2054   3      
2055   3                              if(DATA_ID != 0xff)
2056   3                              {
2057   4                                      if(EEPROM_Buffer[142]>0)
2058   4                                      {
2059   5                                              EEPROM_Buffer[142]=EEPROM_Buffer[142] - 1;      
2060   5                                      }
2061   4                                      if(EEPROM_Buffer[142]==0)
2062   4                                      {
2063   5                                              //采集处理
2064   5                                              if(DATA_Count>0)
2065   5                                              {
2066   6                                                      DATA_Count = DATA_Count - 1;    
2067   6                                              }
2068   5                                              else
2069   5                                              {
2070   6                                                      DATA_Count = EEPROM_Buffer[105];
2071   6                                                      //判断采集是否进行
2072   6                                                      if((EEPROM_Buffer[104]>0)&&(EEPROM_Buffer[104]<0xfc))
2073   6                                                      {
2074   7                                                              EEPROM_Buffer[145] = 1; 
2075   7                                                      }               
2076   6                                              }
2077   5                                              
2078   5                                              //上传处理
2079   5                                              if(EEPROM_Buffer[144]>0)
2080   5                                              {
2081   6                                                      EEPROM_Buffer[144] = EEPROM_Buffer[144] - 1;    
2082   6                                              }
2083   5                                              else
2084   5                                              {
2085   6                                                      EEPROM_Buffer[144] = EEPROM_Buffer[107];
2086   6                                                      //取消判断上传是否进行
2087   6                                                      if((EEPROM_Buffer[106]&0x02)==0x02)
2088   6                                                      {
2089   7                                                              //if((EEPROM_Buffer[151]>0)&&(EEPROM_Buffer[151]<0xfc))
2090   7                                                              //{
2091   7                                                                      EEPROM_Buffer[146] = 1;
2092   7                                                                      //EEPROM_Buffer[151] = EEPROM_Buffer[151]-1;
2093   7                                                              //}else if(EEPROM_Buffer[151]==0xfc)
2094   7                                                              //{
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 35  

2095   7                                                                      //EEPROM_Buffer[146] = 1;
2096   7                                                              //}     
2097   7                                                      }       
2098   6                                              }               
2099   5                                      }
2100   4                              }
2101   3                              if((EXTRA_ID != 0xff)&&(EXTRA_ID == DATA_ID+1))
2102   3                              {
2103   4                                      
2104   4                                      
2105   4                              }
2106   3      
2107   3                      }
2108   2      /*************************************数据接收处理**************************************/
2109   2                      if(recv1){
2110   3                               Delayms(20);
2111   3                               if(SChar_Time == 0){
2112   4                                              SChar_Line = 0;                               
2113   4                                              SChar_Start = (BYTE)(257-256);
2114   4                                              SChar_Time = 4;   
2115   4                                              ShowLine(0,257);
2116   4                              }
2117   3                              ClearBuff1();
2118   3                      }
2119   2                      if(recv2)
2120   2                      {
2121   3                              Delayms(20);
2122   3                              //ClearPro_Buffer();
2123   3                              num = Get_Buff2(pro.Pro_Buff);
2124   3                              k = Parse(Src_Addr[0],Src_Addr[1],num);
2125   3                              if(k == 11){
2126   4                                      //0数据回复
2127   4                                      num = 0;
2128   4                                      if(SChar_Time == 0){
2129   5                                              SChar_Line = 0;                               
2130   5                                              SChar_Start = (BYTE)(275-256);
2131   5                                              SChar_Time = 4;   
2132   5                                              ShowLine(0,275);
2133   5                                      }
2134   4                              }
2135   3                              else if(k == 0)
2136   3                              {
2137   4                                      num = 0;
2138   4                                      k = p->Command;
2139   4                                      //解析数据并做适当处理
2140   4                                      switch(k&0x3f)
2141   4                                      {
2142   5                                              //与远程设备连接
2143   5                                              case 0x01:
2144   5                                                      p->Command = 0x02;
2145   5                                                      p->Payload_Num  = 0;
2146   5                                                      num = p->Payload_Num+9;
2147   5                                                      Remote_Addr[0] = p->Src_Addr[0];
2148   5                                                      Remote_Addr[1] = p->Src_Addr[1];
2149   5                                                      SChar_Line = 0;                               
2150   5                                                      SChar_Start = (BYTE)(274-256);
2151   5                                                  SChar_Time = 10;   
2152   5                                                      ShowLine(0,274);
2153   5                                                      break;
2154   5                                              case 0x02:
2155   5                                                      Remote_Addr[0] = p->Src_Addr[0];
2156   5                                                      Remote_Addr[1] = p->Src_Addr[1];
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 36  

2157   5                                                      SChar_Line = 0;                               
2158   5                                                      SChar_Start = (BYTE)(274-256);
2159   5                                                  SChar_Time = 10; 
2160   5                                                      ShowLine(0,274);
2161   5                                                      break;
2162   5                                              //与远程设备解除连接
2163   5                                              case 0x03:
2164   5                                                      p->Command = 0x04;
2165   5                                                      p->Payload_Num  = 0;
2166   5                                                      num = p->Payload_Num+9;
2167   5                                                      break;
2168   5                                              //获取设备版本及外设设置
2169   5                                              case 0x05:
2170   5                                                      p->Command = 0x06;
2171   5                                                      p->Payload_Num  = 8;
2172   5                                                      for(i=0;i<8;i++)
2173   5                                                      {
2174   6                                                              p->Payload[i] = EEPROM_Buffer[i];       
2175   6                                                      }
2176   5                                                      num = p->Payload_Num+9;
2177   5                                                      break;
2178   5                                              //任意位置EEPROM写30个字节,非用户指令
2179   5                                              case 0x07:
2180   5                                                      p->Payload[0] = Command_07();
2181   5                                                      switch(p->Payload[0])
2182   5                                                      {
2183   6                                                              case 0:                                                                 //锁传感器
2184   6                                                                      //LCD_ID = 0xff;
2185   6                                                                      ADC_ID = 0xff;
2186   6                                                                      DATA_ID = 0xff;
2187   6                                                                      EXTRA_ID = 0xff;
2188   6                                                                  EEPROM_Buffer[296] = 0;        //关闭心跳
2189   6                                                                      break;
2190   6                                                              case 4:
2191   6                                                                      break;
2192   6                                                              case 5:
2193   6                                                                      break;
2194   6                                                              default:
2195   6                                                                      break;
2196   6                                                      }
2197   5                                                      if(k&0x80)
2198   5                                                      {
2199   6                                                              p->Command = 0x08;
2200   6                                                              p->Payload_Num  = 1;
2201   6                                                              num = p->Payload_Num+9;
2202   6                                                      }
2203   5                                                      break;
2204   5                                              //设置采集资源参数
2205   5                                              case 0x09:
2206   5                                                      p->Payload[0] = Command_09();
2207   5                                                      switch(p->Payload[0])
2208   5                                                      {
2209   6                                                              case 0:
2210   6                                                                      if(k&0x40)                                                                               //需要保存，重启提示
2211   6                                                                      {
2212   7                                                                              IapEraseSector(0);                            //先擦后写
2213   7                                                                              WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2214   7                                                                              SChar_Line = 0;                               //提示重启
2215   7                                                                              SChar_Start = 4;
2216   7                                                                              SChar_Time = 5;                               //驻屏5S  
2217   7                                                                      }
2218   6                                                                      ADC_ID = 0xff;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 37  

2219   6                                                                      DATA_ID = 0xff;
2220   6                                                                      EXTRA_ID = 0xff;
2221   6                                                                      EEPROM_Buffer[296] = 0;                          //关闭心跳
2222   6                                                                      break;
2223   6                                                              case 5:
2224   6                                                                      break;
2225   6                                                              case 6:
2226   6                                                                      //提示没有匹配的设置
2227   6                                                                      SChar_Line = 0;                               
2228   6                                                                      SChar_Start = 5;
2229   6                                                                      SChar_Time = 5;                                  //驻屏5S
2230   6                                                                      break;
2231   6                                                              default:
2232   6                                                                      break;
2233   6                                                      }
2234   5                                                      
2235   5                                                      if(k&0x80)
2236   5                                                      {
2237   6                                                              p->Command = 0x0a;
2238   6                                                              p->Payload_Num  = 1;
2239   6                                                              num = p->Payload_Num+9;
2240   6                                                      }
2241   5                                                      break;
2242   5                                              //恢复出厂设置
2243   5                                              case 0x0D:
2244   5                                                      if(k&0x80)
2245   5                                                      {
2246   6                                                              p->Command = 0x0E;
2247   6                                                              p->Payload_Num  = 1;
2248   6                                                              p->Payload[0] = 0;                        //状态码
2249   6                                                              num = p->Payload_Num+9;
2250   6                                                      }
2251   5                                                      GetSector(1,EEPROM_Buffer);                   //EEPROM读取
2252   5                                                      Delayms(2);
2253   5                                                      IapEraseSector(0);                            //先擦后写
2254   5                                                      WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2255   5                                                      ADC_ID = 0xff;
2256   5                                                      DATA_ID = 0xff;
2257   5                                                      EXTRA_ID = 0xff;
2258   5                                                      EEPROM_Buffer[296] = 0;                       //关闭心跳
2259   5                                                      SChar_Line = 0;                               //提示恢复出厂设置
2260   5                                                      SChar_Start = 3;
2261   5                                                      SChar_Time = 5;                               //驻屏5S
2262   5                                                      break;
2263   5                                              //获取采集资源参数
2264   5                                              case 0x0F:
2265   5                                                      p->Payload[0] = Command_0F();
2266   5                                                      p->Command = 0x10;
2267   5                                                      switch(p->Payload[0])
2268   5                                                      {
2269   6                                                              case 0:
2270   6                                                                      //读取成功
2271   6                                                                      p->Payload_Num  = 30;
2272   6                                                                      num = p->Payload_Num+9;
2273   6                                                                      break;
2274   6                                                              case 5:
2275   6                                                                      p->Payload_Num  = 1;
2276   6                                                                      num = p->Payload_Num+9;
2277   6                                                                      break;
2278   6                                                              case 6:
2279   6                                                                      //提示没有匹配的设置
2280   6                                                                      SChar_Line = 0;                               
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 38  

2281   6                                                                      SChar_Start = 5;
2282   6                                                                      SChar_Time = 5;                                  //驻屏5S
2283   6                                                                      p->Payload_Num  = 1;
2284   6                                                                      num = p->Payload_Num+9;
2285   6                                                                      break;
2286   6                                                              default:
2287   6                                                                      p->Payload_Num  = 1;
2288   6                                                                      break;
2289   6                                                      }
2290   5                                                      break;
2291   5                                              //将现有状态存入EEPROM    
2292   5                                              case 0x11:
2293   5                                                      p->Payload[0] = Command_11();
2294   5                                                      switch(p->Payload[0])
2295   5                                                      {
2296   6                                                              case 0:
2297   6                                                                      ADC_ID = 0xff;
2298   6                                                                      DATA_ID = 0xff;
2299   6                                                                      EXTRA_ID = 0xff;
2300   6                                                                      EEPROM_Buffer[296] = 0;                       //关闭心跳
2301   6                                                                      SChar_Line = 0;                               //提示重启
2302   6                                                                      SChar_Start = 3;
2303   6                                                                      SChar_Time = 5;                               //驻屏5S
2304   6                                                                      break;
2305   6                                                              case 5:
2306   6                                                                      break;
2307   6                                                              default:
2308   6                                                                      break;
2309   6                                                      }
2310   5                                                      if(k&0x80)
2311   5                                                      {
2312   6                                                              p->Command = 0x12;
2313   6                                                              p->Payload_Num  = 1;
2314   6                                                              num = p->Payload_Num+9;
2315   6                                                      }
2316   5                                                      break;  
2317   5                                              //参数修改及配置
2318   5                                              case 0x13:
2319   5                                                      p->Payload[0] = Command_13();
2320   5                                                  switch(p->Payload[0])
2321   5                                                      {
2322   6                                                              case 0:
2323   6                                                                      if(k&0x40)
2324   6                                                                      {
2325   7                                                                              IapEraseSector(0);                            //先擦后写
2326   7                                                                              WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2327   7                                                                      }
2328   6                                                                      break;
2329   6                                                              case 5:
2330   6                                                                      break;
2331   6                                                              case 6:
2332   6                                                                      //提示没有匹配的设置
2333   6                                                                      SChar_Line = 0;                               
2334   6                                                                      SChar_Start = 5;
2335   6                                                                      SChar_Time = 5;                                  //驻屏5S
2336   6                                                                      break;
2337   6                                                              default:
2338   6                                                                      break;
2339   6                                                      }
2340   5                                                      if(k&0x80)
2341   5                                                      {
2342   6                                                              p->Command = 0x14;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 39  

2343   6                                                              p->Payload_Num  = 1;
2344   6                                                              num = p->Payload_Num+9;
2345   6                                                      }
2346   5                                                      break;
2347   5                                              //关闭传感器
2348   5                                              case 0x15:
2349   5                                                      p->Payload[0] = Command_15();
2350   5                                                  switch(p->Payload[0])
2351   5                                                      {
2352   6                                                              case 0:
2353   6                                                                      if(k&0x40)
2354   6                                                                      {
2355   7                                                                              IapEraseSector(0);                            //先擦后写
2356   7                                                                              WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2357   7                                                                              SChar_Line = 0;                               //提示重启
2358   7                                                                              SChar_Start = 4;
2359   7                                                                              SChar_Time = 5;                               //驻屏5S  
2360   7                                                                      }
2361   6                                                                      ADC_ID = 0xff;
2362   6                                                                      DATA_ID = 0xff;
2363   6                                                                      EXTRA_ID = 0xff;
2364   6                                                                      EEPROM_Buffer[296] = 0;                          //关闭心跳
2365   6                                                                      break;
2366   6                                                              case 5:
2367   6                                                                      break;
2368   6                                                              default:
2369   6                                                                      break;
2370   6                                                      }
2371   5                                                      if(k&0x80)
2372   5                                                      {
2373   6                                                              p->Command = 0x16;
2374   6                                                              p->Payload_Num  = 1;
2375   6                                                              num = p->Payload_Num+9;
2376   6                                                      }  
2377   5                                                      break;
2378   5                                              //显示设置,非用户指令
2379   5                                              case 0x17:
2380   5                                                      p->Payload[0] = Command_17();
2381   5                                                      switch(p->Payload[0])
2382   5                                                      {
2383   6                                                              case 0:
2384   6                                                                      if(k&0x40)
2385   6                                                                      {
2386   7                                                                              IapEraseSector(0);                            //先擦后写
2387   7                                                                              WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2388   7                                                                              SChar_Line = 0;                               //提示重启
2389   7                                                                              SChar_Start = 3;
2390   7                                                                              SChar_Time = 5;                               //驻屏5S
2391   7                                                                      }
2392   6                                                                      ADC_ID = 0xff;
2393   6                                                                      DATA_ID = 0xff;
2394   6                                                                      EXTRA_ID = 0xff;
2395   6                                                                      EEPROM_Buffer[296] = 0;                      //关闭心跳
2396   6                                                                      break;
2397   6                                                              case 5:
2398   6                                                                      break;
2399   6                                                              case 6:
2400   6                                                                      //提示没有匹配的设置
2401   6                                                                      SChar_Line = 0;                               
2402   6                                                                      SChar_Start = 5;
2403   6                                                                      SChar_Time = 5;                                  //驻屏5S
2404   6                                                                      break;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 40  

2405   6                                                              default:
2406   6                                                                      break;
2407   6                                                      }
2408   5                                                      if(k&0x80)
2409   5                                                      {
2410   6                                                              p->Command = 0x18;
2411   6                                                              p->Payload_Num  = 1;
2412   6                                                              num = p->Payload_Num+9;
2413   6                                                      }
2414   5                                                      break;
2415   5                                              //心跳设置,非用户指令
2416   5                                              case 0x19:
2417   5                                                      p->Payload[0] = Command_19();
2418   5                                                      if(k&0x40)
2419   5                                                      {
2420   6                                                              IapEraseSector(0);                            //先擦后写
2421   6                                                              WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2422   6                                                      }
2423   5                                                      if(k&0x80)
2424   5                                                      {
2425   6                                                              p->Command = 0x1A;
2426   6                                                              p->Payload_Num  = 1;
2427   6                                                              num = p->Payload_Num+9;
2428   6                                                      }
2429   5                                                      break;
2430   5                                              //STA家庭路由器设置
2431   5                                              case 0x1b:
2432   5                                                      p->Payload[0] = Command_1b();
2433   5                                                      if(p->Payload[0] == 0)
2434   5                                                      {
2435   6                                                              EEPROM_Buffer[160] = 0;
2436   6                                                              if(k&0x40)
2437   6                                                              {
2438   7                                                                      IapEraseSector(0);                            //先擦后写
2439   7                                                                      WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2440   7                                                              }
2441   6                                                      }
2442   5                                                      if(k&0x80)
2443   5                                                      {
2444   6                                                              p->Command = 0x1c;
2445   6                                                              p->Payload_Num  = 1;
2446   6                                                              num = p->Payload_Num+9;
2447   6                                                      }
2448   5                                                      break;
2449   5                                              //服务器IP和端口设置
2450   5                                              case 0x1d:
2451   5                                                      p->Payload[0] = Command_1d();
2452   5                                                      if(p->Payload[0] == 0)
2453   5                                                      {
2454   6                                                              EEPROM_Buffer[160] = 0;
2455   6                                                              if(k&0x40)
2456   6                                                              {
2457   7                                                                      IapEraseSector(0);                            //先擦后写
2458   7                                                                      WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
2459   7                                                              }
2460   6                                                      }
2461   5                                                      if(k&0x80)
2462   5                                                      {
2463   6                                                              p->Command = 0x1e;
2464   6                                                              p->Payload_Num  = 1;
2465   6                                                              num = p->Payload_Num+9;
2466   6                                                      }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 41  

2467   5                                                      break;
2468   5                                              case 0x1f:
2469   5                                                      p->Payload[0] = Command_1f();
2470   5                                                      p->Command = 0x20;
2471   5                                                      if(p->Payload[0] == 0)
2472   5                                                      {
2473   6                                                              p->Payload_Num  = 20;
2474   6                                                      }
2475   5                                                      else
2476   5                                                      {
2477   6                                                              p->Payload_Num  = 1;
2478   6                                                      }
2479   5                                                      num = p->Payload_Num+9;
2480   5                                                      break;
2481   5                                              case 0x2f:
2482   5                                                      Server_Flag = 1;
2483   5                                                      EEPROM_Buffer[278] = 0;            //建立连接
2484   5                                                      if(EEPROM_Buffer[1]==0x13)
2485   5                                                      {
2486   6                                                              //EEPROM_Buffer[318] = 0x5b;
2487   6                                                              //EEPROM_Buffer[319] = 0x5d;
2488   6                                                              //EEPROM_Buffer[336] = 0x5b;
2489   6                                                              //EEPROM_Buffer[337] = 0x5d;
2490   6                                                              //EEPROM_Buffer[354] = 0x5b;
2491   6                                                              //EEPROM_Buffer[355] = 0x5d;
2492   6                                                      }
2493   5                                                      else if(EEPROM_Buffer[1]==0x14)
2494   5                                                      {
2495   6                                                              //EEPROM_Buffer[318] = 0x01;
2496   6                                                              //EEPROM_Buffer[319] = 0x5d;
2497   6                                                              //EEPROM_Buffer[336] = 0x01;
2498   6                                                              //EEPROM_Buffer[337] = 0x5d;
2499   6                                                              //EEPROM_Buffer[354] = 0x01;
2500   6                                                      //      EEPROM_Buffer[355] = 0x5d;
2501   6                                                      }
2502   5                                                      break;
2503   5                                              default:
2504   5                                                      break;  
2505   5                                      }
2506   4                                      if(num>0)
2507   4                                      {
2508   5                                              //头处理
2509   5                                              p->Mark_Head[0] = 0xa5;
2510   5                                              p->Mark_Head[1] = 0x5a;
2511   5                                              p->Des_Addr[0] = p->Src_Addr[0];
2512   5                                              p->Des_Addr[1] = p->Src_Addr[1];
2513   5                                              p->Src_Addr[0] = Src_Addr[0];
2514   5                                              p->Src_Addr[1] = Src_Addr[1];
2515   5                                              p->Seq_Num = Seq_Number;
2516   5                                              Seq_Number++;
2517   5                                              if(Send_Pri2<=3)
2518   5                                              {
2519   6                                                      for(i=0;i<p->Payload_Num+9;i++)
2520   6                                                      {
2521   7                                                              Send_Buff2[i] = pro.Pro_Buff[i]; 
2522   7                                                      }
2523   6                                                      Send_Num2 = p->Payload_Num +9;
2524   6                                                      Send_Pri2 = 3;
2525   6                                              }
2526   5                                      }
2527   4                              }else{
2528   4                                      //回复数据的格式错误或未知的回复数据
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 42  

2529   4                                      SChar_Line = 0;                               
2530   4                                      SChar_Start = (BYTE)(272-256);
2531   4                                      SChar_Time = 10;   
2532   4                                      ShowLine(0,273);
2533   4                              }
2534   3                      }       //if(recv2)
2535   2              }
2536   1      }
2537          //===========采集类参数初始化==================
2538          void ADC_P_Init()
2539          {
2540   1              //初始化时间缓存
2541   1          if(EEPROM_Buffer[83]>EEPROM_Buffer[5])
2542   1              {
2543   2                      EEPROM_Buffer[86] = EEPROM_Buffer[83] - EEPROM_Buffer[5];       
2544   2              }
2545   1              else
2546   1              {
2547   2                      EEPROM_Buffer[86] = 0;  
2548   2              }
2549   1              EEPROM_Buffer[84] = 0;                                   //初始认为无故障
2550   1              ADC_Count = EEPROM_Buffer[87];                   //初始采集时间计数手动在EEPROM中控制
2551   1              EEPROM_Buffer[88] = 0;                                   //初始上传时间计数为0
2552   1              EEPROM_Buffer[89] = 0;                   //初始采集状态不采集
2553   1          EEPROM_Buffer[90] = 0;                                       //初始上传状态不上传
2554   1              EEPROM_Buffer[95] = 0;                                   //初始上传状态不上传
2555   1              EEPROM_Buffer[53] = 0;                                   //初始报警状态不报警
2556   1              ADC_100 = ((WORD)EEPROM_Buffer[96]<<8)+(WORD)EEPROM_Buffer[97];
2557   1              ADC_0 = ((WORD)EEPROM_Buffer[98]<<8)+(WORD)EEPROM_Buffer[99];
2558   1      }
2559          
2560          void DATA_P_Init()
2561          {
2562   1              //初始化时间缓存
2563   1          if(EEPROM_Buffer[139]>EEPROM_Buffer[5])
2564   1              {
2565   2                      EEPROM_Buffer[142] = EEPROM_Buffer[139] - EEPROM_Buffer[5];     
2566   2              }
2567   1              else
2568   1              {
2569   2                      EEPROM_Buffer[142] = 0; 
2570   2              }
2571   1              EEPROM_Buffer[140] = 0;                                  //初始认为无故障
2572   1              DATA_Count = EEPROM_Buffer[143];                 //初始采集时间计数手动在EEPROM中控制
2573   1              EEPROM_Buffer[144] = 0;                                  //初始上传时间计数为0
2574   1              EEPROM_Buffer[145] = 0;                  //初始采集状态不采集
2575   1          EEPROM_Buffer[146] = 0;                                      //初始上传状态不上传
2576   1              //EEPROM_Buffer[151] = 0;                                    //初始上传状态不上传
2577   1              EEPROM_Buffer[109] = 0;                                  //初始报警状态不报警
2578   1              DATA_100 = ((WORD)EEPROM_Buffer[152]<<8)+(WORD)EEPROM_Buffer[153];
2579   1              DATA_0 = ((WORD)EEPROM_Buffer[154]<<8)+(WORD)EEPROM_Buffer[155];
2580   1      }
2581          
2582          void EXTRA_P_Init()
2583          {
2584   1              EEPROM_Buffer[411] = 0;                                  //初始报警状态不报警   
2585   1      }
2586          //===========定时器+串口处理===================
2587          void Timer_Uart_Init()
2588          {
2589   1              busy1 = 0;
2590   1              busy2 = 0;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 43  

2591   1              recv1 = 0;
2592   1              recv2 = 0;
2593   1              Recv_Num1 = 0;
2594   1              Recv_Num2 = 0;
2595   1      
2596   1              AUXR = 0x14;//0x94;                                     //0x94 Timer0不分频，Timer1 12分频
2597   1              SCON = 0xda;                                                                                     //9位UART 波特率可变 
2598   1              S2CON = 0xda;                                                                                    //UART2 9位UART 波特率可变 
2599   1              TMOD = 0x21;                                     //Set Timer1 as 8-bit auto reload mode,set timer0 as mod
             -e1 (16-bit)
2600   1              //Set auto-reload vaule  UART2 Set auto-reload vaule of baudrate generator
2601   1              if(EEPROM_Buffer[16] == 1)
2602   1              {
2603   2              TH1 = TL1 = -(FOSC/12/32/BAUD0);              
2604   2                      BRT = -(FOSC/32/BAUD0);                       
2605   2              }else if(EEPROM_Buffer[16] == 0)
2606   1              {
2607   2                      TH1 = TL1 = -(FOSC/12/32/BAUD1);              
2608   2                      BRT = -(FOSC/32/BAUD1); 
2609   2              }
2610   1              TL0 = T1MS;                                      //initial timer0 low byte
2611   1        TH0 = T1MS >> 8;                                 //initial timer0 high byte   
2612   1        TR1 = 1;                                                                                      //Timer1 start run
2613   1              ES = 1;                                       //Enable UART interrupt
2614   1        IE2 = 0x01;                                     //Enable UART2 interrupt
2615   1        EA = 1;                                                                                        //Open master interrupt switch
2616   1      }
2617          
2618          //定时器0部分
2619          void Start_Timer0(WORD count,bit Mode)
2620          {
2621   1              //EA = 0;
2622   1              Timer_Count0 = count;
2623   1              if(Mode)                                                                         //循环模式
2624   1              {
2625   2                      TimerNum0 = count;
2626   2              }
2627   1              else                                                                                     //1次性模式
2628   1              {
2629   2                      TimerNum0 = 0;
2630   2              }
2631   1              TR0 = 1;                                         //timer0 start running
2632   1              ET0 = 1;                                         //enable timer0 interrupt 
2633   1              //EA = 1; 
2634   1      }
2635          
2636          /*
2637          void Stop_Timer0()
2638          {
2639                  EA = 0;
2640              TR0 = 0;                                         //timer0 start running
2641                  ET0 = 0;                                         //enable timer0 interrupt 
2642                  EA = 1; 
2643          }
2644          */
2645          
2646          //External interrupt0 service routine
2647          void exint0() interrupt 0           //(location at 0003H)
2648          {
2649   1              //P25 = 0;      
2650   1              fire_sign=1;    
2651   1      }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 44  

2652          
2653          void tm0_isr() interrupt 1 using 0
2654          {
2655   1      EA = 0;
2656   1          TL0 = T1MS;                                     //reload timer0 low byte
2657   1          TH0 = T1MS >> 8;                                //reload timer0 high byte
2658   1          if (Timer_Count0-- == 0)                         //1ms * 1000 -> 1s
2659   1          {
2660   2              Timer_Count0 = TimerNum0;                     //reset counter
2661   2                                      Timer_Up0 = 1;
2662   2          }
2663   1      EA =1;
2664   1      }
2665          
2666          //串口2部分
2667          void Uart2() interrupt 8 using 2
2668          {
2669   1      EA =0;
2670   1          if (S2CON & S2RI)
2671   1          {
2672   2              S2CON &= ~S2RI;     //Clear receive interrupt flag
2673   2                      if(Recv_Num2 == MaxRecvBuff2)
2674   2                      {
2675   3                              Recv_Num2 = 0;
2676   3                      } 
2677   2                      Recv_Buff2[Recv_Num2++] = S2BUF;
2678   2                  recv2 = 1;
2679   2          }
2680   1          if (S2CON & S2TI)
2681   1          {
2682   2              S2CON &= ~S2TI;     //Clear transmit interrupt flag
2683   2              busy2 = 0;           //Clear transmit busy flag
2684   2          }
2685   1      EA =1;
2686   1      }
2687          
2688          void SendData2(BYTE dat)
2689          {
2690   1          while (busy2);           //Wait for the completion of the previous data is sent
2691   1          ACC = dat;              //Calculate the even parity bit P (PSW.0)
2692   1          if (P)                  //Set the parity bit according to P
2693   1          {
2694   2              S2CON |= S2TB8;     //Set parity bit to 1
2695   2          }
2696   1          else
2697   1          {
2698   2              S2CON &= ~S2TB8;    //Set parity bit to 0
2699   2          }
2700   1          busy2 = 1;
2701   1          S2BUF = ACC;            //Send data to UART2 buffer
2702   1      }
2703          
2704          void SendString2(char *s)
2705          {
2706   1          while (*s)              //Check the end of the string
2707   1          {
2708   2              SendData2(*s++);     //Send current char and increment string ptr
2709   2          }
2710   1      }
2711          
2712          BYTE Get_Buff2(BYTE * Buffer)
2713          {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 45  

2714   1              BYTE i,num;
2715   1              IE2 = 0x00;
2716   1              if(recv2)
2717   1              {
2718   2                      for(i=0;i<Recv_Num2;i++)
2719   2                      {
2720   3                              Buffer[i] = Recv_Buff2[i];
2721   3                      }
2722   2                      num = Recv_Num2;
2723   2              }
2724   1              else
2725   1              {
2726   2                      num = 0;
2727   2              }
2728   1              recv2 = 0;
2729   1              Recv_Num2 = 0;
2730   1              IE2 = 0x01;
2731   1              return num;
2732   1      }
2733          
2734          void ClearBuff2()
2735          {
2736   1              IE2 = 0x00;
2737   1              recv2 = 0;
2738   1              Recv_Num2 = 0;
2739   1              IE2 = 0x01;
2740   1      }
2741          
2742          /*----------------------------
2743          串口1部分
2744          ----------------------------*/
2745          void Uart_Isr() interrupt 4 using 1
2746          {
2747   1          if (RI)
2748   1          {
2749   2              RI = 0;             //Clear receive interrupt flag
2750   2              
2751   2                      if(Recv_Num1 == MaxRecvBuff1)
2752   2                      {
2753   3                              Recv_Num1 = 0;
2754   3                      } 
2755   2                      Recv_Buff1[Recv_Num1++] = SBUF;
2756   2                  recv1 = 1;
2757   2          }
2758   1          if (TI)
2759   1          {
2760   2              TI = 0;             //Clear transmit interrupt flag
2761   2              busy1 = 0;           //Clear transmit busy flag
2762   2          }
2763   1      }
2764          
2765          /*----------------------------
2766          Send a byte data to UART
2767          Input: dat (data to be sent)
2768          Output:None
2769          ----------------------------*/
2770          void SendData1(BYTE dat)
2771          {
2772   1          while (busy1);           //Wait for the completion of the previous data is sent
2773   1          ACC = dat;              //Calculate the even parity bit P (PSW.0)
2774   1          if (P)                  //Set the parity bit according to P
2775   1          {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 46  

2776   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;            //Set parity bit to 0
              #elif (PARITYBIT == EVEN_PARITY)
2779   2              TB8 = 1;            //Set parity bit to 1
2780   2      #endif
2781   2          }
2782   1          else
2783   1          {
2784   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;            //Set parity bit to 1
              #elif (PARITYBIT == EVEN_PARITY)
2787   2              TB8 = 0;            //Set parity bit to 0
2788   2      #endif
2789   2          }
2790   1          busy1 = 1;
2791   1          SBUF = ACC;             //Send data to UART buffer
2792   1      }
2793          
2794          /*----------------------------
2795          Send a string to UART
2796          Input: s (address of string)
2797          Output:None
2798          ----------------------------*/
2799          void SendString1(char *s)
2800          {
2801   1          while (*s)              //Check the end of the string
2802   1          {
2803   2              SendData1(*s++);     //Send current char and increment string ptr
2804   2          }
2805   1      }
2806          
2807          BYTE Get_Buff1(BYTE * Buffer)
2808          {
2809   1              BYTE i,num;
2810   1              ES = 0;
2811   1              if(recv1)
2812   1              {
2813   2                      for(i=0;i<Recv_Num1;i++)
2814   2                      {
2815   3                              Buffer[i] = Recv_Buff1[i];
2816   3                      }
2817   2                      num = Recv_Num1;
2818   2              }
2819   1              else
2820   1              {
2821   2                      num = 0;
2822   2              }
2823   1              recv1 = 0;
2824   1              Recv_Num1 = 0;
2825   1              ES = 1;
2826   1              return num;
2827   1      }
2828          
2829          void ClearBuff1()
2830          {
2831   1              ES = 0;
2832   1              recv1 = 0;
2833   1              Recv_Num1 = 0;
2834   1              ES = 1;
2835   1      }
2836          
2837          //==============WORD与字符串转换==========0：保存在str_i中  1：保存在str_d中
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 47  

2838          void WordToStr(unsigned int integer,BYTE num)
2839          {
2840   1              unsigned long temp,temp1;
2841   1              unsigned char i;
2842   1              //截取相应的位数
2843   1              temp = integer;
2844   1              EA = 0;
2845   1              for(i=5;i>0;i--)
2846   1              {
2847   2                      temp1 = temp%10;
2848   2                      if(num==0)
2849   2                      {
2850   3                              if((temp1>=0x00)&&(temp1<=0x09))
2851   3                                      str_i[i-1] = temp1+0x30;
2852   3                              else
2853   3                                      str_i[i-1] = 0x30;      
2854   3                      }
2855   2                      else if(num==1)
2856   2                      {
2857   3                              if((temp1>=0x00)&&(temp1<=0x09))
2858   3                                      str_d[i-1] = temp1+0x30;
2859   3                              else
2860   3                                      str_d[i-1] = 0x30;      
2861   3                      }
2862   2                      temp = temp - temp1;
2863   2                      temp = temp/10;
2864   2              }
2865   1              EA = 1;
2866   1      }
2867          
2868          //================wifi=======================
2869          //进入命令模式
2870          void Wifi_CMode()
2871          {
2872   1              SendString2("+++");
2873   1              Delayms(Recv_DelayTime2);
2874   1              SendData2('a');
2875   1              Delayms(Recv_DelayTime2);
2876   1              SendString2("AT+E=off");
2877   1              SendData2(0x0d);
2878   1              Delayms(Recv_DelayTime2);
2879   1              Delayms(Recv_DelayTime2);
2880   1              Delayms(Recv_DelayTime2);
2881   1      }
2882          
2883          //返回透传模式
2884          void Wifi_TMode()
2885          {
2886   1              SendString2("AT+ENTM");
2887   1              SendData2(0x0d);
2888   1              Delayms(Recv_DelayTime2);
2889   1              Delayms(Recv_DelayTime2);
2890   1              ClearBuff2();
2891   1      }
2892          
2893          //httpd模式
2894          void Wifi_HTTPD_GET()
2895          {
2896   1              BYTE i,j;
2897   1              BYTE flag = 0;
2898   1              /**/
2899   1          SendString2("AT+HTPTP=POST");
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 48  

2900   1              SendData2(0x0d);
2901   1              Delayms(Recv_DelayTime2);
2902   1              Delayms(Recv_DelayTime2);
2903   1              //公网：219.147.163.225,9090 
2904   1              //内网：192.168.9.81,90  
2905   1              //192.168.0.10,82  
2906   1              //129.168.13.180,80      
2907   1              SendString2("AT+HTPSV=192.168.9.81,90");
2908   1              /*for(i=0;i<4;i++){
2909   1                      flag = 0;
2910   1                      for(j=0;j<3;j++){
2911   1                              if((EEPROM_Buffer[279+i*3+j]!=0x30)||j==2){
2912   1                                      flag = 1;
2913   1                              }
2914   1                              if(flag == 1){
2915   1                                      SendData2(EEPROM_Buffer[279+i*3+j]);
2916   1                              }
2917   1                      }
2918   1                      if(i<3){
2919   1                              SendData2('.');
2920   1                      }
2921   1              }
2922   1              SendData2(',');
2923   1              flag = 0;
2924   1              for(i=0;i<5;i++){
2925   1                      if((EEPROM_Buffer[291+i]!=0x30)||i==4){
2926   1                                      flag = 1;
2927   1                              }
2928   1                              if(flag == 1){
2929   1                                      SendData2(EEPROM_Buffer[291+i]);
2930   1                              }
2931   1              }*/     
2932   1              SendData2(0x0d);
2933   1              Delayms(Recv_DelayTime2);
2934   1              Delayms(Recv_DelayTime2);
2935   1              SendString2("AT+HTPURL=/indexs.php");
2936   1              SendData2(0x0d);                  
2937   1              Delayms(Recv_DelayTime2);
2938   1              Delayms(Recv_DelayTime2);
2939   1              SendString2("AT+HTPTO=10");
2940   1              SendData2(0x0d);
2941   1              Delayms(Recv_DelayTime2);
2942   1              Delayms(Recv_DelayTime2);
2943   1                      /**/
2944   1              SendString2("AT+HTPHD=Accept:text/html[0D][0A]Accept-Language:en[0D][0A]User-Agent:Mozilla/5.0[0D][0A]Con
             -nection:Keep-Alive[0D][0A]");
2945   1              SendData2(0x0d);
2946   1              Delayms(Recv_DelayTime2);
2947   1              Delayms(Recv_DelayTime2);
2948   1              SendString2("AT+HTPFT=ON");
2949   1              SendData2(0x0d);
2950   1              Delayms(Recv_DelayTime2);
2951   1              Delayms(Recv_DelayTime2);
2952   1      
2953   1              /*
2954   1              SendString2("AT+TMODE");
2955   1              SendData2(0x0d);
2956   1              Delayms(Recv_DelayTime2);
2957   1              Delayms(Recv_DelayTime2);
2958   1              if(recv2)
2959   1              {
2960   1                      ShowLine(0,273);
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 49  

2961   1              }*/
2962   1              //Delayms(2000);
2963   1              SendString2("AT+TMODE=htpc");
2964   1              SendData2(0x0d);
2965   1              Delayms(Recv_DelayTime2);
2966   1              Delayms(Recv_DelayTime2);
2967   1      }
*** WARNING C280 IN LINE 2896 OF MAIN.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 2896 OF MAIN.C: 'j': unreferenced local variable
2968          
2969          //检测服务器是否连接
2970          /*
2971               0         已连接
2972                   1         断开
2973                   2         没有检查到数据
2974                   3         数据长度不对
2975                   4-7       数据无意义
2976                   0x31      无效命令格式
2977                   0x32      无效命令
2978                   0x33      无效的操作符
2979                   0x34      无效的参数
2980                   0x35      操作不允许 
2981          */
2982          /*
2983          BYTE GetSockBStatus()
2984          {
2985                  BYTE status;
2986                  ClearBuff2();
2987                  SendString2("AT+TCPLKB");
2988                  SendData2(0x0d);
2989                  Delayms(Recv_DelayTime2);
2990                  Delayms(Recv_DelayTime2);
2991                  if(recv2)
2992                  {
2993                          if(Recv_Buff2[0] == '+')
2994                          {
2995                                  if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
2996                                  {
2997                                          switch(Recv_Buff2[5])
2998                                          {
2999                                                  case 0x6e:
3000                                                          status = 0;
3001                                                          break;
3002                                                  case 0x66:
3003                                                          status = 1;
3004                                                          break;
3005                                                  default:
3006                                                      status = 4;
3007                                                          break;
3008                                          }
3009                                  }
3010                                  else if((Recv_Buff2[1] == 'E')&&(Recv_Buff2[2] == 'R'))
3011                                  {
3012                                          switch(Recv_Buff2[6])
3013                                          {
3014                                                  case 0x31:
3015                                                  case 0x32:
3016                                                  case 0x33:
3017                                                  case 0x34:
3018                                                  case 0x35:
3019                                                          status = Recv_Buff2[6];
3020                                                          break;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 50  

3021                                                  default:
3022                                                          status = 5;
3023                                                          break;
3024                                          }
3025                                  }else
3026                                  {
3027                                          status = 6;     
3028                                  }
3029                                  
3030                          }else
3031                          {
3032                                  status = 7;
3033                          }
3034                  }
3035                  else
3036                  {
3037                          status = 2;
3038                  }
3039                  //ClearBuff2();
3040                  return status;
3041          }
3042          */
3043          //获取工作模式
3044          /*
3045                   1         AP
3046                   2         STA
3047                   3         错误
3048                   4                 APSTA
3049          */
3050          BYTE Get_Mode()
3051          {
3052   1              BYTE status;
3053   1              ClearBuff2();
3054   1              SendString2("AT+WMODE");
3055   1              SendData2(0x0d);
3056   1              Delayms(Recv_DelayTime2);
3057   1              Delayms(Recv_DelayTime2);
3058   1              Delayms(Recv_DelayTime2);
3059   1              if(recv2)
3060   1              {
3061   2                      if(Recv_Buff2[0] == '+')
3062   2                      {
3063   3                              if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
3064   3                              {
3065   4                                      if((Recv_Buff2[4] == 'A')&&(Recv_Buff2[5] == 'P')){
3066   5                                              if(Recv_Buff2[6] == 'S')
3067   5                                                      status = 4;
3068   5                                              else
3069   5                                                      status = 1;       
3070   5                                              return status;
3071   5                                      }                                       
3072   4                                      else if((Recv_Buff2[4] == 'S')&&(Recv_Buff2[5] == 'T')){
3073   5                                              status = 2;
3074   5                                              return status;
3075   5                                      }
3076   4                              }
3077   3                              
3078   3                      }
3079   2              }
3080   1              status = 3;
3081   1              //ClearBuff2();
3082   1              return status;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 51  

3083   1      }
3084          
3085          /*
3086                   0         连接成功
3087                   1         无连接
3088                   2         RF被关闭
3089                   3         错误
3090          */
3091          BYTE Get_WSLK()
3092          {
3093   1              BYTE status;
3094   1              ClearBuff2();
3095   1              SendString2("AT+WSLK");
3096   1              SendData2(0x0d);
3097   1              Delayms(Recv_DelayTime2);
3098   1              Delayms(Recv_DelayTime2);
3099   1              if(recv2)
3100   1              {
3101   2                      if(Recv_Buff2[0] == '+')
3102   2                      {
3103   3                              if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
3104   3                              {
3105   4                                      if((Recv_Buff2[4] == 'D')&&(Recv_Buff2[5] == 'I')&&(Recv_Buff2[6] == 'S')){
3106   5                                              status = 1;
3107   5                                              return status;
3108   5                                      }                                       
3109   4                                      else if((Recv_Buff2[4] == 'R')&&(Recv_Buff2[5] == 'F')&&(Recv_Buff2[6] == ' ')){
3110   5                                              status = 2;
3111   5                                              return status;
3112   5                                      }else{
3113   5                                              status = 0;
3114   5                                              ShowLine(0,273);
3115   5                                              return status;
3116   5                                      }
3117   4                              }                       
3118   3                      }
3119   2              }
3120   1              status = 3;
3121   1              //ClearBuff2();
3122   1              return status;
3123   1      }
3124          
3125          /*
3126                   0         ping成功
3127                   1         超时
3128                   2         找不到主机
3129                   3         错误
3130          */
3131          BYTE PING_IP_ADDR(){
3132   1              BYTE status;
3133   1              BYTE flag =0;
3134   1              BYTE i;
3135   1              BYTE j;
3136   1              ClearBuff2();
3137   1              SendString2("AT+PING=");
3138   1              for(i=0;i<4;i++){
3139   2                      flag = 0;
3140   2                      for(j=0;j<3;j++){
3141   3                              if((EEPROM_Buffer[279+i*4+j]!=0x30)||j==2){
3142   4                                      flag = 1;
3143   4                              }
3144   3                              if(flag == 1){
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 52  

3145   4                                      SendData2(EEPROM_Buffer[279+i*4+j]);
3146   4                              }
3147   3                      }
3148   2                      if(i<3){
3149   3                              SendData2('.');
3150   3                      }
3151   2              }                                                                        
3152   1              SendData2(0x0d);
3153   1              Delayms(Recv_DelayTime2);
3154   1              Delayms(Recv_DelayTime2);
3155   1              Delayms(5000);
3156   1              if(recv2)
3157   1              {
3158   2                      if(Recv_Buff2[0] == '+')
3159   2                      {
3160   3                              if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
3161   3                              {
3162   4                                      if((Recv_Buff2[4] == 'S')&&(Recv_Buff2[5] == 'u')&&(Recv_Buff2[6] == 'c')){
3163   5                                              status = 0;
3164   5                                              return status;
3165   5                                      }                                       
3166   4                                      else if((Recv_Buff2[4] == 'T')&&(Recv_Buff2[5] == 'i')&&(Recv_Buff2[6] == 'm')){
3167   5                                              status = 1;
3168   5                                              return status;
3169   5                                      }else if((Recv_Buff2[4] == 'U')&&(Recv_Buff2[5] == 'n')&&(Recv_Buff2[6] == 'k')){
3170   5                                              status = 2;
3171   5                                              return status;
3172   5                                      }
3173   4                              }
3174   3                              
3175   3                      }
3176   2              }
3177   1              status = 3;
3178   1              //ClearBuff2();
3179   1              return status;
3180   1      }
3181          
3182          void Wifi_MDCH(){
3183   1              SendString2("AT+MDCH=ON");
3184   1              SendData2(0x0d);
3185   1              Delayms(Recv_DelayTime2);
3186   1              Delayms(Recv_DelayTime2);       
3187   1      }
3188          
3189          //重启
3190          void Wifi_ReStart()
3191          {
3192   1              SendString2("AT+Z");
3193   1              SendData2(0x0d);
3194   1      }
3195          
3196          //重启2
3197          void Wifi_ReStart2()
3198          {
3199   1              wifi_reset = 0;
3200   1              Delayms(600);
3201   1              wifi_reset = 1; 
3202   1      }
3203          
3204          //AP配置
3205          void Wifi_AP()
3206          {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 53  

3207   1              BYTE i;
3208   1              
3209   1              SendString2("AT+WAP=11BGN,");
3210   1              for(i=164;i<=167;i++)
3211   1              {
3212   2                      SendData2(EEPROM_Buffer[i]);
3213   2              }
3214   1              for(i=0;i<5;i++)
3215   1              {
3216   2                      SendData2(str_i[i]);
3217   2              }
3218   1              SendString2(",CH1");
3219   1              SendData2(0x0d);
3220   1              Delayms(Recv_DelayTime2);
3221   1              Delayms(Recv_DelayTime2);
3222   1              SendString2("AT+WAKEY=WPA2PSK,AES,");
3223   1              for(i=168;i<=175;i++)
3224   1              {
3225   2                      SendData2(EEPROM_Buffer[i]);
3226   2              }
3227   1              SendData2(0x0d);
3228   1              Delayms(Recv_DelayTime2);
3229   1              Delayms(Recv_DelayTime2);
3230   1              ClearBuff2();
3231   1              SendString2("AT+WMODE=AP");
3232   1              SendData2(0x0d);
3233   1              Delayms(Recv_DelayTime2);
3234   1              Delayms(Recv_DelayTime2);
3235   1              //ShowLine(1,273);
3236   1      }
3237          
3238          void Wifi_STA()
3239          {
3240   1              BYTE i;
3241   1              ClearBuff2();
3242   1              /*
3243   1              SendString2("AT+WSSSID=");
3244   1              for(i=0;i<EEPROM_Buffer[208];i++)
3245   1              {
3246   1                      SendData2(EEPROM_Buffer[i+209]);
3247   1              } 
3248   1              SendData2(0x0d);
3249   1              Delayms(Recv_DelayTime2);
3250   1              Delayms(Recv_DelayTime2);
3251   1              SendString2("AT+WSKEY=WPA2PSK,AES,");
3252   1              for(i=0;i<EEPROM_Buffer[224];i++)
3253   1              {
3254   1                      SendData2(EEPROM_Buffer[i+225]);
3255   1              }
3256   1              SendData2(0x0d);
3257   1              Delayms(Recv_DelayTime2);
3258   1              Delayms(Recv_DelayTime2);
3259   1              */
3260   1              SendString2("AT+WMODE=STA");
3261   1              SendData2(0x0d);
3262   1              Delayms(Recv_DelayTime2);
3263   1              Delayms(Recv_DelayTime2);
3264   1              ClearBuff2();
3265   1      }
*** WARNING C280 IN LINE 3240 OF MAIN.C: 'i': unreferenced local variable
3266          
3267          //apsta配置
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 54  

3268          void Wifi_APSTA()
3269          {
3270   1              BYTE i;
3271   1              /*
3272   1              SendString2("AT+WAP=11BGN,");
3273   1              for(i=164;i<=167;i++)
3274   1              {
3275   1                      SendData2(EEPROM_Buffer[i]);
3276   1              }
3277   1              for(i=0;i<5;i++)
3278   1              {
3279   1                      SendData2(str_i[i]);
3280   1              }
3281   1              SendString2(",CH1");
3282   1              SendData2(0x0d);
3283   1              Delayms(Recv_DelayTime2);
3284   1              Delayms(Recv_DelayTime2);
3285   1              SendString2("AT+WAKEY=WPA2PSK,AES,");
3286   1              for(i=168;i<=175;i++)
3287   1              {
3288   1                      SendData2(EEPROM_Buffer[i]);
3289   1              }
3290   1              SendData2(0x0d);
3291   1              Delayms(Recv_DelayTime2);
3292   1              Delayms(Recv_DelayTime2);
3293   1          //STA设置
3294   1              SendString2("AT+WSSSID=");
3295   1              for(i=0;i<EEPROM_Buffer[208];i++)
3296   1              {
3297   1                      SendData2(EEPROM_Buffer[i+209]);
3298   1              } 
3299   1              SendData2(0x0d);
3300   1              Delayms(Recv_DelayTime2);
3301   1              Delayms(Recv_DelayTime2);
3302   1              SendString2("AT+WSKEY=WPA2PSK,AES,");
3303   1              for(i=0;i<EEPROM_Buffer[224];i++)
3304   1              {
3305   1                      SendData2(EEPROM_Buffer[i+225]);
3306   1              }
3307   1              SendData2(0x0d);
3308   1              Delayms(Recv_DelayTime2);
3309   1              Delayms(Recv_DelayTime2);
3310   1              SendString2("AT+SOCKB=TCP,");
3311   1              for(i=0;i<EEPROM_Buffer[251];i++)
3312   1              {
3313   1                      SendData2(EEPROM_Buffer[i+252]);
3314   1              }
3315   1              SendData2(',');
3316   1              for(i=0;i<EEPROM_Buffer[257];i++)
3317   1              {
3318   1                      SendData2(EEPROM_Buffer[i+258]);
3319   1              }
3320   1              SendData2(0x0d);
3321   1              Delayms(Recv_DelayTime2);
3322   1              Delayms(Recv_DelayTime2);
3323   1              SendString2("AT+TCPTOB=0");
3324   1              SendData2(0x0d);
3325   1              Delayms(Recv_DelayTime2);
3326   1              Delayms(Recv_DelayTime2);  */
3327   1              SendString2("AT+WMODE=APSTA");
3328   1              SendData2(0x0d);
3329   1              Delayms(Recv_DelayTime2);
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 55  

3330   1              Delayms(Recv_DelayTime2);
3331   1      }
*** WARNING C280 IN LINE 3270 OF MAIN.C: 'i': unreferenced local variable
3332          
3333          BYTE Wifi_STATUS()
3334          {
3335   1              BYTE mode_status;
3336   1              BYTE wifi_status;
3337   1              BYTE status;
3338   1              //先检查工作模式
3339   1              mode_status = Get_Mode();
3340   1              switch(mode_status){
3341   2                      //STA模式  需要检查连接是否正常
3342   2                      case 2:
3343   2                              //检查wifi连接
3344   2                              wifi_status = Get_WSLK();
3345   2                              switch(wifi_status){
3346   3                                      case 0:
3347   3                                              //wifi连接正常 检查服务器连接(ping)
3348   3                                              ShowLine(0,266);
3349   3                                              Wifi_HTTPD_GET();
3350   3                                              Wifi_ReStart();
3351   3                                      ClearBuff2();
3352   3                                              status =20;
3353   3                                              break;
3354   3                                      case 1:
3355   3                                              //转到ap模式
3356   3                                              //Wifi_AP();
3357   3                                              //Wifi_ReStart();
3358   3                                      //ClearBuff2();
3359   3                                              //ShowLine(0,269);
3360   3                                              ShowLine(0,265);
3361   3                                              status =21;
3362   3                                              break;
3363   3                                      case 2:
3364   3                                              ShowLine(0,269);
3365   3                                              status=22;
3366   3                                              break;
3367   3                                      case 3:
3368   3                                              ShowLine(0,272);
3369   3                                              status=23;
3370   3                                              break;
3371   3                              }
3372   2                              break;
3373   2                      //AP模式  需要转换成STA模式
3374   2                      case 1:
3375   2                              status = 10;
3376   2                              ShowLine(0,265);
3377   2                              break;
3378   2                      //APSTA模式 表示设备正在不断重新连接wifi
3379   2                      case 4:
3380   2                              status =40;
3381   2                              ShowLine(0,267);
3382   2                              break;
3383   2                      //发生错误
3384   2                      case 3:
3385   2                              status =3;
3386   2                              ShowLine(0,273);
3387   2                              break;
3388   2                      default:
3389   2                              break;
3390   2              }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 56  

3391   1              return status;
3392   1      
3393   1      }
3394          
3395          //==================LCD处理================
3396          void Screen_refresh()
3397          {
3398   1              Screen_Num = 0;
3399   1              if(LCD_ID != 0xff)
3400   1              {
3401   2                      if(DATA_ID != 0xff)
3402   2                      {
3403   3                              Screen_Array[Screen_Num] = 4;//DATA_ID;
3404   3                              Screen_Num++;
3405   3                      }
3406   2                      if(ADC_ID != 0xff)
3407   2                      {
3408   3                              Screen_Array[Screen_Num] = 3;//ADC_ID;
3409   3                              Screen_Num++;
3410   3                      }
3411   2                      if(EXTRA_ID != 0xff)
3412   2                      {
3413   3                              Screen_Array[Screen_Num] = 6;//EXTRA_ID;
3414   3                              Screen_Num++;
3415   3                      }
3416   2              }
3417   1              Screen_Count = 0;
3418   1              Screen_Fresh_Count = 0;
3419   1              Screen_Fresh_flag = 0;
3420   1      }
3421          /*********************************
3422          line:行数，从0开始 440 458为显示缓存
3423          start：要显示的字符在EEPROM的开始位置
3424          虚拟行说明：
3425                  行号                       意义
3426                   0（256）                  故障说明
3427                   1（257）                  数据类初始化倒计时说明
3428                   2（258）                  ADC类初始化倒计时说明
3429                   3（259）                  重新启动说明  
3430                   4 (260)                   设置成功说明 
3431                   5 (261)                   不具备匹配的功能                                                                                                                               
3432                   6 (262)                           全行空白
3433                   7 (263)                                   服务器连接成功
3434                   8 (264)                               服务器连接失败
3435                   7 (265)                           等待用户设置wifi名字和密码
3436                   8 (266)                   wifi连接配置成功
3437                   9 (267)                   wifi连接重试中
3438                   10(268)                   以默认参数连接wifi
3439                   11(269)                   wifi连接失败
3440                   12(270)                   服务器主机错误
3441                   13(271)                   服务器侦测超时
3442                   14(272)                   回复错误
3443                   15(273)                   测试接收数据
3444                   16(274)                   握手信息
3445                   17(275)                   回复数据
3446          *********************************/
3447          void ShowLine(BYTE line,WORD start)
3448          {
3449   1              BYTE i;
3450   1              WORD j;
3451   1              Pro_0_0* p;
3452   1              bit sign;
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 57  

3453   1              BYTE replace[8];
3454   1              BYTE replace_count=0;
3455   1              WORD temp;
3456   1              p = &(pro.Pro_Struct);
3457   1              if(line ==0)
3458   1              {
3459   2                      j = 440;
3460   2              }
3461   1              if(line == 1)
3462   1              {
3463   2                      j = 458;
3464   2              }
3465   1              sign = 0;                              //不需要更新      
3466   1              //检查下数据是否需要更新
3467   1          if((start>=256)&&(start<287))                                
3468   1              {
3469   2                  switch(start){
3470   3                              case 257:
3471   3                                      temp = (WORD)EEPROM_Buffer[142];
3472   3                                      WordToStr(temp,0);
3473   3                                      replace[0] = Recv_Buff1[0];
3474   3                                      replace[1] = Recv_Buff1[1];
3475   3                                      replace[2] = 0x20;
3476   3                                      break;
3477   3                              case 258:
3478   3                                      temp = (WORD)EEPROM_Buffer[86];
3479   3                                      WordToStr(temp,0);
3480   3                                      replace[0] = str_i[2];
3481   3                                      replace[1] = str_i[3];
3482   3                                      replace[2] = str_i[4];
3483   3                                      break;
3484   3                              case 273:
3485   3                                      replace[0] = Recv_Buff2[0];//EEPROM_Buffer[160]+0x30;//
3486   3                                      replace[1] = Recv_Buff2[1];//EEPROM_Buffer[161]+0x30;//
3487   3                                      replace[2] = Recv_Buff2[2];//0x20;//
3488   3                                      replace[3] = Recv_Buff2[3];//0x20;//
3489   3                                      replace[4] = Recv_Buff2[4];//EEPROM_Buffer[160]+0x30;//
3490   3                                      replace[5] = Recv_Buff2[5];//EEPROM_Buffer[161]+0x30;//
3491   3                                      replace[6] = Recv_Buff2[6];//0x20;//
3492   3                                      replace[7] = Recv_Buff2[7];//0x20;//
3493   3                                      break;
3494   3                              case 274:
3495   3                                      temp = ((WORD)Remote_Addr[0]<<8)+(WORD)Remote_Addr[1];
3496   3                                      WordToStr(temp,0);
3497   3                                      replace[0] = str_i[0];
3498   3                                      replace[1] = str_i[1];
3499   3                                      replace[2] = str_i[2];
3500   3                                      replace[3] = str_i[3];
3501   3                                      replace[4] = str_i[4];
3502   3                                      break;
3503   3                      }
3504   2                      if(EEPROM_Buffer[1] == 0x14){
3505   3                              for(i=0;i<18;i++)
3506   3                              {
3507   4                                      if(EEPROM_Buffer[j+i] != INFO_14432[start-256][i])
3508   4                                      {
3509   5                                              if(INFO_14432[start-256][i]!=0x00)
3510   5                                                      EEPROM_Buffer[j+i] = INFO_14432[start-256][i];
3511   5                                              else{
3512   6                                                      EEPROM_Buffer[j+i] = replace[replace_count];
3513   6                                                      replace_count++;
3514   6                                              }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 58  

3515   5                                                      
3516   5                                              sign = 1;
3517   5                                      }
3518   4                              }
3519   3                      }else if(EEPROM_Buffer[1] == 0x13)
3520   2                      {
3521   3                              for(i=0;i<16;i++)
3522   3                              {
3523   4                                      if(EEPROM_Buffer[j+i] != INFO_1620[start-256][i])
3524   4                                      {
3525   5                                              if(INFO_1620[start-256][i]!=0x00)
3526   5                                                      EEPROM_Buffer[j+i] = INFO_1620[start-256][i];
3527   5                                              else{
3528   6                                                      EEPROM_Buffer[j+i] = replace[replace_count];
3529   6                                                      replace_count++;
3530   6                                              }
3531   5                                              sign = 1;
3532   5                                      }
3533   4                              }
3534   3                      }
3535   2                                      
3536   2              }
3537   1              else
3538   1              {
3539   2                      for(i=0;i<EEPROM_Buffer[25];i++)
3540   2                      {
3541   3                              if(EEPROM_Buffer[j+i]!=EEPROM_Buffer[start+i])
3542   3                              {
3543   4                                      EEPROM_Buffer[j+i] = EEPROM_Buffer[start+i];
3544   4                                      sign = 1;
3545   4                              }       
3546   3                      }
3547   2              }
3548   1          if(sign)
3549   1              {
3550   2                      LcdWriteCmd(EEPROM_Buffer[line+26]);
3551   2                      for(i=0;i<EEPROM_Buffer[25];i++)
3552   2                      {
3553   3                              LcdWriteDat(EEPROM_Buffer[j+i]);        
3554   3                      }
3555   2                      if(start>256)
3556   2                      {
3557   3                              EEPROM_Buffer[line+30] = start - 256;
3558   3                      }
3559   2                      else
3560   2                      {
3561   3                              EEPROM_Buffer[line+30] = 0;     
3562   3                      }
3563   2              }
3564   1      }
3565          
3566          
3567          //==================协议解析================
3568          //a5 5a 
3569          void ClearPro_Buffer(){
3570   1              BYTE i;
3571   1              for(i=0;i<MaxRecvBuff2;i++){
3572   2                      pro.Pro_Buff[0] = 0x00; 
3573   2              }
3574   1      }
3575          
3576          BYTE Parse(BYTE HAddr,BYTE LAddr,BYTE num)
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 59  

3577          {
3578   1              BYTE i;
3579   1              BYTE temp;
3580   1              Pro_0_0* p;
3581   1              p = &(pro.Pro_Struct);
3582   1              //http1.1协议空回复
3583   1              if(pro.Pro_Buff[0] == 0x30){
3584   2                      return 11;
3585   2              }
3586   1              //http1.1协议有数据回复
3587   1              if((pro.Pro_Buff[0]>0x30)&&(pro.Pro_Buff[0]<=0x39)){
3588   2                      //将数据整理成raw data
3589   2                      temp = num;
3590   2                      for(i=0;i<num;i++){
3591   3                              if(pro.Pro_Buff[i]==0xa5){
3592   4                                      temp = i;
3593   4                              }
3594   3                      }
3595   2                      if(temp == num){
3596   3                              return 12;
3597   3                      }else{
3598   3                              for(i=temp;i<num;i++){
3599   4                                      pro.Pro_Buff[i-temp] = pro.Pro_Buff[i]; 
3600   4                              }
3601   3                      }       
3602   2              }
3603   1              if((p->Mark_Head[0]!=0xa5)||(p->Mark_Head[1]!=0x5a))
3604   1              {   
3605   2                      return 1;                
3606   2              }
3607   1              if((p->Des_Addr[0]!=HAddr)||(p->Des_Addr[1]!=LAddr))
3608   1              {
3609   2                      return 2;
3610   2              }
3611   1              //序列号检查
3612   1              if(p->Seq_Num!=0xff)
3613   1              {
3614   2              }
3615   1              if((p->Payload_Num+9)>num)
3616   1              {
3617   2                      return 3;
3618   2              }
3619   1              return 0;
3620   1      }
3621          
3622          void Command_01()
3623          {
3624   1              BYTE i;
3625   1              Pro_0_0* p;
3626   1              p = &(pro.Pro_Struct);
3627   1              //头处理
3628   1              p->Mark_Head[0] = 0xa5;
3629   1              p->Mark_Head[1] = 0x5a;
3630   1              p->Des_Addr[0] = 0x00;
3631   1              p->Des_Addr[1] = 0x01;
3632   1              p->Src_Addr[0] = Src_Addr[0];
3633   1              p->Src_Addr[1] = Src_Addr[1];
3634   1              p->Command = 0x01;
3635   1              p->Seq_Num = 0;
3636   1              p->Payload_Num = 0;
3637   1              if(Send_Pri2<=3)
3638   1              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 60  

3639   2                      for(i=0;i<p->Payload_Num+9;i++)
3640   2                      {
3641   3                              Send_Buff2[i] = pro.Pro_Buff[i]; 
3642   3                      }
3643   2                      Send_Num2 = p->Payload_Num +9;
3644   2                      Send_Pri2 = 3;
3645   2              }
3646   1                                      
3647   1      }
3648          
3649          //一次写入50字节
3650          BYTE Command_07()
3651          {
3652   1              WORD i;
3653   1              BYTE j;
3654   1              Pro_0_0* p;
3655   1              p = &(pro.Pro_Struct);
3656   1              if(p->Payload_Num==50)
3657   1              {
3658   2                      i = (((WORD)(p->Payload[0]))<<8)+(WORD)(p->Payload[1]);
3659   2                      if(i<=462)
3660   2                      {
3661   3                              for(j=0;j<30;j++)
3662   3                              {
3663   4                                      EEPROM_Buffer[i+j] = p->Payload[j+2];
3664   4                              }
3665   3                              return 0;
3666   3                      }else
3667   2                      {
3668   3                              return 4;
3669   3                      }               
3670   2              }else
3671   1              {
3672   2                      return 5;
3673   2              }
3674   1      }
3675          //配置相关参数
3676          BYTE Command_09()
3677          {
3678   1              WORD i;
3679   1              Pro_0_0* p;
3680   1              p = &(pro.Pro_Struct);
3681   1              if(p->Payload_Num==50)
3682   1              {
3683   2                      switch(p->Payload[0])
3684   2                      {
3685   3                              case 0x01:      
3686   3                              case 0x02:
3687   3                              case 0x08:
3688   3                              case 0x09:
3689   3                                      EEPROM_Buffer[3] = p->Payload[0];
3690   3                                      for(i=0;i<34;i++)
3691   3                                      {
3692   4                                              if(p->Payload[i+1]!=0xff)
3693   4                                              {
3694   5                                                      EEPROM_Buffer[i+48] = p->Payload[i+1];
3695   5                                              }
3696   4                                      }       
3697   3                                      EEPROM_Buffer[87] = p->Payload[49];
3698   3                                      break;
3699   3                              case 0x03:
3700   3                              case 0x05:
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 61  

3701   3                              case 0x06:
3702   3                                      EEPROM_Buffer[4] = p->Payload[0];
3703   3                                      for(i=0;i<34;i++)
3704   3                                      {
3705   4                                              if(p->Payload[i+1]!=0xff)
3706   4                                              {
3707   5                                                      EEPROM_Buffer[i+104] = p->Payload[i+1];
3708   5                                              }
3709   4                                      }
3710   3                                      EEPROM_Buffer[143] = p->Payload[49];
3711   3                                      break;
3712   3                              case 0x04:
3713   3                              case 0x07:
3714   3                                      EEPROM_Buffer[6] = p->Payload[0];
3715   3                                      //补充类
3716   3                                      for(i=0;i<14;i++)
3717   3                                  {
3718   4                                              if(p->Payload[i+3]!=0xff)
3719   4                                              {
3720   5                                                      EEPROM_Buffer[i+408] = p->Payload[i+3];
3721   5                                              }
3722   4                                      }
3723   3                                      for(i=0;i<18;i++)
3724   3                                      {
3725   4                                              if(p->Payload[i+17]!=0xff)
3726   4                                              {
3727   5                                                      EEPROM_Buffer[i+318] = p->Payload[i+17];
3728   5                                              }
3729   4                                      }
3730   3                                      break;
3731   3                          default:
3732   3                                      break;
3733   3                      }
3734   2                      switch(p->Payload[0])
3735   2                      {
3736   3                              case 0x01:
3737   3                                      EEPROM_Buffer[82] = 0x01;            //1秒采集间隔
3738   3                                      EEPROM_Buffer[83] = 0x32;            //启动时间
3739   3                                      EEPROM_Buffer[91] = 0x00;
3740   3                                      EEPROM_Buffer[92] = 0x64;
3741   3                                      EEPROM_Buffer[93] = 0x00;
3742   3                                      EEPROM_Buffer[94] = 0x00;
3743   3                                      break;
3744   3                              case 0x02:
3745   3                                      EEPROM_Buffer[82] = 0x01;            //1秒采集间隔
3746   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
3747   3                                      EEPROM_Buffer[91] = 0x03;
3748   3                                      EEPROM_Buffer[92] = 0xe8;
3749   3                                      EEPROM_Buffer[93] = 0x00;
3750   3                                      EEPROM_Buffer[94] = 0x00;
3751   3                                      EEPROM_Buffer[96] = 0x10;                   //超过4.3认为100%
3752   3                                      EEPROM_Buffer[97] = 0xe3;
3753   3                                      EEPROM_Buffer[98] = 0x04;                   //低于1.1认为0 低于1认为故障
3754   3                                      EEPROM_Buffer[99] = 0x4c;
3755   3                                      break;
3756   3                              case 0x03:                      
3757   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
3758   3                                      break;
3759   3                              case 0x04:
3760   3                                      break;
3761   3                              case 0x05:
3762   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 62  

3763   3                                      break;
3764   3                              case 0x06:
3765   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
3766   3                                      break;
3767   3                              case 0x07:
3768   3                                      break;
3769   3                              case 0x08:
3770   3                                      EEPROM_Buffer[82] = p->Payload[35];         //采集间隔
3771   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
3772   3                                      EEPROM_Buffer[100] = p->Payload[36];         //电平意义
3773   3                                      EEPROM_Buffer[101] = p->Payload[37];         //判决次数
3774   3                                      EEPROM_Buffer[102] = p->Payload[38];         //判决门限
3775   3                                      EEPROM_Buffer[103] = p->Payload[39];         //判决次数门限 多少次算成功判决
3776   3                                      EEPROM_Buffer[91] = 0x00;
3777   3                                      EEPROM_Buffer[92] = 0x00;
3778   3                                      EEPROM_Buffer[93] = 0x00;
3779   3                                      EEPROM_Buffer[94] = 0x00;
3780   3                                      break;
3781   3                              case 0x09:
3782   3                                      EEPROM_Buffer[82] = p->Payload[35];         //采集间隔
3783   3                                      EEPROM_Buffer[83] = 0x05;            //启动时间
3784   3                                      EEPROM_Buffer[91] = 0x13;
3785   3                                      EEPROM_Buffer[92] = 0xe2;
3786   3                                      EEPROM_Buffer[93] = 0x00;
3787   3                                      EEPROM_Buffer[94] = 0x00;
3788   3                                      break;
3789   3                              default:
3790   3                                      break;
3791   3                      }
3792   2                      return 0;
3793   2              }
3794   1              else
3795   1              {
3796   2                      return 5;
3797   2              }
3798   1      }
3799          //获取相关参数
3800          BYTE Command_0F()
3801          {
3802   1              WORD i;
3803   1              Pro_0_0* p;
3804   1              p = &(pro.Pro_Struct);
3805   1              if(p->Payload_Num==1)
3806   1              {
3807   2                      if(p->Payload[0] == EEPROM_Buffer[3])
3808   2                      {
3809   3                              p->Payload[1] = EEPROM_Buffer[3];
3810   3                              for(i=0;i<16;i++)
3811   3                              {
3812   4                                      p->Payload[i+2] = EEPROM_Buffer[i+48];
3813   4                              }
3814   3                              //若是08类，填写测试级别
3815   3                              p->Payload[18] = EEPROM_Buffer[82];
3816   3                              p->Payload[19] = EEPROM_Buffer[100];
3817   3                              p->Payload[20] = EEPROM_Buffer[101];
3818   3                              p->Payload[21] = EEPROM_Buffer[102];
3819   3                              p->Payload[22] = EEPROM_Buffer[103];
3820   3                              return 0;
3821   3                      }else if(p->Payload[0] == EEPROM_Buffer[4])     
3822   2                      {
3823   3                              p->Payload[1] = EEPROM_Buffer[4];
3824   3                              for(i=0;i<16;i++)
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 63  

3825   3                              {
3826   4                                      p->Payload[i+2] = EEPROM_Buffer[i+104];
3827   4                              }
3828   3                              return 0;
3829   3                      }else if(p->Payload[0] == EEPROM_Buffer[6])               
3830   2                      {
3831   3                              p->Payload[1] = EEPROM_Buffer[4];
3832   3                              p->Payload[2] = EEPROM_Buffer[104];
3833   3                              p->Payload[3] = EEPROM_Buffer[105];
3834   3                              for(i=0;i<14;i++)
3835   3                              {
3836   4                                      p->Payload[i+4] = EEPROM_Buffer[i+408];
3837   4                              }
3838   3                              return 0;
3839   3                      }else
3840   2                      {
3841   3                              return 6;
3842   3                      }
3843   2              }
3844   1              else
3845   1              {
3846   2                      return 5;
3847   2              }
3848   1      }
3849          
3850          BYTE Command_11()
3851          {
3852   1              Pro_0_0* p;
3853   1              p = &(pro.Pro_Struct);
3854   1              if(p->Payload_Num==0)
3855   1              {
3856   2                      EEPROM_Buffer[34] = 0;                                       //初始状态各行都不刷新
3857   2                      EEPROM_Buffer[35] = 0;
3858   2                      EEPROM_Buffer[36] = 0;
3859   2                      EEPROM_Buffer[37] = 0;
3860   2                      ADC_P_Init();
3861   2                      DATA_P_Init();
3862   2                      EXTRA_P_Init();
3863   2                      IapEraseSector(0);                            //先擦后写
3864   2                      WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
3865   2                      return 0;               
3866   2              }else
3867   1              {
3868   2                      return 5;
3869   2              }
3870   1      }
3871          //采集和按次定时上传处理+报警检测开闭+故障、报警上传+临时解除警报+门限处理+........
3872          BYTE Command_13()
3873          {
3874   1              Pro_0_0* p;
3875   1              WORD i;
3876   1              p = &(pro.Pro_Struct);
3877   1              if(p->Payload_Num==30)
3878   1              {
3879   2                      if(p->Payload[0] == EEPROM_Buffer[3])
3880   2                      {
3881   3                              for(i=0;i<8;i++)
3882   3                              {
3883   4                                      if(p->Payload[i+1]!=0xff)
3884   4                                              EEPROM_Buffer[i+48] = p->Payload[i+1];
3885   4                              }
3886   3                              if(p->Payload[9] == 0x01)              //配置门限值
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 64  

3887   3                              {
3888   4                                      for(i=0;i<8;i++)
3889   4                                      {
3890   5                                              EEPROM_Buffer[i+56] = p->Payload[i+10]; 
3891   5                                      }
3892   4                              }
3893   3                              //记录上传设置
3894   3                              if(p->Payload[18]!=0xff)
3895   3                                      EEPROM_Buffer[95] = p->Payload[18];
3896   3                              //记录上传地址
3897   3                              if(p->Payload[19]!=0xff)
3898   3                                      EEPROM_Buffer[301] = p->Payload[19];
3899   3                              if(p->Payload[20]!=0xff)
3900   3                                      EEPROM_Buffer[302] = p->Payload[20];
3901   3                              //08类传感器参数
3902   3                              if(p->Payload[21]!=0xff)
3903   3                                      EEPROM_Buffer[82] = p->Payload[21];
3904   3                              if(p->Payload[22]!=0xff)
3905   3                                      EEPROM_Buffer[100] = p->Payload[22];
3906   3                              if(p->Payload[23]!=0xff)
3907   3                                      EEPROM_Buffer[101] = p->Payload[23];
3908   3                              if(p->Payload[24]!=0xff)
3909   3                                      EEPROM_Buffer[102] = p->Payload[24];
3910   3                              if(p->Payload[25]!=0xff)
3911   3                                      EEPROM_Buffer[103] = p->Payload[25];
3912   3                              return 0;       
3913   3                      }else if(p->Payload[0] == EEPROM_Buffer[4])
3914   2                      {
3915   3                              for(i=0;i<8;i++)
3916   3                              {
3917   4                                      if(p->Payload[i+1]!=0xff)
3918   4                                              EEPROM_Buffer[i+104] = p->Payload[i+1];
3919   4                              }
3920   3                              if(p->Payload[9] == 0x01)              //配置门限值
3921   3                              {
3922   4                                      for(i=0;i<8;i++)
3923   4                                      {
3924   5                                              EEPROM_Buffer[i+112] = p->Payload[i+10];
3925   5                                      }       
3926   4                              }
3927   3                              //记录上传设置
3928   3                              if(p->Payload[18]!=0xff)
3929   3                                      EEPROM_Buffer[151] = p->Payload[18];
3930   3                              //记录上传地址
3931   3                              if(p->Payload[19]!=0xff)
3932   3                                      EEPROM_Buffer[301] = p->Payload[19];
3933   3                              if(p->Payload[20]!=0xff)
3934   3                                      EEPROM_Buffer[302] = p->Payload[20];
3935   3                              return 0;       
3936   3                      } else if(p->Payload[0] == EEPROM_Buffer[6])
3937   2                      {
3938   3                              if(p->Payload[1] !=0xff)
3939   3                                      EEPROM_Buffer[104] = p->Payload[1];
3940   3                              if(p->Payload[2] !=0xff)
3941   3                                      EEPROM_Buffer[105] = p->Payload[2];
3942   3                              for(i=0;i<6;i++)
3943   3                              {
3944   4                                      if(p->Payload[i+3]!=0xff)
3945   4                                              EEPROM_Buffer[i+408] = p->Payload[i+3];
3946   4                              }
3947   3                              if(p->Payload[9] == 0x01)              //配置门限值
3948   3                              {
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 65  

3949   4                                      for(i=0;i<8;i++)
3950   4                                      {
3951   5                                              EEPROM_Buffer[i+414] = p->Payload[i+10];
3952   5                                      }       
3953   4                              }
3954   3                              //记录上传设置
3955   3                              if(p->Payload[18]!=0xff)
3956   3                                      EEPROM_Buffer[151] = p->Payload[18];
3957   3                              //记录上传地址
3958   3                              if(p->Payload[19]!=0xff)
3959   3                                      EEPROM_Buffer[301] = p->Payload[19];
3960   3                              if(p->Payload[20]!=0xff)
3961   3                                      EEPROM_Buffer[302] = p->Payload[20];
3962   3                              return 0;       
3963   3                      }
3964   2                      else
3965   2                      {
3966   3                              return 6;
3967   3                      }
3968   2              }
3969   1              else
3970   1              {
3971   2                      return 5;
3972   2              }
3973   1      }
3974          //
3975          BYTE Command_15()
3976          {
3977   1              Pro_0_0* p;
3978   1              p = &(pro.Pro_Struct);
3979   1              if(p->Payload_Num==3)
3980   1              {
3981   2                      if(p->Payload[0] == 0x00)
3982   2                              EEPROM_Buffer[3] = 0xff;
3983   2                      if(p->Payload[1] == 0x00)
3984   2                      EEPROM_Buffer[4] = 0xff;
3985   2                      if(p->Payload[2] == 0x00)
3986   2                              EEPROM_Buffer[6] = 0xff;
3987   2                      return 0;
3988   2              }
3989   1              else
3990   1              {
3991   2                      return 5;
3992   2              }
3993   1      } 
3994          //LOGO和显示字符修改
3995          BYTE Command_17()
3996          {
3997   1              WORD i;
3998   1              BYTE j,k;
3999   1              Pro_0_0* p;
4000   1              p = &(pro.Pro_Struct);
4001   1              if(p->Payload_Num==20)
4002   1              {
4003   2                      i = ((WORD)(p->Payload[0])<<8)+(WORD)(p->Payload[1]);
4004   2                      switch(i)
4005   2                      {
4006   3                              case 64:                
4007   3                              case 120:                               
4008   3                              case 318:                               
4009   3                              case 336:                               
4010   3                              case 354:                               
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 66  

4011   3                              case 372:                       
4012   3                              case 390:
4013   3                                      k=0;
4014   3                                      break;
4015   3                              default:
4016   3                                      k=1;
4017   3                                      break;
4018   3                      }
4019   2                      if(k==0)
4020   2                      {
4021   3                              for(j=0;j<18;j++)
4022   3                              {
4023   4                                      EEPROM_Buffer[i+j] = p->Payload[j+2];
4024   4                              }
4025   3                              return 0;       
4026   3                      }
4027   2                      else
4028   2                      {
4029   3                              return 4;
4030   3                      }
4031   2              }
4032   1              else
4033   1              {
4034   2                      return 5;
4035   2              }       
4036   1      }
4037          //心跳设置
4038          BYTE Command_19()
4039          {
4040   1              BYTE i;
4041   1              Pro_0_0* p;
4042   1              p = &(pro.Pro_Struct);
4043   1              if(p->Payload_Num==5)
4044   1              {
4045   2                      for(i=0;i<5;i++)
4046   2                      {
4047   3                              EEPROM_Buffer[i+296] = p->Payload[i];
4048   3                      }
4049   2                      if((EEPROM_Buffer[296]&0x02)==0x02)
4050   2                      {
4051   3                              Heart_Time = ((WORD)(EEPROM_Buffer[297])<<8)+(WORD)EEPROM_Buffer[298];
4052   3                              Heart_Count = 0;
4053   3                      }
4054   2                      return 0;
4055   2              }
4056   1              else
4057   1              {
4058   2                      return 5;
4059   2              }
4060   1      }
4061          //设置家庭路由器
4062          BYTE Command_1b()
4063          {
4064   1              BYTE i;
4065   1              Pro_0_0* p;
4066   1              p = &(pro.Pro_Struct);
4067   1              if(p->Payload_Num==42)
4068   1              {
4069   2                      for(i=0;i<42;i++)
4070   2                      {
4071   3                              EEPROM_Buffer[i+208] = p->Payload[i];
4072   3                      }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 67  

4073   2                      return 0;
4074   2              }
4075   1              else
4076   1              {
4077   2                      return 5;
4078   2              }
4079   1      }
4080          //设置远程服务器
4081          BYTE Command_1d()
4082          {
4083   1              BYTE i;
4084   1              Pro_0_0* p;
4085   1              p = &(pro.Pro_Struct);
4086   1              if(p->Payload_Num==28)
4087   1              {
4088   2                      for(i=0;i<28;i++)
4089   2                      {
4090   3                              EEPROM_Buffer[i+250] = p->Payload[i];
4091   3                      }
4092   2                      return 0;
4093   2              }
4094   1              else
4095   1              {
4096   2                      return 5;
4097   2              }
4098   1      }
4099          //获取工作状态
4100          BYTE Command_1f()
4101          {
4102   1              Pro_0_0* p;
4103   1              p = &(pro.Pro_Struct);
4104   1              if(p->Payload_Num==0)
4105   1              {
4106   2                      p->Payload[1] = EEPROM_Buffer[53];
4107   2                      p->Payload[2] = EEPROM_Buffer[84];
4108   2                      p->Payload[3] = EEPROM_Buffer[86];
4109   2                      p->Payload[4] = ADC_Count;
4110   2                      p->Payload[5] = EEPROM_Buffer[88];
4111   2                      p->Payload[6] = EEPROM_Buffer[89];
4112   2                      p->Payload[7] = EEPROM_Buffer[90];
4113   2                      p->Payload[8] = EEPROM_Buffer[95];
4114   2      
4115   2                      p->Payload[9] = EEPROM_Buffer[109];
4116   2                      p->Payload[10] = EEPROM_Buffer[140];
4117   2                      p->Payload[11] = EEPROM_Buffer[142];
4118   2                      p->Payload[12] = DATA_Count;
4119   2                      p->Payload[13] = EEPROM_Buffer[144];
4120   2                      p->Payload[14] = EEPROM_Buffer[145];
4121   2                      p->Payload[15] = EEPROM_Buffer[146];
4122   2                      p->Payload[16] = EEPROM_Buffer[151];
4123   2                 
4124   2                  p->Payload[17] = EEPROM_Buffer[411]; 
4125   2                      
4126   2                      p->Payload[18] = (BYTE)(Heart_Count>>8);
4127   2                      p->Payload[19] = (BYTE)(Heart_Count); 
4128   2                      return 0;
4129   2              }       
4130   1              else
4131   1              {
4132   2                      return 5;
4133   2              }
4134   1      }
C51 COMPILER V9.00   MAIN                                                                  08/06/2018 16:22:30 PAGE 68  

4135          
4136          //心跳处理，最高优先级
4137          void Heart_Process() 
4138          {
4139   1              BYTE num,i;
4140   1              Pro_0_0* p;
4141   1              p = &(pro.Pro_Struct);
4142   1              //头处理
4143   1               p->Mark_Head[0] = 0xa5;
4144   1               p->Mark_Head[1] = 0x5a;
4145   1               //心跳地址
4146   1               p->Des_Addr[0] = EEPROM_Buffer[299];
4147   1               p->Des_Addr[1] = EEPROM_Buffer[300];
4148   1               //本地地址写入
4149   1               p->Src_Addr[0] = Src_Addr[0];
4150   1               p->Src_Addr[1] = Src_Addr[1];
4151   1               p->Seq_Num = Seq_Number;
4152   1               Seq_Number++;
4153   1               p->Command = 0x30;                                         //上传数据
4154   1               //上传32字节的板子和用户信息
4155   1               for(i=0;i<8;i++)
4156   1               {
4157   2                      p->Payload[i] = EEPROM_Buffer[i];
4158   2               }
4159   1               for(i=0;i<24;i++)
4160   1               {
4161   2                      p->Payload[i+8] = 0xff;
4162   2               }
4163   1               num = 32;
4164   1               p->Payload_Num = num;                                             //载荷长度
4165   1               if(Send_Pri2<=4)
4166   1               {
4167   2                      for(i=0;i<num+9;i++)
4168   2                      {
4169   3                              Send_Buff2[i] = pro.Pro_Buff[i]; 
4170   3                      }
4171   2                      Send_Num2 = num +9;
4172   2                      Send_Pri2 = 4;
4173   2               }
4174   1               EEPROM_Buffer[301]++;
4175   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16160    ----
   CONSTANT SIZE    =   1060    ----
   XDATA SIZE       =    791     112
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
