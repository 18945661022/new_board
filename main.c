/*========================================
1、本板编号0x10 版本号1.0
2、本机组成说明:
       MCU                              stc125a60s2
       时钟                             11.0592MHZ
       EEPROM                           512*2 byte
       timer                            timer0 16位
       串口                             串口2(BAUD 9600)
      
       wifi                             usr-wifi-232-t(AP/APSTA)
       ADC                              p1.1
       数据类                           p1.0
       LCD                              1602/14432
 3、本机主要功能:
      1)模拟传感器或数据类数据采集。
      2)对采集的数据进行的必要处理(报警等)。
      3)WIFI AP模式下与手机端进行数据交换。
      4)WIFI STA模式下与服务器进行数据交换。
========================================*/

#include "COM_Fun.h"
#include "LCD_Fun.h"
#include "eeprom_fun.h"
#include "18b20_Fun.h"
#include "Delay_Fun.h"
#include "ADC_Fun.h"
#include "Stc_Math.h"
#include "AM2305.h"
#include "WDT_Fun.h"

typedef unsigned char BYTE;
typedef unsigned int WORD;

/*============EEPROM设计==================
总体设计：
-----------------------------------------------
|  0-7  |                 本机信息            |
-----------------------------------------------
|  8-15 |               定时器类设置          |
-----------------------------------------------
|  16-23|               串口类设置            |
-----------------------------------------------
|  24-47|               LCD类设置             |
-----------------------------------------------
| 48-103|               ADC类设置             |
-----------------------------------------------
|104-159|               数据类设置            |
-----------------------------------------------
|160-295|               WIFI类设置            |
-----------------------------------------------
|296-335|               用户逻辑类            |
-----------------------------------------------
|336-375|               显示字符类设置        |
-----------------------------------------------
| 剩余  |               扩展区                |
-----------------------------------------------

本机信息说明：
----------------------------------------------------------------------------------
|   0     |   1      |   2     |   3     |   4       |   5      |   6   |   7    |
----------------------------------------------------------------------------------
| TYPE    | LCD      |  WIFI    |  ADC    | DATA     |初始化时间|补充类 |通信协议|
----------------------------------------------------------------------------------
TYPE: 板型，填0x10
LCD: 显示器类  1602:0x13  14432:0x14  12864:0x15  16032：0x16  无：0x00或0xff
wifi: WIFI 工作类  0x11
ADC:ADC工作类 
DATA：DATA工作类 
初始化时间：初始化所需时间
补充类：ADC或DATA数据的补充，若设置的话必须等于这两个类的ID值
协议: FF:http1.1（chunked包）;  00：http1.0	 智能解析


定时器类设置
-----------------------------------------------------------------------
|   8   |   9   |   10   |   11   |   12   |   13   |   14   |   15   |
-----------------------------------------------------------------------
|  步长 |位数   |电源ADC修正值    |                传感器补充         |
-----------------------------------------------------------------------
步长：定时时间 = 125ms*定时步长   默认值是8
位数：16位

串口类设置
-----------------------------------------------------------------------
|   16  |  17   |   18   |   19   |   20   |   21   |   22   |   23   |
-----------------------------------------------------------------------
|波特率 |数据位 |校验方式|停止位  |CTSRTS  |                          |
-----------------------------------------------------------------------
波特率： 0:9600  1:115200 3....
数据位： 8
校验方式：0：无校验 1：奇校验 2：偶校验 3、MARK校验
CTSRTS：0：无握手 1：有握手

LCD类设置
-----------------------------------------------------------------------
|   24  |  25   |   26   |   27   |   28   |   29   |   30   |   31   |
-----------------------------------------------------------------------
|行数   |行字符数|行地址0|行地址1 |行地址2 |行地址3 |行0位置 |行1位置 |
-----------------------------------------------------------------------

-----------------------------------------------------------------------
|   32  |  33   |   34   |   35   |   36   |   37   |   38   |   39   |
-----------------------------------------------------------------------
|行2位置|行3位置|行0刷新 |行1刷新 |行2刷新 |行3刷新 |                                                    |
-----------------------------------------------------------------------

-----------------------------------------------------------------------
|   40  |  41   |   42   |   43   |   44   |   45   |   46   |   47   |
-----------------------------------------------------------------------
|                        保留                                         |
-----------------------------------------------------------------------

行数：行数量
行字符数：每行可显示的字符数量  
行地址：每行的显示屏显示初始地址
行位置：每行显示EEPROM位置

ADC类设置1（P1.1脚）
-------------------------------------------------------------------------------
|   48   |  49    |   50    |   51    |   52    |   53    |   54    |   55    |
-------------------------------------------------------------------------------
|采集方式|采集时长|上传方式 |上传时长 |报警检测 |报警标识 |报警模式 |报警方式 |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|   56   |  57    |   58    |   59    |   60    |   61    |   62    |   63    |
-------------------------------------------------------------------------------
|         低门限值                    |           高门限值                    |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------              
|   64   |  65    |   66    |   67    |   68    |   69    |   70    |   71    |
------------------------------------------------------------------------------- 
|                     占行模式                                                |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|   72   |  73    |   74    |   75    |   76    |   77    |   78    |   79    |
------------------------------------------------------------------------------- 
|                               占行模式                                      |
-------------------------------------------------------------------------------
                            
-------------------------------------------------------------------------------
|   80   |  81    |   82    |   83    |   84    |   85    |   86    |   87    |
------------------------------------------------------------------------------- 
|14432占行模式    |08类判决间隔|启动时间|故障警告 |引脚参数 |启动时间缓存值|采集时间缓存值|
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|   88         |  89    |   90    |   91    |   92    |   93    |   94    |   95    |
------------------------------------------------------------------------------- 
|上传时间缓存值|采集状态|上传状态 |        断路特征值                     |上传计数值                                                                         |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|   96   |  97    |   98    |   99    |  100       |  101       |  102    |  103    |
------------------------------------------------------------------------------- 
|百分比顶值修订   |百分比低值修订     |08类电平意义|08类判决次数|08类电平判决值|08类次数门限                                                       |
-------------------------------------------------------------------------------

数据类设置（P1.0脚）
-------------------------------------------------------------------------------
|  104   | 105    |  106    |  107    |  108    |  109    |  110    |  111    |
-------------------------------------------------------------------------------
|采集方式|采集时长|上传方式 |上传时长 |报警检测 |报警标识 |报警模式 |报警方式 |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  112   | 113    |  114    |  115    |  116    |  117    |  118    |  119    |
-------------------------------------------------------------------------------
|         低门限值                    |           高门限值                    |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------              
|  120   | 121    |  122    |  123    |  124    |  125    |  126    |  127    |
------------------------------------------------------------------------------- 
|                     占行模式                                                |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  128   | 129    |  130    |  131    |  132    |  133    |  134    |  135    |
------------------------------------------------------------------------------- 
|                               占行模式                                      |
-------------------------------------------------------------------------------
                            
-------------------------------------------------------------------------------
|  136   | 137    |  138    |  139    |  140    |  141    |  142    |  143    |
------------------------------------------------------------------------------- 
|14432占行模式    |显示生命期|启动时间|故障警告 |引脚参数 |启动时间缓存值|采集时间缓存值                            |
-------------------------------------------------------------------------------
																   
-------------------------------------------------------------------------------
|   144        |  145   |  146    |  147    |  148    |  149    |  150    |  151|
------------------------------------------------------------------------------- 
|上传时间缓存值|采集状态|上传状态 |   断路特征值                          |上传计数值                                                                          |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  152   | 153    |  154    |  155    |  156    |  157    |  158    |  159    |
------------------------------------------------------------------------------- 
|                                                                              |
-------------------------------------------------------------------------------

采集方式：0xff 无意义 0x00 不采集 0xfb 循环采集   其他值（<=250） 采集次数
采集时长：定时采集时长 默认1s
上传方式：
-------------------------------------------------------------------------
|  7     |  6     |  5     |  4     |  3     |  2     |  1     |  0     | 
-------------------------------------------------------------------------
| x      |  x     | x      | x      |故障上传|告警上传|定时上传|单次上传|
-------------------------------------------------------------------------
上传时长：定时上传时长 默认1s 可设置
报警检测：0 不检测报警 1 检测报警
报警标识：报警识别位，1有效，可手动清零。
报警模式：01高门限报警，02低门限报警，03双门限报警
报警方式：01持续报警，00单次报警
低门限值：前面2字节整数部分，后面两字节小数部分
高门限值：前面2字节整数部分，后面两字节小数部分
占行模式：把要显示的字符放在相应的位置，其中0x30表示符号位，0x31-0x35表示整数部分相应的字节数，0x36-0x39表示小数部分相应字节数
显示生命期：数据显示的时间长度，默认为10.
启动时间：设备启动到稳定工作的时间
故障警告：设备故障说明。
引脚参数：1.1脚就是0x02
-------------------------------------------------------------------------
|  7     |  6     |  5     |  4     |  3     |  2     |  1     |  0     | 
-------------------------------------------------------------------------
||															   |设备断路|
-------------------------------------------------------------------------

WIFI类设置
-------------------------------------------------------------------------------
|  160   | 161    |  162    |  163    |  164    |  165    |  166    |  167    |
------------------------------------------------------------------------------- 
|初始标识|MODE    |    设备地址       |            AP SSID前缀                |        
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  168   | 169    |  170    |  171    |  172    |  173    |  174    |  175    |
------------------------------------------------------------------------------- 
|                      AP密码                                                 |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  176   | 177    |  178    |  179    |  180    |  181    |  182    |  183    |
------------------------------------------------------------------------------- 
|   CH   |NET_MODE|ENC_MODE |WPA_ENC  |A_PRO    |A_PORT_N | A_PORT1 | A_PORT2 |                                                          |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  184   | 185    |  186    |  187    |  188    |  189    |  190    |  191    |
------------------------------------------------------------------------------- 
|A_PORT3 |A_PORT4 |A_PORT5  |A_IP_N   |A_IP1    |A_IP2    |A_IP3    |A_IP4    |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  192   | 193    |  194    |  195    |  196    |  197    |  198    |  199    |
------------------------------------------------------------------------------- 
|A_IP5   |A_IP6   |A_IP7    |A_IP8    |A_IP9    |A_IP10   |A_IP11   |A_IP12   |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  200   | 201    |  202    |  203    |  204    |  205    |  206    |  207    |
------------------------------------------------------------------------------- 
|A_IP13  |A_IP14  |A_IP15   |A_TIMEOUT_N|A_TIMEOUT1|A_TIMEOUT2|A_TIMEOUT3|                                       |
-------------------------------------------------------------------------------

----------------------------------------------------------------------------------
|  208     | 209     |  210    |  211    |  212    |  213    |  214    |  215    |
----------------------------------------------------------------------------------
|STA_SSID_N|STA_SSID1|STA_SSID2|STA_SSID3|STA_SSID4|STA_SSID5|STA_SSID6|STA_SSID7|
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------------
|  216     | 217      |  218     |  219     |  220     |  221     |  222     |  223     |
----------------------------------------------------------------------------------------
|STA_SSID8 |STA_SSID9 |STA_SSID10|STA_SSID11|STA_SSID12|STA_SSID13|STA_SSID14|STA_SSID15|
----------------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  224   | 225    |  226    |  227    |  228    |  229    |  230    |  231    |
------------------------------------------------------------------------------- 
|STA_P_N |STA_P1  |STA_P2   |STA_P3   |STA_P4   |STA_P5   |STA_P6   |STA_P7   |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  232   | 233    |  234    |  235    |  236    |  237    |  238    |  239    |
------------------------------------------------------------------------------- 
|STA_P8  |STA_P9  |STA_P10  |STA_P11  |STA_P12  |STA_P13  |STA_P14  |STA_P15  |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  240   | 241    |  242    |  243    |  244    |  245    |  246    |  247    |
------------------------------------------------------------------------------- 
|STA_P16 |STA_P17 |STA_P18  |STA_P19  |STA_P20  |STA_P21  |STA_P22  |STA_P23  |
-------------------------------------------------------------------------------

--------------------------------------------------------------------------------------
|  248       | 249       |  250    |  251    |  252    |  253    |  254    |  255    |
-------------------------------------------------------------------------------------- 
|STA_ENC_MODE|STA_WPA_ENC|B_PRO    |B_PORT_N | B_PORT1 | B_PORT2 |B_PORT3  |B_PORT4  |
--------------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  256   | 257    |  258    |  259    |  260    |  261    |  262    |  263    |
------------------------------------------------------------------------------- 
|B_PORT5 |B_IP_N  |B_IP1    |B_IP2    |B_IP3    |B_IP4    |B_IP5    |B_IP6    |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  264   | 265    |  266    |  267    |  268    |  269    |  270    |  271    |
------------------------------------------------------------------------------- 
|B_IP7   |B_IP8   |B_IP9    |B_IP10   |B_IP11   |B_IP12   |B_IP13   |B_IP14   |
-------------------------------------------------------------------------------

--------------------------------------------------------------------------------------
|  272   | 273       |  274     |  275     |  276     |  277     |  278    |  279    |
-------------------------------------------------------------------------------------- 
|B_IP15  |B_TIMEOUT_N|B_TIMEOUT1|B_TIMEOUT2|B_TIMEOUT3|B_TIMEOUT4|         |服务器ip |
--------------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  280   | 281    |  282    |  283    |  284    |  285    |  286    |  287    |
------------------------------------------------------------------------------- 
|                      服务器ip                                               |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  288   | 289    |  290    |  291    |  292    |  293    |  294    | 295     |
------------------------------------------------------------------------------- 
| 服务器ip                  |			  服务器端口                          |
-------------------------------------------------------------------------------

初始标识：0表示未进行初始化   1表示已经初始化
MODE：1 AP模式  2 STA模式 4 APSTA模式  8 AP一定时间再转STA模式
设备地址：设备通信地址  1-65534    0xff为广播地址
AP参数
AP SSID前缀：通信前缀 4字节 默认USR_
AP密码 ：8字节 
CH：AP信道 0 自动 手动 1-11.
NET_MODE：0 11bgn
ENC_MODE：0 WPA2PSK 1 none
WPA_ENC：0 AES 

SOCKET A参数：
A_PRO：0 TCP 1 UDP
A_PORT_N：端口字符数
A_PORT？：端口字符，无意义部分用0Xff表示
A_IP_N：IP字符数
A_IP?:IP字符，无意义部分用0xff表示
A_TIMEOUT_N:超时时间字符数
A_TIMEOUT？：超时时间字符，无意义部分用0xff表示

STA参数
STA_SSID_N：STA模式外部路由器SSID的字符数
STA_SSID？：STA模式外部路由器SSID，无意义部分用0xff表示
STA_P_N：STA模式外部路由器密码字符数
STA_P？：TA模式外部路由器密码，无意义部分用0xff表示
STA_ENC_MODE：0 WPA2PSK  ......
STA_WPA_ENC：

SOCKETB参数
B_PRO：0 TCP 1 UDP
B_PORT_N：端口字符数
B_PORT？：端口字符，无意义部分用0Xff表示
B_IP_N：IP字符数
B_IP?:IP字符，无意义部分用0xff表示
B_TIMEOUT_N:超时时间字符数
B_TIMEOUT？：超时时间字符，无意义部分用0xff表示

服务器IP：    279-290     如192.168.0.36    192168000036
服务器端口：  291-295     如805             00805  

用户逻辑类
-------------------------------------------------------------------------------
| 296    |  297    |  298    |  299    |  300    |  301    |  302    |303     |
------------------------------------------------------------------------------- 
|心跳设置|心跳时间           |心跳地址           | 心跳计数|
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
| 304    |  305    |  306    |  307    |  308    |  309    |  310    |311     |
------------------------------------------------------------------------------- 
|                                                                             |
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
|  312   | 313    |  314    |  315    |  316    |  317    |  318    |  319    |
------------------------------------------------------------------------------- 
|                                                         |	  补充类提示			  显示字符类
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
|  320   | 321    |  322    |  323    |  324    |  325    |  326    |  327    |
------------------------------------------------------------------------------- 
|                      补充类提示                                             |
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
|  328   | 329    |  330    |  331    |  332    |  333    |  334    |  335    |
------------------------------------------------------------------------------- 
|                      补充类提示                                             |
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
|  336   | 337    |  338    |  339    |  340    |  341    |  342    |  343    |
------------------------------------------------------------------------------- 
|                            ADC类提示1                                        |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  344   | 345    |  346    |  347    |  348    |  349    |  350    |  351    |
------------------------------------------------------------------------------- 
|                            ADC类提示1                                        |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  352   | 353    |  354    |  355    |  356    |  357    |  358    |  359    |
------------------------------------------------------------------------------- 
|                 |        数据类提示1                                        |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  360   | 361    |  362    |  363    |  364    |  365    |  366    |  367    |
------------------------------------------------------------------------------- 
|                          数据类提示1                                        |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  368   | 369    |  370    |  371    |  372    |  373    |  374    |  375    |
------------------------------------------------------------------------------- 
|          数据类提示1                |       wifi类提示1                     |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  376   | 377    |  378    |  379    |  380    |  381    |  382    |  383    |
------------------------------------------------------------------------------- 
|				                 wifi类提示1                                  |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  384   | 385    |  386    |  387    |  388    |  389    |  390    |  391    |
------------------------------------------------------------------------------- 
|              wifi类提示1                                |	开机LOGO文字	  |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  392   | 393    |  394    |  395    |  396    |  397    |  398    |  399    |
------------------------------------------------------------------------------- 
|				                开机LOGO文字                                  |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  400   | 401    |  402    |  403    |  404    |  405    |  406    |  407    |
------------------------------------------------------------------------------- 
|                                 开机LOGO文字                                |
-------------------------------------------------------------------------------

296:心跳设置 0x02:设置心跳  0x01:开机心跳   0x00:无心跳  0x03：both

扩展区
-------------------------------------------------------------------------------
|  408   | 409    |  410    |  411    |  412    |  413    |  414    |  415    |
------------------------------------------------------------------------------- 
|上传方式|上传时长|报警检测 |报警标识 |报警模式 |报警方式 |    低门限值		  |
-------------------------------------------------------------------------------
|  416   | 417    |  418    |  419    |  420    |  421    |  422    |  423    |
------------------------------------------------------------------------------- 
|地门限值         |高门限值 							  |补充类显示缓存	  |
-------------------------------------------------------------------------------
|  424   | 425    |  426    |  427    |  428    |  429    |  430    |  431    |
------------------------------------------------------------------------------- 
						   补充类显示缓存
-------------------------------------------------------------------------------
|  432   | 433    |  434    |  435    |  436    |  437    |  438    |  439    |
------------------------------------------------------------------------------- 
						   补充类显示缓存
-------------------------------------------------------------------------------
|  440   | 441    |  442    |  443    |  444    |  445    |  446    |  447    |
------------------------------------------------------------------------------- 
				   LCD显示缓存0 
-------------------------------------------------------------------------------
|  448   | 449    |  450    |  451    |  452    |  453    |  454    |  455    |
------------------------------------------------------------------------------- 
				   LCD显示缓存0 
-------------------------------------------------------------------------------
|  456   | 457    |  458    |  459    |  460    |  461    |  462    |  463    |
------------------------------------------------------------------------------- 
|                 |                      LCD显示缓存1                     	  |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  464   | 465    |  466    |  467    |  468    |  469    |  470    |  471    |
------------------------------------------------------------------------------- 
|                        LCD显示缓存1                                         |
-------------------------------------------------------------------------------   

-------------------------------------------------------------------------------
|  472   | 473    |  474    |  475    |  476    |  477    |  478    |  479    |
------------------------------------------------------------------------------- 
|        LCD显示缓存1    			  |         数据类待显示缓存1             |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  480   | 481    |  482    |  483    |  484    |  485    |  486    |  487    |
------------------------------------------------------------------------------- 
|                    数据类待显示缓存1                                        |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  488   | 489    |  490    |  491    |  492    |  493    |  494    |  495    |
------------------------------------------------------------------------------- 
|                      数据类待显示缓存1		             |ADC类待显示缓存1|
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  496   | 497    |  498    |  499    |  500    |  501    |  502    |  503    |
------------------------------------------------------------------------------- 
|                               ADC类待显示缓存1                              |
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
|  504   | 505    |  506    |  507    |  508    |  509    |  510    |  511    |
------------------------------------------------------------------------------- 
|                               ADC类待显示缓存1                              |
-------------------------------------------------------------------------------

========================================*/

//256--275
BYTE code INFO_14432[][18] = {
	{0x20,0x20,0x20,0x20,0x20,0x20,0xc9,0xe8,0xb1,0xb8,0xb9,0xca,0xd5,0xcf,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xb5,0xb9,0xbc,0xc6,0xca,0xb1,0x00,0x00,0x00,0x53,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xb5,0xb9,0xbc,0xc6,0xca,0xb1,0x00,0x00,0x00,0x53,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xc7,0xeb,0xd6,0xd8,0xd0,0xc2,0xc6,0xf4,0xb6,0xaf,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0x20,0x20,0xc9,0xe8,0xd6,0xc3,0xb3,0xc9,0xb9,0xa6,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xc9,0xe8,0xb1,0xb8,0xb2,0xbb,0xc6,0xa5,0xc5,0xe4,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
	{0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xc1,0xac,0xbd,0xd3,0xb3,0xc9,0xb9,0xa6,0x20,0x20},
	{0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xc1,0xac,0xbd,0xd3,0xca,0xa7,0xb0,0xdc,0x20,0x20},
	{0x20,0x20,0xd6,0xd8,0xd0,0xc2,0xc5,0xe4,0xd6,0xc3,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9},
	{0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xb3,0xc9,0xb9,0xa6},
	{0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xd6,0xd8,0xd6,0xc3},
	{0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
	{0x20,0x20,0xa3,0xd7,0xa3,0xc9,0xa3,0xc6,0xa3,0xc9,0xc1,0xac,0xbd,0xd3,0xca,0xa7,0xb0,0xdc},
	{0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xd6,0xf7,0xbb,0xfa,0xb4,0xed,0xce,0xf3,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xb7,0xfe,0xce,0xf1,0xc6,0xf7,0xb3,0xac,0xca,0xb1,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0xbb,0xd8,0xb8,0xb4,0xb4,0xed,0xce,0xf3,0x20,0x20,0x20,0x20,0x20,0x20},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0xce,0xd5,0xca,0xd6,0xd0,0xc5,0xcf,0xa2,0x20,0x20},
	{0x20,0x20,0x20,0x20,0x20,0x20,0xbb,0xd8,0xb8,0xb4,0xb3,0xc9,0xb9,0xa6,0x20,0x20,0x20,0x20},
	{0x20,0x20,0x20,0x20,0x20,0x20,0xbb,0xf0,0xc7,0xe9,0xcc,0xe1,0xca,0xbe,0x20,0x20,0x20,0x20}
};

BYTE code INFO_1620[][16] = {
	{0x20,0x20,'S','E','N','S','O','R',' ','F','A','U','L','T',0x20,0x20},
	{'C','O','U','N','T','D','O','W','N',':',' ',0x00,0x00,0x00,0x20,0x20},
	{'C','O','U','N','T','D','O','W','N',':',' ',0x00,0x00,0x00,0x20,0x20},
	{' ','P','L','E','A','S','E',' ','R','E','S','T','A','R','T',' '},
	{'S','E','T',' ','S','U','C','C','E','S','S','F','U','L','L','Y'},
	{' ',' ',' ','M','I','S','M','A','T','C','H','I','N','G',' ',' '},
	{' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '},
	{' ',' ',' ',' ','C','O','N','N','E','C','T','E','D',' ',' ',' '},
	{' ',' ','D','I','S','C','O','N','N','E','C','T','E','D',' ',' '},
	{' ',' ','W','I','F','I',' ',' ','C','O','N','F','I','G',' ',' '},
	{' ',' ','W','I','F','I','C','O','N','N','E','C','T','E','D',' '},
	{' ','W','I','F','I','R','E','C','O','N','N','E','C','T','E','D'},
	{' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '},
	{'W','I','F','I','D','I','S','C','O','N','N','E','C','T','E','D'},
	{' ',' ',' ','H','O','S','T',' ','E','R','R','O','R',' ',' ',' '},
	{' ','S','E','R','V','E','R',' ','T','I','M','E','O','U','T',' '},
	{' ',' ','R','E','T','U','R','N',' ','E','R','R','O','R',' ',' '},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,' ',' ',' ',' ',' ',' ',' ',' '},
	{0x20,0x00,0x00,0x00,0x00,0x00,'H','A','N','D','S','H','A','K','E',0x20},
	{0x20,0x20,0x20,'R','E','C','V',0x20,0x20,'D','A','T','A',0x20,0x20,0x20}
};

BYTE xdata EEPROM_Buffer[512];

#define FOSC 11059200L              //System frequency
#define T1MS 19455//50ms  12分频
//(65536-FOSC/12/1000) 1ms timer calculation method in 1T mode
//(65536-FOSC/1000) 1ms timer calculation method in 1T mode
#define BAUD0 9600                  //UART baudrate 9600
#define BAUD1 115200                //UART baudrate 115200

sbit rs485_wr = P2^2;

//串口接收
#define MaxRecvBuff1   4
#define MaxRecvBuff2   59         
//#define Recv_DelayTime1 200

BYTE xdata Recv_Buff2[MaxRecvBuff2];  //
BYTE xdata Recv_Buff1[MaxRecvBuff1];
bit recv2;//
bit recv1;		                   
BYTE Recv_Num2;//
BYTE Recv_Num1;
bit busy2;//
bit busy1;
//串口发送
/*********优先级定义**************   
       0 	1       2        3       4      5
上传   √	√       ×        ×       ×      ×
心跳   √ 	√       √        ×       ×      ×
回复   √ 	√		√		 √		 ×      ×
.....  √	√		√		 √       √	    ×
**********************************/
BYTE xdata Send_Buff2[MaxRecvBuff2]; 
BYTE xdata Send_Buff1[MaxRecvBuff1];
BYTE Send_Num2;
BYTE Send_Pri2;       

BYTE xdata Send_Buff1[MaxRecvBuff1]; 
BYTE Send_Num1;     
        
//定时器
WORD Timer_Count0,TimerNum0;
WORD Timer_Step; 
bit Timer_Up0;
bit ding;                                     //一次计数
void Start_Timer0(WORD count,bit Mode);
BYTE Get_Buff1(BYTE * Buffer);
BYTE Get_Buff2(BYTE * Buffer);
void ClearBuff1();
void ClearBuff2();

//===================ADC类特定设置==============
void ADC_P_Init();
BYTE ADC_P;
BYTE ADC_ID;
BYTE ADC[10];
BYTE ADC_Average;
WORD ADC_Integer,ADC_Decimal;
BYTE ADC_sign;		           //暂未使用
WORD ADC_REF;                  //adc修正值
WORD ADC_100,ADC_0;            //百分比修正值
BYTE ADC_Count;                //ADC计数值
bit sign_08;


bit fire_sign;
sbit test_315m = P2^1; 
            

//===================数据类特定设置==============
void DATA_P_Init();
BYTE DATA_ID;
BYTE TPL,TPH;                    //18b20参数
BYTE AM2305_Data[5];             //am2305参数        
WORD DATA_Integer,DATA_Decimal;
BYTE DATA_sign;
WORD DATA_100,DATA_0;            //百分比修正值
BYTE DATA_Count;                 //数据计数值
BYTE YES_NO[2];

//===================补充类特定设置==============
void EXTRA_P_Init();
BYTE EXTRA_ID;
BYTE EXTRA_sign;
WORD EXTRA_Integer,EXTRA_Decimal;
//===================字符串处理============
void WordToStr(unsigned int integer,BYTE num);
BYTE xdata str_i[5],str_d[5];

//===================WIFI SET==============
void Wifi_CMode();
void Wifi_TMode();
BYTE GetSockBStatus();
void Wifi_ReStart();
void Wifi_ReStart2();
void Wifi_AP();
void Wifi_STA();
void Wifi_APSTA();
BYTE Wifi_STATUS();
BYTE Get_Mode();
BYTE Get_WSLK();
void Wifi_MDCH();

#define Recv_DelayTime2 200
BYTE Wifi_status_flag;
sbit wifi_reset = P2^0; 
/*==================LCD处理================
                 
=========================================*/
BYTE LCD_ID;
BYTE Show_ID;                                 //马上显示
BYTE Screen_Array[3],Screen_Num,Screen_Count;  //分屏显示资源数组和分屏显示资源数量及计数
BYTE Screen_Fresh = 3;            			//刷新周期（ding）数量
BYTE Screen_Fresh_Count;
bit Screen_Fresh_flag=0;
BYTE SChar_Line,SChar_Start,SChar_Time;        //提示字符显示行和起始位置及驻屏时间
void Screen_refresh();                         //分屏显示资源重新统计
void ShowLine(BYTE line,WORD start);
//RAM缓冲区
//BYTE xdata LCDScreen[64];	                  //兼容1602 14432 12864

/*==================协议解析================
错误码                    意义
  0                       成功
  1                       头错误
  2 					  地址错误
  3                       序列号错误
  4                       指令地址值错误
  5                       指令载荷数错误
  6                       没有匹配的资源
==========================================*/
BYTE Src_Addr[2];
BYTE Remote_Addr[2];

typedef struct Pro_0_0
{
	BYTE Mark_Head[2];
	BYTE Des_Addr[2];
	BYTE Src_Addr[2];
	BYTE Seq_Num;
	BYTE Command;
	BYTE Payload_Num;
	BYTE Payload[MaxRecvBuff2-9];
}Pro_0_0;

typedef union protocol
{
	Pro_0_0 Pro_Struct;
	BYTE Pro_Buff[MaxRecvBuff2];
}protocol;

void ClearPro_Buffer();

protocol xdata pro;

BYTE Seq_Number;
BYTE Parse(BYTE HAddr,BYTE LAddr,BYTE num);

void Command_01();
BYTE Command_07();
BYTE Command_09();
BYTE Command_0F();
BYTE Command_11();
BYTE Command_13();
BYTE Command_15();
BYTE Command_17();
BYTE Command_19();
BYTE Command_1b();
BYTE Command_1d();
BYTE Command_1f();		            //传输失败可能没用

/*=================用户逻辑================
                 
=========================================*/
WORD Heart_Time;               //心跳定时时间
WORD Heart_Count;              //心跳定时计数
bit Server_Flag;               //服务器连接标识
void Heart_Process();          //心跳处理


void main()
{
	WORD i,j,integer,decimal;
	BYTE num,k;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	//EEPROM操作  
	Delayms(500);                         
	GetSector(0,EEPROM_Buffer);                   //EEPROM读取
	EEPROM_Buffer[278] = 1;
	//EEPROM_Buffer[318] = 0x20;					  //空格
	//EEPROM_Buffer[319] = 0x20;
	//EEPROM_Buffer[336] = 0x20;
	//EEPROM_Buffer[337] = 0x20;
	//EEPROM_Buffer[354] = 0x20;
	//EEPROM_Buffer[355] = 0x20;
	Server_Flag = 0;
	LCD_ID = EEPROM_Buffer[1];
	ADC_ID = EEPROM_Buffer[3];
	DATA_ID = EEPROM_Buffer[4];
	EXTRA_ID = EEPROM_Buffer[6];
	ADC_REF = ((WORD)EEPROM_Buffer[10]<<8)+(WORD)EEPROM_Buffer[11];		  //ADC参考电压
	if((EEPROM_Buffer[296]&0x02)==0x02)
	{
		Heart_Time = ((WORD)(EEPROM_Buffer[297])<<8)+(WORD)EEPROM_Buffer[298];
		Heart_Count = 0;
	}
	Screen_refresh();                            //资源计数
	EEPROM_Buffer[440] = 0xff;					 //避免开机不显示  不重要
    EEPROM_Buffer[458] = 0xff;
	Src_Addr[0] = EEPROM_Buffer[162];
	Src_Addr[1] = EEPROM_Buffer[163];
	Seq_Number = 0;
	Timer_Step = (WORD)EEPROM_Buffer[8];//*125;
	LcdInit1();                                    //14432和1602暂同使用一个初始化程序
	rs485_wr = 1;
	EEPROM_Buffer[34] = 0;					     //初始状态各行都不刷新
	EEPROM_Buffer[35] = 0;
	EEPROM_Buffer[36] = 0;
	EEPROM_Buffer[37] = 0;
	Delayms(500);
	ShowLine(0,390);
	//while(1);
	Timer_Uart_Init();
	Send_Pri2 = 0;                         //最低优先级
	Send_Num2 = 0;                         //没有数据装载
	//检查是否有ADC类初始化
	ADC_P = 0x00;
	if(ADC_ID != 0xff)
	{	
		ADC_P_Init();
		switch(ADC_ID)
		{
			case 0x01:
				ADC_P |= EEPROM_Buffer[85];	             //默认值为0x01 0x31  045 3个脚
				InitADC(ADC_P);
				break;
			case 0x02:
				ADC_P |= EEPROM_Buffer[85];	             //默认值为0x01
				InitADC(ADC_P);
				break;			 
		/*	case 0x05:
				DS18B20_Init();
				break;	 */
			case 0x08:
				ADC_P |= EEPROM_Buffer[85];	             //默认值为0x02
				InitADC(ADC_P);
				sign_08 = 0;                             //初始化默认为0
				EEPROM_Buffer[89] = 1;
				Show_ID = 3;
				break;
			case 0x09:
				ADC_P |= EEPROM_Buffer[85];	             //默认值为0x02
				InitADC(ADC_P);
				break;
			default:
				break;	
		}	
	}
		
	//检查数据类 初始化
	ADC_P = 0x00;
	if(DATA_ID != 0xff)
	{
		DATA_P_Init();
		switch(DATA_ID)
		{
		/*	case 0x01:
				ADC_P |= EEPROM_Buffer[141];	             //默认值为0x02
				InitADC(ADC_P);
				break;
			case 0x02:
				ADC_P |= EEPROM_Buffer[141];	             //默认值为0x02
				InitADC(ADC_P);
				break;		*/
			case 0x05:
				DS18B20_Init();
				break;
		/*	case 0x08:
				break;	   */
			default:
				break;	
		}	
	}
	//扩充类的初始化
	if(EXTRA_ID != 0xff)
	{
	}
	//补充传感器   火警
    if(EEPROM_Buffer[12] != 0xff){
		fire_sign = 0;
		IT0 = 1;                        //set INT0 int type (1:Falling 0:Low level)
    	EX0 = 1;   
	}
	
	//保证wifi芯片完全启动
	Delayms(5000);

	Wifi_status_flag = 0;
	//ShowLine(0,273);

	if(EEPROM_Buffer[160] == 0)
	{
		if(EEPROM_Buffer[161]>0)
		{
			//ShowLine(0,372);
			//进入命令模式
			//Wifi_CMode();
			//换算出AP SSID和密码 ,默认WAP2PSK
			i = ((WORD)Src_Addr[0]<<8)+(WORD)Src_Addr[1];								 
			WordToStr(i,0);
			/***
			//根据模式做出相应操作
			if((EEPROM_Buffer[161]|0x01)==0x01)                     //ap模式
			{
			    //2、设置AP参数，部分参数直接填写默认值
			    Wifi_AP();
				Wifi_ReStart();
			} 
			if(EEPROM_Buffer[161]|0x02)                     //STA模式
			{
				//暂未处理

			} 
			if((EEPROM_Buffer[161]|0x04)==0x04)                     //APSTA模式
			{
				Wifi_APSTA();
				Wifi_ReStart();
			} 	***/
			if((EEPROM_Buffer[161]|0x08)==0x08)
			{
				/*** /
				Wifi_AP();
				Delayms(200);
				Wifi_ReStart();
				Delayms(3000);
				//Wifi_CMode();
				/**/
				//Wifi_MDCH();
				//while(1);
			//Wifi_status_flag = Wifi_STATUS();
			}
		}
		//EEPROM_Buffer[160] = 1;
	    //EEPROM_Buffer[5] = EEPROM_Buffer[5] - 10;           //初始化时间缩短了 
		//IapEraseSector(0);                                 //先擦后写
		//WriteSector(0,EEPROM_Buffer);                      //EEPROM写入	
		Delayms(3000);
		ClearBuff2();
		//if(Wifi_status_flag == 20){
			//Command_01();
		//}
		Delayms(15000);
	}else                                        //不做初始化
	{
		Delayms(10000);
	}
	
	Start_Timer0(Timer_Step,1);
    //变量初始化为0
	SChar_Line = 0;
	SChar_Time = 0;
	SChar_Start = 0;
	ding = 0;
	//9S一次喂狗
	//WDT_CONTR = 0x3f; 
	while(1)
	{
/*************************************数据采集处理**************************************/
		//先判断是否设置了数据类  03 04 05 06 07  可以处理
		if(DATA_ID != 0xff)
		{
			//再判断初始化时间是否结束
			if((EEPROM_Buffer[142]==0)&&(EEPROM_Buffer[145]>0))
			{
				//再判断采集是否打开 
				switch(EEPROM_Buffer[104])
				{
					case 0x00:
						break;
					//循环采集
					case 0xfb:
						if(EEPROM_Buffer[111]==0)       	//非持续报警
						{
							EEPROM_Buffer[109] = 0;	    //清警
							EEPROM_Buffer[140] = 0;  	//清障	
						}
						if(DATA_ID == EXTRA_ID-1)
						{
							if(EEPROM_Buffer[413]==0)       	//非持续报警
							{
								EEPROM_Buffer[411] = 0;	    //清警	
							}	
						}
						switch(DATA_ID)
						{
							case 0x01:
								break;
							case 0x02:
								break;
							case 0x03:                     //DHT11
								EA = 0;
								k = AM2305_Start(18);
								if(k==0)
								{
									for(i=0;i<5;i++)
									{
										AM2305_Data[i] = AM2305_ReadByte();	
									}
									j = (WORD)AM2305_Data[0] + (WORD)AM2305_Data[1] + (WORD)(AM2305_Data[2]) + (WORD)AM2305_Data[3]; 
									if((BYTE)j==AM2305_Data[4])
									{
										DATA_Integer = AM2305_Data[0];
										DATA_Decimal = AM2305_Data[1];
								        EXTRA_Integer = AM2305_Data[2];
										EXTRA_Decimal = AM2305_Data[3];
										if(AM2305_Data[2]&0x80)
										{
											EXTRA_sign = 0x2d;
										}else
										{
											EXTRA_sign = 0x2b;
										}
									}
									else
									{
										EEPROM_Buffer[140] |= 0x01;               //断路？？？
									}
								}
								else
								{
									EEPROM_Buffer[140] |= 0x01;               //断路？？
								}
								EA = 1;
								break;
							case 0x05:				       //18b20
								DS18B20_Init();
								TPL = DS18B20_ReadByte();                     //读温度低字节
								TPH = DS18B20_ReadByte();                     //读温度高字节
	    						DATA_Integer = Get_Integer(TPH,TPL);
								DATA_Decimal = Get_Decimal(TPL);
								if((TPH == 0x05)&&(TPL==0x50))
								{
									EEPROM_Buffer[140] |= 0x02;               //初始化未完成造成？
								}
								if((TPH&0x07==0x07)&&(TPL==0xff))
								{
									EEPROM_Buffer[140] |= 0x01;               //断路
								}
								if((TPH>>8)&0x01)
								{
									DATA_sign = 0x2d;
									DATA_Integer |= 0x8000;
									DATA_Decimal |= 0x8000;	
								}
								else
								{
									DATA_sign = 0x2b;	
								}
								break;
							case 0x06:					  //am2305,注意填充补充类
								EA = 0;
								k = AM2305_Start(2);
								if(k==0)
								{
									for(i=0;i<5;i++)
									{
										AM2305_Data[i] = AM2305_ReadByte();	
									}
									j = (WORD)AM2305_Data[0] + (WORD)AM2305_Data[1] + (WORD)(AM2305_Data[2]) + (WORD)AM2305_Data[3]; 
									if((BYTE)j==AM2305_Data[4])
									{
										DATA_Integer = ((WORD)AM2305_Data[0]<<8)+((WORD)AM2305_Data[1]);
										DATA_Decimal = 0;
								        EXTRA_Integer = ((WORD)AM2305_Data[2]<<8)+((WORD)AM2305_Data[3]);
										EXTRA_Decimal = 0;
										if(AM2305_Data[2]&0x80)
										{
											EXTRA_sign = 0x2d;
										}else
										{
											EXTRA_sign = 0x2b;
										}
									}
									else
									{
										EEPROM_Buffer[140] |= 0x01;               //断路？？？
									}
								}
								else
								{
									EEPROM_Buffer[140] |= 0x01;               //断路？？
								}
								EA = 1;
								break;
							case 0x08:
								break;
							case 0x09:
								break;
							default:
								break;
						 }
						break;
					//0xfc--0xfe保留
					case 0xfc:
						break;
					case 0xfd:
						break;
					case 0xfe:
						break;
					//0xff 不处理
					case 0xff:
						break;
					default:
						//EEPROM_Buffer[104] = EEPROM_Buffer[104]-1;
						break;
				}	
			}
			else							//没有初始化完毕
			{
			}
		}

		//再判断是否设置了ADC类				01 02 08 09 可以处理
		if(ADC_ID != 0xff)
		{
			//再判断初始化时间是否结束
			if((EEPROM_Buffer[86]==0)&&(EEPROM_Buffer[89]>0))
			{
				//再判断采集是否打开
				switch(EEPROM_Buffer[48])
				{
					case 0x00:
						break;
					//循环采集
					case 0xfb:
						if(EEPROM_Buffer[55]==0)       	//非持续报警
						{
							EEPROM_Buffer[53] = 0;	    //清警
							EEPROM_Buffer[84] = 0;  	//清障	
						}
						switch(ADC_ID)
						{
							//高于高的，低于低的认为断路
							case 0x01:
								for(i=0;i<10;i++)
								{
									ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
									Delayms(EEPROM_Buffer[82]);
								}
								ADC_Average = Average(ADC);
								ADC_Integer = Vin_8(ADC_Average,ADC_REF);
								ADC_Decimal = 0;
								integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
								i = Compare(ADC_Integer,integer);
								if(i == 1)
								{
									//EEPROM_Buffer[84]|=0x01;
								}
								else if(i==0)
								{
									decimal = (((WORD)EEPROM_Buffer[93])<<8)+(WORD)EEPROM_Buffer[94];
									i = Compare(ADC_Integer,decimal);
									if(i == 1)
									{
										//EEPROM_Buffer[84]|=0x01;
									}
								}
								break;
							case 0x02:
								for(i=0;i<10;i++)
								{
									ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
									Delayms(EEPROM_Buffer[82]);
								}
								ADC_Average = Average(ADC);
								j = Vin_8(ADC_Average,ADC_REF);              //j应该大于1000
								EA = 0;
								//i = (ADC_100-ADC_0)/100;
								if(j>=ADC_100)
								{
									ADC_Integer = 1000;
								}else if(j<=ADC_0)
								{
									ADC_Integer = 0;
								}else
								{
									ADC_Integer = ((j-ADC_0)*10)>>5;//i;	
								}
								ADC_Decimal = 0;
								EA = 1;
								integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
								i = Compare(j,integer);
								if(i == 2)
								{
									EEPROM_Buffer[84]|=0x01;
								}
								else if(i==0)
								{
									EEPROM_Buffer[84]|=0x01;
								}
								break;
							case 0x08:
								num = 0;
								k = 0;
								if(EEPROM_Buffer[100]==0x00)
								{
									for(i=0;i<EEPROM_Buffer[101];i++)
									{
										ADC_Average = GetADCResult(EEPROM_Buffer[85]-1);
										if(ADC_Average<EEPROM_Buffer[102])		   //判决值，低电平有效
										{
											k++;
										}
										Delayms(EEPROM_Buffer[82]);
									}
									if(k>=EEPROM_Buffer[103])   //判决次数门限，表示有动作
									{
										num = 1;
										//低电平报警
									    if(EEPROM_Buffer[54]&0x02){
											EEPROM_Buffer[53]|=0x02;
										}
										if((EEPROM_Buffer[50]&0x04) == 0x04)	            //报警上传
										{
											if(EEPROM_Buffer[53]!=0)
											{
												EEPROM_Buffer[90]=1;				 //需要上传	
											}
										}	
									}
									else
									{
										num = 0;
									}			
								}else 
								if(EEPROM_Buffer[100]==0x01)
								{
									for(i=0;i<EEPROM_Buffer[101];i++)
									{
										ADC_Average = GetADCResult(EEPROM_Buffer[85]-1);
										if(ADC_Average>EEPROM_Buffer[102])		   //判决值,高电平有效
										{
											k++;
										}
										Delayms(EEPROM_Buffer[82]);
									}
									if(k>=EEPROM_Buffer[103])   //判决次数门限，表示有动作
									{
										num = 1;
									}
									else
									{
										num = 0;
									}			
								}

								
								if(num==1)
								{
									ADC_Integer = 10;
									ADC_Decimal = 0;
									if(LCD_ID == 0x14)		   //有 
									{
										YES_NO[0] = 0xd3;
										YES_NO[1] = 0xd0;
									}else 
									if(LCD_ID == 0x13)		 //Y 
									{
										YES_NO[0] = 0x59;
										YES_NO[1] = 0x20;
									}
									if(sign_08 == 0)				   //状态翻转
									{
										sign_08 = 1;
										Show_ID = 3;                   //特别提示要显示	
									}
									num = 0;
								}
								else
								{
									ADC_Integer = 5;
									ADC_Decimal = 0;
									if(LCD_ID == 0x14)		   // 无
									{
										YES_NO[0] = 0xce;
										YES_NO[1] = 0xde;
									}else 
									if(LCD_ID == 0x13)		 // N
									{
										YES_NO[0] = 0x4e;
										YES_NO[1] = 0x20;
									}
									if(sign_08 == 1)				   //状态翻转
									{
										sign_08 = 0;
										Show_ID = 3;                   //特别提示要显示	
									}	
								}
								break;
							case 0x09:
								for(i=0;i<9;i++)
								{
									ADC[i] = GetADCResult(EEPROM_Buffer[85]-1);
									Delayms(EEPROM_Buffer[82]);
								}
								ADC_Average = Average(ADC);
								j = Vin_8(ADC_Average,ADC_REF);              //j应该大于0	   千位
								EA = 0;
								if(j>=ADC_100)
								{
									ADC_Integer = 0;
								}else if(j<=ADC_0)
								{
									ADC_Integer = 100;
								}else
								{
									ADC_Integer = ((ADC_100-j)*10)>>9;	
								}
								ADC_Decimal = 0;
								EA = 1;
							/*	integer = ((WORD)EEPROM_Buffer[91]<<8)+(WORD)EEPROM_Buffer[92];
								i = Compare(j,integer);
								if(i == 2)
								{
									EEPROM_Buffer[84]|=0x01;
								}
								else if(i==0)
								{
									EEPROM_Buffer[84]|=0x01;
								}  */
								break;
							default:
								break;
						 }
						break;
					//0xfc--0xfe保留
					case 0xfc:
						break;
					case 0xfd:
						break;
					case 0xfe:
						break;
					//0xff 不处理
					case 0xff:
						break;
					default:
						break;
				}	
			}
			else							//没有初始化完毕
			{
			}
		}
/*************************************数据报警处理************************************************/
		//先判断是否设置了数据类
		if(DATA_ID != 0xff)
		{
			//再判断初始化时间是否结束
			if(EEPROM_Buffer[142]==0)
			{
				if((EEPROM_Buffer[145]==1)&&(EEPROM_Buffer[108]==1))			     //是否进行采集+报警检测是否开启
				{
					//故障判断		 只能检查断路,低门限值断路
					//18b20采集时自行判断
					if(EEPROM_Buffer[106]&0x08 == 0x08)
					{
						if(EEPROM_Buffer[140]!=0x00)
							EEPROM_Buffer[146]=1;				                    //需要上传
					}
					//低门限值判断
					if(EEPROM_Buffer[110]&0x02)					                
					{
						integer = (((WORD)EEPROM_Buffer[112])<<8)+(WORD)EEPROM_Buffer[113];
						i = Compare(DATA_Integer,integer);
						if(i == 2)
						{
							EEPROM_Buffer[109]|=0x02;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[114])<<8)+(WORD)EEPROM_Buffer[115];
							i = Compare(DATA_Decimal,decimal);
							if(i != 1)
							{
								EEPROM_Buffer[109]|=0x02;
							}
						} 
					}
					//高门限值判断
					if(EEPROM_Buffer[110]&0x01)					 
					{
						integer = (((WORD)EEPROM_Buffer[116])<<8)+(WORD)EEPROM_Buffer[117];
						i = Compare(DATA_Integer,integer);
						if(i == 1)
						{
							EEPROM_Buffer[109]|=0x01;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[118])<<8)+(WORD)EEPROM_Buffer[119];
							i = Compare(DATA_Decimal,decimal);
							if(i != 2)
							{
								EEPROM_Buffer[109]|=0x01;
							}
						} 
					}
					if((EEPROM_Buffer[106]&0x04)==0x04)	            //报警上传
					{

						if(EEPROM_Buffer[109]!=0)
						{
							EEPROM_Buffer[146]=1;				 //需要上传
						}
					}
				}
			}
		}

		//再判断是否设置了ADC类		  08自行判断
		if((ADC_ID != 0xff)&&(ADC_ID!=0x08))
		{
			//再判断初始化时间是否结束
			if(EEPROM_Buffer[86]==0)
			{
				if((EEPROM_Buffer[89]==1)&&(EEPROM_Buffer[52]==1))			     //是否进行采集+报警检测是否开启
				{
					//出现故障是否上传
					if(EEPROM_Buffer[50]&0x08 == 0x08)
					{
						if(EEPROM_Buffer[84]!=0x00)
							EEPROM_Buffer[90]=1;				                    //需要上传
					}
					//低门限值判断
					if(EEPROM_Buffer[54]&0x02)					                
					{
						integer = (((WORD)EEPROM_Buffer[56])<<8)+(WORD)EEPROM_Buffer[57];
						i = Compare(ADC_Integer,integer);
						if(i == 2)
						{
							EEPROM_Buffer[53]|=0x02;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[58])<<8)+(WORD)EEPROM_Buffer[59];
							i = Compare(ADC_Decimal,decimal);
							if(i != 1)
							{
								EEPROM_Buffer[53]|=0x02;
							}
						} 
					}
					//高门限值判断
					if(EEPROM_Buffer[54]&0x01)					 
					{
						integer = (((WORD)EEPROM_Buffer[60])<<8)+(WORD)EEPROM_Buffer[61];
						i = Compare(ADC_Integer,integer);
						if(i == 1)
						{
							EEPROM_Buffer[53]|=0x01;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[62])<<8)+(WORD)EEPROM_Buffer[63];
							i = Compare(ADC_Decimal,decimal);
							if(i != 2)
							{
								EEPROM_Buffer[53]=1;
							}
						} 
					}
					if((EEPROM_Buffer[50]&0x04) == 0x04)	            //报警上传
					{
						if(EEPROM_Buffer[53]!=0)
						{
							EEPROM_Buffer[90]=1;				 //需要上传	
						}
					}	
				}
			}
		}

		//先判断是否设置了补充类
		if((EXTRA_ID == DATA_ID+1)&&(EXTRA_ID !=0xff))
		{
			//再判断初始化时间是否结束
			if(EEPROM_Buffer[142]==0)
			{
				if((EEPROM_Buffer[145]==1)&&(EEPROM_Buffer[410]==1))			     //是否进行采集+报警检测是否开启
				{
					//补充类故障报警
					if(EEPROM_Buffer[408]&0x08 == 0x08)
					{
						if(EEPROM_Buffer[140]!=0x00)
							EEPROM_Buffer[146]=1;				                    //需要上传
					} 
					//低门限值判断
					if(EEPROM_Buffer[412]&0x02)					                
					{
						integer = (((WORD)EEPROM_Buffer[414])<<8)+(WORD)EEPROM_Buffer[415];
						i = Compare(EXTRA_Integer,integer);
						if(i == 2)
						{
							EEPROM_Buffer[411]|=0x02;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[416])<<8)+(WORD)EEPROM_Buffer[417];
							i = Compare(EXTRA_Decimal,decimal);
							if(i != 1)
							{
								EEPROM_Buffer[411]|=0x02;
							}
						} 
					}
					//高门限值判断
					if(EEPROM_Buffer[412]&0x01)					 
					{
						integer = (((WORD)EEPROM_Buffer[418])<<8)+(WORD)EEPROM_Buffer[419];
						i = Compare(EXTRA_Integer,integer);
						if(i == 1)
						{
							EEPROM_Buffer[411]|=0x01;
						}
						else if(i == 0)
						{
							decimal = (((WORD)EEPROM_Buffer[420])<<8)+(WORD)EEPROM_Buffer[421];
							i = Compare(EXTRA_Decimal,decimal);
							if(i != 2)
							{
								EEPROM_Buffer[411]|=0x01;
							}
						} 
					}
					if((EEPROM_Buffer[408]&0x04) == 0x04)	            //报警上传
					{
						if(EEPROM_Buffer[411]!=0)
						{
							EEPROM_Buffer[146]=1;				 //需要上传	
						}
					}
				}
			}
		}
/*************************************报警上传准备************************************************/
		num = 0;  //上传初始计数
		//先判断是否设置了数据类
		if(DATA_ID != 0xff)
		{
			//再判断初始化时间是否结束,是否有新上传
			if((EEPROM_Buffer[142]==0)&&(EEPROM_Buffer[146]!=0))
			{
				p->Payload[num] = DATA_ID;
				num++;
			    p->Payload[num] = (EEPROM_Buffer[140]<<4)+ EEPROM_Buffer[109];
				num++;
				p->Payload[num] = (BYTE)(DATA_Integer>>8);
				num++;
				p->Payload[num] = (BYTE)(DATA_Integer);
				num++;
				p->Payload[num] = (BYTE)(DATA_Decimal>>8);
				num++;
				p->Payload[num] = (BYTE)(DATA_Decimal);
				num++;
				//补充类
				if(EXTRA_ID == DATA_ID+1)
				{
					p->Payload[num] = EXTRA_ID;
					num++;
				    p->Payload[num] = (EEPROM_Buffer[140]<<4)+ EEPROM_Buffer[411];
					num++;
					p->Payload[num] = (BYTE)(EXTRA_Integer>>8);
					num++;
					p->Payload[num] = (BYTE)(EXTRA_Integer);
					num++;
					p->Payload[num] = (BYTE)(EXTRA_Decimal>>8);
					num++;
					p->Payload[num] = (BYTE)(EXTRA_Decimal);
					num++;
				}
			}
		}
		//再判断是否设置了ADC类
		if(ADC_ID != 0xff)
		{
			//再判断初始化时间是否结束,是否有新上传
			if((EEPROM_Buffer[86]==0)&&(EEPROM_Buffer[90]==1))
			{
				p->Payload[num] = ADC_ID;
				num++;
			    p->Payload[num] = (EEPROM_Buffer[84]<<4)+ EEPROM_Buffer[53];
				num++;
				p->Payload[num] = (BYTE)(ADC_Integer>>8);
				num++;
				p->Payload[num] = (BYTE)(ADC_Integer);
				num++;
				p->Payload[num] = (BYTE)(ADC_Decimal>>8);
				num++;
				p->Payload[num] = (BYTE)(ADC_Decimal);
				num++;
			}
			
		}

		//加插一个火警报警补充
		if(EEPROM_Buffer[12] != 0xff){
			if(test_315m == 0 && fire_sign==1){

				fire_sign = 0;

				SChar_Line = 0;                               
				SChar_Start = (BYTE)(276-256);
				SChar_Time = 10; 
				ShowLine(0,276);
			

				p->Payload[num] = 0x0c;
				num++;
			    p->Payload[num] = 0x01;
				num++;
				p->Payload[num] = 0;
				num++;
				p->Payload[num] = 0;
				num++;
				p->Payload[num] = 0;
				num++;
				p->Payload[num] = 0;
				num++;	

				Send_Buff1[0] = 0x32;
				Send_Buff1[1] = 0x37;
				Send_Num1 = 2;
				for(i=0;i<Send_Num1;i++)
				{
					SendData1(Send_Buff1[i]);
				}
				Send_Num1 = 0;
			}
		}

		 /** /
		//有数据要发送
	    if(num>0)
		{
			 //头处理
			 p->Mark_Head[0] = 0xa5;
			 p->Mark_Head[1] = 0x5a;
			 //目的地址需要计算
			 p->Des_Addr[0] = EEPROM_Buffer[301];
			 p->Des_Addr[1] = EEPROM_Buffer[302];
			 //本地地址写入
			 p->Src_Addr[0] = Src_Addr[0];
			 p->Src_Addr[1] = Src_Addr[1];
			 p->Seq_Num = Seq_Number;
			 Seq_Number++;
			 p->Command = 0xc;                                         //上传数据
			 p->Payload_Num = num;			                           //载荷长度
			 if(Send_Pri2<=1)
			 {
			 	for(i=0;i<num+9;i++)
			 	{
			 		Send_Buff2[i] = pro.Pro_Buff[i]; 
			 	}
			 	Send_Num2 = num +9;
				Send_Pri2 = 1;
			 }
		}
		/**/
/*************************************数据发送处理************************************************/
		if(ding)
		{
			if(Send_Pri2>0)
			{							   
				//ShowLine(0,258);
				for(i=0;i<Send_Num2;i++)
				{
					SendData2(Send_Buff2[i]);
				}
				Send_Num2 = 0;
				Send_Pri2 = 0;	
			}	
		}
/*************************************准备数据显示************************************************/
		//先判断是否设置了数据类
		if(DATA_ID != 0xff)
		{
			//再判断初始化时间是否结束,是否有新采集
			if((EEPROM_Buffer[142]==0)&&((EEPROM_Buffer[145]==1)))
			{
				//根据显示模式填写显示数据	   0   12345   6789?
				integer = (DATA_Integer&0x7fff);
				decimal = (DATA_Decimal&0x7fff);
				WordToStr(integer,0);
			    WordToStr(decimal,1);
				k = 0;
				for(i=0;i<EEPROM_Buffer[25];i++)
				{
					//处理显示行0 354 440
					//处理显示行1
					if(EEPROM_Buffer[i+120]==0x00)
					{
						EEPROM_Buffer[i+476] = YES_NO[k];	   //				 有无YN
						k++;
						if(k==2)
							k=0;
					}
					else if((EEPROM_Buffer[i+120]<0x30)||(EEPROM_Buffer[i+120]>0x39))
		            {
						EEPROM_Buffer[i+476] = EEPROM_Buffer[i+120];
					}
					else if(EEPROM_Buffer[i+120] == 0x30)
					{
						EEPROM_Buffer[i+476] = DATA_sign;	
					} else if((EEPROM_Buffer[i+120]>0x30)&&(EEPROM_Buffer[i+120]<=0x35))
					{
						j = EEPROM_Buffer[i+120] -0x30-1;
						EEPROM_Buffer[i+476] = str_i[j];
					}else if((EEPROM_Buffer[i+120]>0x35)&&(EEPROM_Buffer[i+120]<=0x39))
					{
						j = EEPROM_Buffer[i+120]-5-0x30-1;		  //6--str_d[1]
						EEPROM_Buffer[i+476] = str_d[j];
					}
				}
				//补充，是否填写后两位报警和上传状态
				if(EEPROM_Buffer[109]==0)
				{
					j = EEPROM_Buffer[25]-1-3;
					EEPROM_Buffer[j+476] = 0x20;
					EEPROM_Buffer[j+477] = 0x20;	
				}
				if(EEPROM_Buffer[146]==0)
				{
					j = EEPROM_Buffer[25]-1-1;
					EEPROM_Buffer[j+476] = 0x20;
					EEPROM_Buffer[j+477] = 0x20;	
				}
				//补充类
				if(EXTRA_ID == DATA_ID+1)
				{
					//根据显示模式填写显示数据	   0   12345   6789?
					integer = EXTRA_Integer;
					decimal = DATA_Decimal;
					WordToStr(integer,0);
				    WordToStr(decimal,1);
					k = 0;
					for(i=0;i<EEPROM_Buffer[25];i++)
					{	
						//处理显示行1
						if(EEPROM_Buffer[i+318]==0x00)
						{
							EEPROM_Buffer[i+422] = YES_NO[k];
							k++;
							if(k==2)
								k=0;
						}else
						if((EEPROM_Buffer[i+318]<0x30)||(EEPROM_Buffer[i+318]>0x39))
			            {
							EEPROM_Buffer[i+422] = EEPROM_Buffer[i+318];
						}
						else if(EEPROM_Buffer[i+318] == 0x30)
						{
							EEPROM_Buffer[i+422] = EXTRA_sign;	
						} else if((EEPROM_Buffer[i+318]>0x30)&&(EEPROM_Buffer[i+318]<=0x35))
						{
							j = EEPROM_Buffer[i+318] -0x30-1;
							EEPROM_Buffer[i+422] = str_i[j];
						}else if((EEPROM_Buffer[i+318]>0x35)&&(EEPROM_Buffer[i+318]<=0x39))
						{
							j = EEPROM_Buffer[i+318]-5-0x30-1;		  //6--str_d[1]
							EEPROM_Buffer[i+422] = str_d[j];
						}
					}
					//补充，是否填写后两位报警和上传状态
					if(EEPROM_Buffer[411]==0)
					{
						j = EEPROM_Buffer[25]-1-3;
						EEPROM_Buffer[j+422] = 0x20;
						EEPROM_Buffer[j+423] = 0x20;	
					}
					if(EEPROM_Buffer[146]==0)
					{
						j = EEPROM_Buffer[25]-1-1;
						EEPROM_Buffer[j+422] = 0x20;
						EEPROM_Buffer[j+423] = 0x20;	
					}	
				}//if(EXTRA_ID == DATA_ID)
			}
		}

		//再判断是否设置了ADC类
		if(ADC_ID != 0xff)
		{
			//再判断初始化时间是否结束,是否有新采集
			if((EEPROM_Buffer[86]==0)&&((EEPROM_Buffer[89]==1)))
			{
				//根据显示模式填写显示数据	   0   12345   6789?
				WordToStr(ADC_Integer,0);
			    WordToStr(ADC_Decimal,1);
				ADC_sign = 0x2b;
				k = 0;
				for(i=0;i<EEPROM_Buffer[25];i++)
				{
					//处理显示行0  336 458
					//处理显示行1
					if(EEPROM_Buffer[i+64]==0x00)
					{
						EEPROM_Buffer[i+494] = YES_NO[k];
						k++;
						if(k==2)
							k=0;
					}
					else if((EEPROM_Buffer[i+64]<0x30)||(EEPROM_Buffer[i+64]>0x39))
		            {
						EEPROM_Buffer[i+494] = EEPROM_Buffer[i+64];
					}
					else if(EEPROM_Buffer[i+64] == 0x30)
					{
						EEPROM_Buffer[i+494] = ADC_sign;	
					} 
					else if((EEPROM_Buffer[i+64]>0x30)&&(EEPROM_Buffer[i+64]<=0x35))
					{
						j = EEPROM_Buffer[i+64] -0x30-1;
						EEPROM_Buffer[i+494] = str_i[j];
					}
					else if((EEPROM_Buffer[i+64]>0x35)&&(EEPROM_Buffer[i+64]<=0x39))
					{
						j = EEPROM_Buffer[i+64]-5-0x30-1;		  //6--str_d[1]
						EEPROM_Buffer[i+494] = str_d[j];
					}
				}
				//补充，是否填写后两位报警和上传状态
				if(EEPROM_Buffer[53]==0)
				{
					j = EEPROM_Buffer[25]-1-3;
					EEPROM_Buffer[j+494] = 0x20;
					EEPROM_Buffer[j+495] = 0x20;	
				}
				if(EEPROM_Buffer[90]==0)
				{
					j = EEPROM_Buffer[25]-1-1;
					EEPROM_Buffer[j+494] = 0x20;
					EEPROM_Buffer[j+495] = 0x20;	
				}	
			}
		}
		
/*************************************显示处理数据************************************************/
		if(LCD_ID != 0xff)
		{
			k = 0;
			//分屏处理
			if(Screen_Num>0)		
			{
				//准备要显示的数据,并布置屏幕（12864屏幕暂没有布置）
				if(Screen_Fresh_flag)
				{
					k = Screen_Array[Screen_Count];	
					Screen_Fresh_flag = 0;
				}
			}
			//不分屏，只是要求显示时处理
		    else if(Show_ID>0)
			{   
				k = Show_ID;
				Show_ID = 0;
			}
				if(k>0)		  //有变化
				{
					switch(k)
					{
						case 3:
							if(ADC_ID != 0xff)
							{
								if(EEPROM_Buffer[86]==0)
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									EEPROM_Buffer[30] = (BYTE)(336-256);
									if(EEPROM_Buffer[84]==0)
									{
										//EEPROM_Buffer[30] = (BYTE)(458 - 256);
										EEPROM_Buffer[31] = (BYTE)(494 - 256);              //刷新位置
									}else
									{
										//EEPROM_Buffer[30] = 6; 							//显示空白
										EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
									}
								}
								else
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									//EEPROM_Buffer[30] = 6;
									EEPROM_Buffer[30] = (BYTE)(336-256);
									EEPROM_Buffer[31] = 2;                                  //虚拟行显示,倒计时处理
								}
							}
							break;
						case 4:
							if(DATA_ID != 0xff)
							{
								if(EEPROM_Buffer[142]==0)
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									EEPROM_Buffer[30] = (BYTE)(354-256);
									switch(EEPROM_Buffer[140])
									{
										case 0x00:
											//EEPROM_Buffer[30] = (BYTE)(440 - 256);             //刷新位置
											EEPROM_Buffer[31] = (BYTE)(476 - 256);             //刷新位置
											break;
										case 0x01:
											//EEPROM_Buffer[30] = 0; 
											EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
											break;
										case 0x02:												 //85°问题
											//EEPROM_Buffer[30] = 0; 
											EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
											break;       
										default:
											break;
									}
								}
								else
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									EEPROM_Buffer[30] = (BYTE)(354-256);
									//EEPROM_Buffer[30] = 6;
									EEPROM_Buffer[31] = 1;
								}
							}
							break;
						case 6:
							if((EXTRA_ID != 0xff)&&(DATA_ID==EXTRA_ID-1))
							{
								if(EEPROM_Buffer[142]==0)
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									EEPROM_Buffer[30] = 354;
									switch(EEPROM_Buffer[140])
									{
										case 0x00:
											//EEPROM_Buffer[30] = (BYTE)(440 - 256);             //刷新位置
											EEPROM_Buffer[31] = (BYTE)(422 - 256);             //刷新位置
											break;
										case 0x01:
											//EEPROM_Buffer[30] = 0; 
											EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
											break;
										case 0x02:												 //85°问题
											//EEPROM_Buffer[30] = 0; 
											EEPROM_Buffer[31] = 0;                              //虚拟行显示,从程序中写数据
											break;       
										default:
											break;
									}
								}
								else
								{
									EEPROM_Buffer[34] = 1;                                  //行0要求刷新
									EEPROM_Buffer[35] = 1;                                  //行1要求刷新
									EEPROM_Buffer[30] = (BYTE)(354-256);
									//EEPROM_Buffer[30] = 6;
									EEPROM_Buffer[31] = 1;
								}
							}	
							break;
						default:
							break;
					} 
					//特殊提示显示
					if(SChar_Time>0)
					{
						EEPROM_Buffer[SChar_Line+34] = 1;
						EEPROM_Buffer[SChar_Line+30] = SChar_Start;
						SChar_Time =SChar_Time -1; 
					}
				}
				//逐行扫描是否需要刷新，并显示刷新内容
				for(i=0;i<4;i++)
				{
					if(EEPROM_Buffer[i+34]==1)		     //需要刷新
					{
						j =  (WORD)EEPROM_Buffer[i+30] + 256;
						ShowLine((BYTE)i,j);
						EEPROM_Buffer[i+34] = 0;
					} 	
				}
			}
		

			
/*************************************采集标志清零************************************************/
		if(DATA_ID != 0xff)
		{
			EEPROM_Buffer[145] = 0;
			EEPROM_Buffer[146] = 0;
		}	
							   
		if(ADC_ID != 0xff)
		{
			if(ADC_ID != 0x08)		   //08类特殊
				EEPROM_Buffer[89] = 0;
			EEPROM_Buffer[90] = 0;
		}
		ding = 0;
		/*************************************定时器定时中断到来处理**************************************/
		if(Timer_Up0)	
		{
			Timer_Up0 = 0;
			ding = 1;                                     //一次计数
			
			if(Screen_Fresh_Count<Screen_Fresh){
				Screen_Fresh_Count++;
			}else{
				Screen_Fresh_Count = 0;	
				//分屏计数计算
				if(Screen_Num>0)
				{
					if(Screen_Count<Screen_Num-1)
					{
						Screen_Count = 	Screen_Count+1;
					}
					else
					{
						Screen_Count = 0;	
					}
					Screen_Fresh_flag = 1;
				}
			}
			
			if(ADC_ID != 0xff)
			{
				if(EEPROM_Buffer[86]>0)
				{
					EEPROM_Buffer[86] = EEPROM_Buffer[86] - 1;	
				}
				if(EEPROM_Buffer[86]==0)
				{
					
					//采集处理
					if(ADC_Count>0)
					{
						ADC_Count=ADC_Count-1;		   //倒计时
					}
					else
					{
						ADC_Count = EEPROM_Buffer[49];
						//判断采集是否进行
						if((EEPROM_Buffer[48]>0)&&(EEPROM_Buffer[48]<0xfc))
						{
							EEPROM_Buffer[89] = 1;	
						}	
					}
					//上传处理
					if(EEPROM_Buffer[88]>0)
					{
						EEPROM_Buffer[88] = EEPROM_Buffer[88]-1;		   //倒计时
					}
					else
					{
						EEPROM_Buffer[88] = EEPROM_Buffer[51];
						if((EEPROM_Buffer[50]&0x02)==0x02)
						{
							//if((EEPROM_Buffer[95]>0)&&(EEPROM_Buffer[95]<0xfc))
							{
								//EEPROM_Buffer[90] =1;
								//EEPROM_Buffer[95] = EEPROM_Buffer[95]-1;
							}//else if(EEPROM_Buffer[95]==0xfc)
							{
								EEPROM_Buffer[90] = 1;
							}	
						}		
					}		
				}
			}

			if(DATA_ID != 0xff)
			{
				if(EEPROM_Buffer[142]>0)
				{
					EEPROM_Buffer[142]=EEPROM_Buffer[142] - 1;	
				}
				if(EEPROM_Buffer[142]==0)
				{
					//采集处理
					if(DATA_Count>0)
					{
						DATA_Count = DATA_Count - 1;	
					}
					else
					{
						DATA_Count = EEPROM_Buffer[105];
						//判断采集是否进行
						if((EEPROM_Buffer[104]>0)&&(EEPROM_Buffer[104]<0xfc))
						{
							EEPROM_Buffer[145] = 1;	
						}		
					}
					
					//上传处理
					if(EEPROM_Buffer[144]>0)
					{
						EEPROM_Buffer[144] = EEPROM_Buffer[144] - 1;	
					}
					else
					{
						EEPROM_Buffer[144] = EEPROM_Buffer[107];
						//取消判断上传是否进行
						if((EEPROM_Buffer[106]&0x02)==0x02)
						{
							//if((EEPROM_Buffer[151]>0)&&(EEPROM_Buffer[151]<0xfc))
							//{
								EEPROM_Buffer[146] = 1;
								//EEPROM_Buffer[151] = EEPROM_Buffer[151]-1;
							//}else if(EEPROM_Buffer[151]==0xfc)
							//{
								//EEPROM_Buffer[146] = 1;
							//}	
						}	
					}		
				}
			}
			if((EXTRA_ID != 0xff)&&(EXTRA_ID == DATA_ID+1))
			{
				
				
			}

		}
/*************************************数据接收处理**************************************/
		if(recv1){
			 Delayms(20);
			 if(SChar_Time == 0){
					SChar_Line = 0;                               
					SChar_Start = (BYTE)(257-256);
					SChar_Time = 4;   
					ShowLine(0,257);
			}
			ClearBuff1();
		}
		if(recv2)
		{
			Delayms(20);
			//ClearPro_Buffer();
			num = Get_Buff2(pro.Pro_Buff);
			k = Parse(Src_Addr[0],Src_Addr[1],num);
			if(k == 11){
				//0数据回复
				num = 0;
				if(SChar_Time == 0){
					SChar_Line = 0;                               
					SChar_Start = (BYTE)(275-256);
					SChar_Time = 4;   
					ShowLine(0,275);
				}
			}
			else if(k == 0)
			{
				num = 0;
				k = p->Command;
				//解析数据并做适当处理
				switch(k&0x3f)
				{
					//与远程设备连接
					case 0x01:
						p->Command = 0x02;
						p->Payload_Num	= 0;
						num = p->Payload_Num+9;
						Remote_Addr[0] = p->Src_Addr[0];
						Remote_Addr[1] = p->Src_Addr[1];
						SChar_Line = 0;                               
						SChar_Start = (BYTE)(274-256);
					    SChar_Time = 10;   
						ShowLine(0,274);
						break;
					case 0x02:
						Remote_Addr[0] = p->Src_Addr[0];
						Remote_Addr[1] = p->Src_Addr[1];
						SChar_Line = 0;                               
						SChar_Start = (BYTE)(274-256);
					    SChar_Time = 10; 
						ShowLine(0,274);
						break;
					//与远程设备解除连接
					case 0x03:
						p->Command = 0x04;
						p->Payload_Num	= 0;
						num = p->Payload_Num+9;
						break;
					//获取设备版本及外设设置
					case 0x05:
						p->Command = 0x06;
						p->Payload_Num	= 8;
						for(i=0;i<8;i++)
						{
							p->Payload[i] = EEPROM_Buffer[i];	
						}
						num = p->Payload_Num+9;
						break;
					//任意位置EEPROM写30个字节,非用户指令
					case 0x07:
						p->Payload[0] = Command_07();
						switch(p->Payload[0])
						{
							case 0:									//锁传感器
								//LCD_ID = 0xff;
								ADC_ID = 0xff;
								DATA_ID = 0xff;
								EXTRA_ID = 0xff;
							    EEPROM_Buffer[296] = 0;        //关闭心跳
								break;
							case 4:
								break;
							case 5:
								break;
							default:
								break;
						}
						if(k&0x80)
						{
							p->Command = 0x08;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//设置采集资源参数
					case 0x09:
						p->Payload[0] = Command_09();
						switch(p->Payload[0])
						{
							case 0:
								if(k&0x40)										 //需要保存，重启提示
								{
									IapEraseSector(0);                            //先擦后写
									WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
									SChar_Line = 0;                               //提示重启
									SChar_Start = 4;
									SChar_Time = 5;                               //驻屏5S	
								}
								ADC_ID = 0xff;
								DATA_ID = 0xff;
								EXTRA_ID = 0xff;
								EEPROM_Buffer[296] = 0;                          //关闭心跳
								break;
							case 5:
								break;
							case 6:
								//提示没有匹配的设置
								SChar_Line = 0;                               
								SChar_Start = 5;
								SChar_Time = 5;                                  //驻屏5S
								break;
							default:
								break;
						}
						
						if(k&0x80)
						{
							p->Command = 0x0a;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//恢复出厂设置
					case 0x0D:
						if(k&0x80)
						{
							p->Command = 0x0E;
							p->Payload_Num	= 1;
							p->Payload[0] = 0;                        //状态码
							num = p->Payload_Num+9;
						}
						GetSector(1,EEPROM_Buffer);                   //EEPROM读取
						Delayms(2);
						IapEraseSector(0);                            //先擦后写
						WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
						ADC_ID = 0xff;
						DATA_ID = 0xff;
						EXTRA_ID = 0xff;
						EEPROM_Buffer[296] = 0;                       //关闭心跳
						SChar_Line = 0;                               //提示恢复出厂设置
						SChar_Start = 3;
						SChar_Time = 5;                               //驻屏5S
						break;
					//获取采集资源参数
					case 0x0F:
						p->Payload[0] = Command_0F();
						p->Command = 0x10;
						switch(p->Payload[0])
						{
							case 0:
								//读取成功
								p->Payload_Num	= 30;
								num = p->Payload_Num+9;
								break;
							case 5:
								p->Payload_Num	= 1;
								num = p->Payload_Num+9;
								break;
							case 6:
								//提示没有匹配的设置
								SChar_Line = 0;                               
								SChar_Start = 5;
								SChar_Time = 5;                                  //驻屏5S
								p->Payload_Num	= 1;
								num = p->Payload_Num+9;
								break;
							default:
								p->Payload_Num	= 1;
								break;
						}
						break;
					//将现有状态存入EEPROM	  
					case 0x11:
						p->Payload[0] = Command_11();
						switch(p->Payload[0])
						{
							case 0:
								ADC_ID = 0xff;
								DATA_ID = 0xff;
								EXTRA_ID = 0xff;
								EEPROM_Buffer[296] = 0;                       //关闭心跳
								SChar_Line = 0;                               //提示重启
								SChar_Start = 3;
								SChar_Time = 5;                               //驻屏5S
								break;
							case 5:
								break;
							default:
								break;
						}
						if(k&0x80)
						{
							p->Command = 0x12;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;	
					//参数修改及配置
					case 0x13:
						p->Payload[0] = Command_13();
					    switch(p->Payload[0])
						{
							case 0:
								if(k&0x40)
								{
									IapEraseSector(0);                            //先擦后写
									WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
								}
								break;
							case 5:
								break;
							case 6:
								//提示没有匹配的设置
								SChar_Line = 0;                               
								SChar_Start = 5;
								SChar_Time = 5;                                  //驻屏5S
								break;
							default:
								break;
						}
						if(k&0x80)
						{
							p->Command = 0x14;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//关闭传感器
					case 0x15:
						p->Payload[0] = Command_15();
					    switch(p->Payload[0])
						{
							case 0:
								if(k&0x40)
								{
									IapEraseSector(0);                            //先擦后写
									WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
									SChar_Line = 0;                               //提示重启
									SChar_Start = 4;
									SChar_Time = 5;                               //驻屏5S	
								}
								ADC_ID = 0xff;
								DATA_ID = 0xff;
								EXTRA_ID = 0xff;
								EEPROM_Buffer[296] = 0;                          //关闭心跳
								break;
							case 5:
								break;
							default:
								break;
						}
						if(k&0x80)
						{
							p->Command = 0x16;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}  
						break;
					//显示设置,非用户指令
					case 0x17:
						p->Payload[0] = Command_17();
						switch(p->Payload[0])
						{
							case 0:
								if(k&0x40)
								{
									IapEraseSector(0);                            //先擦后写
									WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
									SChar_Line = 0;                               //提示重启
									SChar_Start = 3;
									SChar_Time = 5;                               //驻屏5S
								}
								ADC_ID = 0xff;
								DATA_ID = 0xff;
								EXTRA_ID = 0xff;
								EEPROM_Buffer[296] = 0;                      //关闭心跳
								break;
							case 5:
								break;
							case 6:
								//提示没有匹配的设置
								SChar_Line = 0;                               
								SChar_Start = 5;
								SChar_Time = 5;                                  //驻屏5S
								break;
							default:
								break;
						}
						if(k&0x80)
						{
							p->Command = 0x18;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//心跳设置,非用户指令
					case 0x19:
						p->Payload[0] = Command_19();
						if(k&0x40)
						{
							IapEraseSector(0);                            //先擦后写
							WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
						}
						if(k&0x80)
						{
							p->Command = 0x1A;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//STA家庭路由器设置
					case 0x1b:
						p->Payload[0] = Command_1b();
						if(p->Payload[0] == 0)
						{
							EEPROM_Buffer[160] = 0;
							if(k&0x40)
							{
								IapEraseSector(0);                            //先擦后写
								WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
							}
						}
						if(k&0x80)
						{
							p->Command = 0x1c;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					//服务器IP和端口设置
					case 0x1d:
						p->Payload[0] = Command_1d();
						if(p->Payload[0] == 0)
						{
							EEPROM_Buffer[160] = 0;
							if(k&0x40)
							{
								IapEraseSector(0);                            //先擦后写
								WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
							}
						}
						if(k&0x80)
						{
							p->Command = 0x1e;
							p->Payload_Num	= 1;
							num = p->Payload_Num+9;
						}
						break;
					case 0x1f:
						p->Payload[0] = Command_1f();
						p->Command = 0x20;
						if(p->Payload[0] == 0)
						{
							p->Payload_Num	= 20;
						}
						else
						{
							p->Payload_Num	= 1;
						}
						num = p->Payload_Num+9;
						break;
					case 0x2f:
						Server_Flag = 1;
						EEPROM_Buffer[278] = 0;            //建立连接
						if(EEPROM_Buffer[1]==0x13)
						{
							//EEPROM_Buffer[318] = 0x5b;
							//EEPROM_Buffer[319] = 0x5d;
							//EEPROM_Buffer[336] = 0x5b;
							//EEPROM_Buffer[337] = 0x5d;
							//EEPROM_Buffer[354] = 0x5b;
							//EEPROM_Buffer[355] = 0x5d;
						}
						else if(EEPROM_Buffer[1]==0x14)
						{
							//EEPROM_Buffer[318] = 0x01;
							//EEPROM_Buffer[319] = 0x5d;
							//EEPROM_Buffer[336] = 0x01;
							//EEPROM_Buffer[337] = 0x5d;
							//EEPROM_Buffer[354] = 0x01;
						//	EEPROM_Buffer[355] = 0x5d;
						}
						break;
					default:
						break;	
				}
				if(num>0)
				{
					//头处理
				 	p->Mark_Head[0] = 0xa5;
				 	p->Mark_Head[1] = 0x5a;
					p->Des_Addr[0] = p->Src_Addr[0];
					p->Des_Addr[1] = p->Src_Addr[1];
					p->Src_Addr[0] = Src_Addr[0];
				 	p->Src_Addr[1] = Src_Addr[1];
					p->Seq_Num = Seq_Number;
		 			Seq_Number++;
					if(Send_Pri2<=3)
					{
						for(i=0;i<p->Payload_Num+9;i++)
					 	{
					 		Send_Buff2[i] = pro.Pro_Buff[i]; 
					 	}
					 	Send_Num2 = p->Payload_Num +9;
						Send_Pri2 = 3;
					}
				}
			}else{
				//回复数据的格式错误或未知的回复数据
				SChar_Line = 0;                               
				SChar_Start = (BYTE)(272-256);
				SChar_Time = 10;   
				ShowLine(0,273);
			}
		}	//if(recv2)
	}
}
//===========采集类参数初始化==================
void ADC_P_Init()
{
	//初始化时间缓存
    if(EEPROM_Buffer[83]>EEPROM_Buffer[5])
	{
		EEPROM_Buffer[86] = EEPROM_Buffer[83] - EEPROM_Buffer[5];	
	}
	else
	{
		EEPROM_Buffer[86] = 0;	
	}
	EEPROM_Buffer[84] = 0;					 //初始认为无故障
	ADC_Count = EEPROM_Buffer[87];			 //初始采集时间计数手动在EEPROM中控制
	EEPROM_Buffer[88] = 0;					 //初始上传时间计数为0
	EEPROM_Buffer[89] = 0;	                 //初始采集状态不采集
    EEPROM_Buffer[90] = 0;					 //初始上传状态不上传
	EEPROM_Buffer[95] = 0;					 //初始上传状态不上传
	EEPROM_Buffer[53] = 0;					 //初始报警状态不报警
	ADC_100 = ((WORD)EEPROM_Buffer[96]<<8)+(WORD)EEPROM_Buffer[97];
	ADC_0 = ((WORD)EEPROM_Buffer[98]<<8)+(WORD)EEPROM_Buffer[99];
}

void DATA_P_Init()
{
	//初始化时间缓存
    if(EEPROM_Buffer[139]>EEPROM_Buffer[5])
	{
		EEPROM_Buffer[142] = EEPROM_Buffer[139] - EEPROM_Buffer[5];	
	}
	else
	{
		EEPROM_Buffer[142] = 0;	
	}
	EEPROM_Buffer[140] = 0;					 //初始认为无故障
	DATA_Count = EEPROM_Buffer[143];		 //初始采集时间计数手动在EEPROM中控制
	EEPROM_Buffer[144] = 0;					 //初始上传时间计数为0
	EEPROM_Buffer[145] = 0;	                 //初始采集状态不采集
    EEPROM_Buffer[146] = 0;					 //初始上传状态不上传
	//EEPROM_Buffer[151] = 0;				     //初始上传状态不上传
	EEPROM_Buffer[109] = 0;					 //初始报警状态不报警
	DATA_100 = ((WORD)EEPROM_Buffer[152]<<8)+(WORD)EEPROM_Buffer[153];
	DATA_0 = ((WORD)EEPROM_Buffer[154]<<8)+(WORD)EEPROM_Buffer[155];
}

void EXTRA_P_Init()
{
	EEPROM_Buffer[411] = 0;					 //初始报警状态不报警	
}
//===========定时器+串口处理===================
void Timer_Uart_Init()
{
	busy1 = 0;
	busy2 = 0;
	recv1 = 0;
	recv2 = 0;
	Recv_Num1 = 0;
	Recv_Num2 = 0;

	AUXR = 0x14;//0x94;                                     //0x94 Timer0不分频，Timer1 12分频
	SCON = 0xda;									                 //9位UART 波特率可变 
	S2CON = 0xda; 									                 //UART2 9位UART 波特率可变 
	TMOD = 0x21;                                     //Set Timer1 as 8-bit auto reload mode,set timer0 as mode1 (16-bit)
	//Set auto-reload vaule  UART2 Set auto-reload vaule of baudrate generator
	if(EEPROM_Buffer[16] == 1)
	{
  	TH1 = TL1 = -(FOSC/12/32/BAUD0);              
		BRT = -(FOSC/32/BAUD0);                       
	}else if(EEPROM_Buffer[16] == 0)
	{
		TH1 = TL1 = -(FOSC/12/32/BAUD1);              
		BRT = -(FOSC/32/BAUD1); 
	}
	TL0 = T1MS;                                      //initial timer0 low byte
  TH0 = T1MS >> 8;                                 //initial timer0 high byte	
  TR1 = 1;     									                //Timer1 start run
	ES = 1;                                       //Enable UART interrupt
  IE2 = 0x01;                                     //Enable UART2 interrupt
  EA = 1;      									                 //Open master interrupt switch
}

//定时器0部分
void Start_Timer0(WORD count,bit Mode)
{
	//EA = 0;
	Timer_Count0 = count;
	if(Mode)								         //循环模式
	{
		TimerNum0 = count;
	}
	else											 //1次性模式
	{
		TimerNum0 = 0;
	}
	TR0 = 1;                                         //timer0 start running
	ET0 = 1;                                         //enable timer0 interrupt 
	//EA = 1; 
}

/*
void Stop_Timer0()
{
	EA = 0;
    TR0 = 0;                                         //timer0 start running
	ET0 = 0;                                         //enable timer0 interrupt 
	EA = 1; 
}
*/

//External interrupt0 service routine
void exint0() interrupt 0           //(location at 0003H)
{
	//P25 = 0;	
	fire_sign=1;	
}

void tm0_isr() interrupt 1 using 0
{
EA = 0;
    TL0 = T1MS;                                     //reload timer0 low byte
    TH0 = T1MS >> 8;                                //reload timer0 high byte
    if (Timer_Count0-- == 0)                         //1ms * 1000 -> 1s
    {
        Timer_Count0 = TimerNum0;                     //reset counter
				Timer_Up0 = 1;
    }
EA =1;
}

//串口2部分
void Uart2() interrupt 8 using 2
{
EA =0;
    if (S2CON & S2RI)
    {
        S2CON &= ~S2RI;     //Clear receive interrupt flag
		if(Recv_Num2 == MaxRecvBuff2)
		{
			Recv_Num2 = 0;
		} 
		Recv_Buff2[Recv_Num2++] = S2BUF;
  	    recv2 = 1;
    }
    if (S2CON & S2TI)
    {
        S2CON &= ~S2TI;     //Clear transmit interrupt flag
        busy2 = 0;           //Clear transmit busy flag
    }
EA =1;
}

void SendData2(BYTE dat)
{
    while (busy2);           //Wait for the completion of the previous data is sent
    ACC = dat;              //Calculate the even parity bit P (PSW.0)
    if (P)                  //Set the parity bit according to P
    {
        S2CON |= S2TB8;     //Set parity bit to 1
    }
    else
    {
        S2CON &= ~S2TB8;    //Set parity bit to 0
    }
    busy2 = 1;
    S2BUF = ACC;            //Send data to UART2 buffer
}

void SendString2(char *s)
{
    while (*s)              //Check the end of the string
    {
        SendData2(*s++);     //Send current char and increment string ptr
    }
}

BYTE Get_Buff2(BYTE * Buffer)
{
	BYTE i,num;
	IE2 = 0x00;
	if(recv2)
	{
		for(i=0;i<Recv_Num2;i++)
		{
			Buffer[i] = Recv_Buff2[i];
		}
		num = Recv_Num2;
	}
	else
	{
		num = 0;
	}
	recv2 = 0;
	Recv_Num2 = 0;
	IE2 = 0x01;
	return num;
}

void ClearBuff2()
{
	IE2 = 0x00;
	recv2 = 0;
	Recv_Num2 = 0;
	IE2 = 0x01;
}

/*----------------------------
串口1部分
----------------------------*/
void Uart_Isr() interrupt 4 using 1
{
    if (RI)
    {
        RI = 0;             //Clear receive interrupt flag
        
		if(Recv_Num1 == MaxRecvBuff1)
		{
			Recv_Num1 = 0;
		} 
		Recv_Buff1[Recv_Num1++] = SBUF;
  	    recv1 = 1;
    }
    if (TI)
    {
        TI = 0;             //Clear transmit interrupt flag
        busy1 = 0;           //Clear transmit busy flag
    }
}

/*----------------------------
Send a byte data to UART
Input: dat (data to be sent)
Output:None
----------------------------*/
void SendData1(BYTE dat)
{
    while (busy1);           //Wait for the completion of the previous data is sent
    ACC = dat;              //Calculate the even parity bit P (PSW.0)
    if (P)                  //Set the parity bit according to P
    {
#if (PARITYBIT == ODD_PARITY)
        TB8 = 0;            //Set parity bit to 0
#elif (PARITYBIT == EVEN_PARITY)
        TB8 = 1;            //Set parity bit to 1
#endif
    }
    else
    {
#if (PARITYBIT == ODD_PARITY)
        TB8 = 1;            //Set parity bit to 1
#elif (PARITYBIT == EVEN_PARITY)
        TB8 = 0;            //Set parity bit to 0
#endif
    }
    busy1 = 1;
    SBUF = ACC;             //Send data to UART buffer
}

/*----------------------------
Send a string to UART
Input: s (address of string)
Output:None
----------------------------*/
void SendString1(char *s)
{
    while (*s)              //Check the end of the string
    {
        SendData1(*s++);     //Send current char and increment string ptr
    }
}

BYTE Get_Buff1(BYTE * Buffer)
{
	BYTE i,num;
	ES = 0;
	if(recv1)
	{
		for(i=0;i<Recv_Num1;i++)
		{
			Buffer[i] = Recv_Buff1[i];
		}
		num = Recv_Num1;
	}
	else
	{
		num = 0;
	}
	recv1 = 0;
	Recv_Num1 = 0;
	ES = 1;
	return num;
}

void ClearBuff1()
{
	ES = 0;
	recv1 = 0;
	Recv_Num1 = 0;
	ES = 1;
}

//==============WORD与字符串转换==========0：保存在str_i中  1：保存在str_d中
void WordToStr(unsigned int integer,BYTE num)
{
	unsigned long temp,temp1;
	unsigned char i;
	//截取相应的位数
	temp = integer;
	EA = 0;
	for(i=5;i>0;i--)
	{
		temp1 = temp%10;
		if(num==0)
		{
			if((temp1>=0x00)&&(temp1<=0x09))
				str_i[i-1] = temp1+0x30;
			else
				str_i[i-1] = 0x30;	
		}
		else if(num==1)
		{
			if((temp1>=0x00)&&(temp1<=0x09))
				str_d[i-1] = temp1+0x30;
			else
				str_d[i-1] = 0x30;	
		}
		temp = temp - temp1;
		temp = temp/10;
	}
	EA = 1;
}

//================wifi=======================
//进入命令模式
void Wifi_CMode()
{
	SendString2("+++");
	Delayms(Recv_DelayTime2);
	SendData2('a');
	Delayms(Recv_DelayTime2);
	SendString2("AT+E=off");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
}

//返回透传模式
void Wifi_TMode()
{
	SendString2("AT+ENTM");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	ClearBuff2();
}

//httpd模式
void Wifi_HTTPD_GET()
{
	BYTE i,j;
	BYTE flag = 0;
	/**/
    SendString2("AT+HTPTP=POST");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	//公网：219.147.163.225,9090 
	//内网：192.168.9.81,90  
	//192.168.0.10,82  
	//129.168.13.180,80	 
	SendString2("AT+HTPSV=192.168.9.81,90");
	/*for(i=0;i<4;i++){
		flag = 0;
		for(j=0;j<3;j++){
			if((EEPROM_Buffer[279+i*3+j]!=0x30)||j==2){
				flag = 1;
			}
			if(flag == 1){
				SendData2(EEPROM_Buffer[279+i*3+j]);
			}
		}
		if(i<3){
			SendData2('.');
		}
	}
	SendData2(',');
	flag = 0;
	for(i=0;i<5;i++){
		if((EEPROM_Buffer[291+i]!=0x30)||i==4){
				flag = 1;
			}
			if(flag == 1){
				SendData2(EEPROM_Buffer[291+i]);
			}
	}*/	
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+HTPURL=/indexs.php");
	SendData2(0x0d);		  
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+HTPTO=10");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
		/**/
	SendString2("AT+HTPHD=Accept:text/html[0D][0A]Accept-Language:en[0D][0A]User-Agent:Mozilla/5.0[0D][0A]Connection:Keep-Alive[0D][0A]");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+HTPFT=ON");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);

	/*
	SendString2("AT+TMODE");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	if(recv2)
	{
		ShowLine(0,273);
	}*/
	//Delayms(2000);
	SendString2("AT+TMODE=htpc");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
}

//检测服务器是否连接
/*
     0         已连接
	 1         断开
	 2         没有检查到数据
	 3         数据长度不对
	 4-7       数据无意义
	 0x31      无效命令格式
	 0x32      无效命令
	 0x33      无效的操作符
	 0x34      无效的参数
	 0x35      操作不允许 
*/
/*
BYTE GetSockBStatus()
{
	BYTE status;
	ClearBuff2();
	SendString2("AT+TCPLKB");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	if(recv2)
	{
		if(Recv_Buff2[0] == '+')
		{
			if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
			{
				switch(Recv_Buff2[5])
				{
					case 0x6e:
						status = 0;
						break;
					case 0x66:
						status = 1;
						break;
					default:
					    status = 4;
						break;
				}
			}
			else if((Recv_Buff2[1] == 'E')&&(Recv_Buff2[2] == 'R'))
			{
				switch(Recv_Buff2[6])
				{
					case 0x31:
					case 0x32:
					case 0x33:
					case 0x34:
					case 0x35:
						status = Recv_Buff2[6];
						break;
					default:
						status = 5;
						break;
				}
			}else
			{
				status = 6;	
			}
			
		}else
		{
			status = 7;
		}
	}
	else
	{
		status = 2;
	}
	//ClearBuff2();
	return status;
}
*/
//获取工作模式
/*
	 1         AP
	 2         STA
	 3         错误
	 4		   APSTA
*/
BYTE Get_Mode()
{
	BYTE status;
	ClearBuff2();
	SendString2("AT+WMODE");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	if(recv2)
	{
		if(Recv_Buff2[0] == '+')
		{
			if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
			{
				if((Recv_Buff2[4] == 'A')&&(Recv_Buff2[5] == 'P')){
					if(Recv_Buff2[6] == 'S')
						status = 4;
					else
						status = 1;	  
					return status;
				}					
				else if((Recv_Buff2[4] == 'S')&&(Recv_Buff2[5] == 'T')){
					status = 2;
					return status;
				}
			}
			
		}
	}
	status = 3;
	//ClearBuff2();
	return status;
}

/*
	 0         连接成功
	 1         无连接
	 2         RF被关闭
	 3         错误
*/
BYTE Get_WSLK()
{
	BYTE status;
	ClearBuff2();
	SendString2("AT+WSLK");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	if(recv2)
	{
		if(Recv_Buff2[0] == '+')
		{
			if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
			{
				if((Recv_Buff2[4] == 'D')&&(Recv_Buff2[5] == 'I')&&(Recv_Buff2[6] == 'S')){
					status = 1;
					return status;
				}					
				else if((Recv_Buff2[4] == 'R')&&(Recv_Buff2[5] == 'F')&&(Recv_Buff2[6] == ' ')){
					status = 2;
					return status;
				}else{
					status = 0;
					ShowLine(0,273);
					return status;
				}
			}			
		}
	}
	status = 3;
	//ClearBuff2();
	return status;
}

/*
	 0         ping成功
	 1         超时
	 2         找不到主机
	 3         错误
*/
BYTE PING_IP_ADDR(){
	BYTE status;
	BYTE flag =0;
	BYTE i;
	BYTE j;
	ClearBuff2();
	SendString2("AT+PING=");
	for(i=0;i<4;i++){
		flag = 0;
		for(j=0;j<3;j++){
			if((EEPROM_Buffer[279+i*4+j]!=0x30)||j==2){
				flag = 1;
			}
			if(flag == 1){
				SendData2(EEPROM_Buffer[279+i*4+j]);
			}
		}
		if(i<3){
			SendData2('.');
		}
	}									 
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	Delayms(5000);
	if(recv2)
	{
		if(Recv_Buff2[0] == '+')
		{
			if((Recv_Buff2[1] == 'o')&&(Recv_Buff2[2] == 'k'))
			{
				if((Recv_Buff2[4] == 'S')&&(Recv_Buff2[5] == 'u')&&(Recv_Buff2[6] == 'c')){
					status = 0;
					return status;
				}					
				else if((Recv_Buff2[4] == 'T')&&(Recv_Buff2[5] == 'i')&&(Recv_Buff2[6] == 'm')){
					status = 1;
					return status;
				}else if((Recv_Buff2[4] == 'U')&&(Recv_Buff2[5] == 'n')&&(Recv_Buff2[6] == 'k')){
					status = 2;
					return status;
				}
			}
			
		}
	}
	status = 3;
	//ClearBuff2();
	return status;
}

void Wifi_MDCH(){
	SendString2("AT+MDCH=ON");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);	
}

//重启
void Wifi_ReStart()
{
	SendString2("AT+Z");
	SendData2(0x0d);
}

//重启2
void Wifi_ReStart2()
{
	wifi_reset = 0;
	Delayms(600);
	wifi_reset = 1;	
}

//AP配置
void Wifi_AP()
{
	BYTE i;
	
	SendString2("AT+WAP=11BGN,");
	for(i=164;i<=167;i++)
	{
		SendData2(EEPROM_Buffer[i]);
	}
	for(i=0;i<5;i++)
	{
		SendData2(str_i[i]);
	}
	SendString2(",CH1");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+WAKEY=WPA2PSK,AES,");
	for(i=168;i<=175;i++)
	{
		SendData2(EEPROM_Buffer[i]);
	}
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	ClearBuff2();
	SendString2("AT+WMODE=AP");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	//ShowLine(1,273);
}

void Wifi_STA()
{
	BYTE i;
	ClearBuff2();
	/*
	SendString2("AT+WSSSID=");
	for(i=0;i<EEPROM_Buffer[208];i++)
	{
		SendData2(EEPROM_Buffer[i+209]);
	} 
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+WSKEY=WPA2PSK,AES,");
	for(i=0;i<EEPROM_Buffer[224];i++)
	{
		SendData2(EEPROM_Buffer[i+225]);
	}
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	*/
	SendString2("AT+WMODE=STA");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	ClearBuff2();
}

//apsta配置
void Wifi_APSTA()
{
	BYTE i;
	/*
	SendString2("AT+WAP=11BGN,");
	for(i=164;i<=167;i++)
	{
		SendData2(EEPROM_Buffer[i]);
	}
	for(i=0;i<5;i++)
	{
		SendData2(str_i[i]);
	}
	SendString2(",CH1");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+WAKEY=WPA2PSK,AES,");
	for(i=168;i<=175;i++)
	{
		SendData2(EEPROM_Buffer[i]);
	}
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
    //STA设置
	SendString2("AT+WSSSID=");
	for(i=0;i<EEPROM_Buffer[208];i++)
	{
		SendData2(EEPROM_Buffer[i+209]);
	} 
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+WSKEY=WPA2PSK,AES,");
	for(i=0;i<EEPROM_Buffer[224];i++)
	{
		SendData2(EEPROM_Buffer[i+225]);
	}
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+SOCKB=TCP,");
	for(i=0;i<EEPROM_Buffer[251];i++)
	{
		SendData2(EEPROM_Buffer[i+252]);
	}
	SendData2(',');
	for(i=0;i<EEPROM_Buffer[257];i++)
	{
		SendData2(EEPROM_Buffer[i+258]);
	}
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
	SendString2("AT+TCPTOB=0");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);  */
	SendString2("AT+WMODE=APSTA");
	SendData2(0x0d);
	Delayms(Recv_DelayTime2);
	Delayms(Recv_DelayTime2);
}

BYTE Wifi_STATUS()
{
	BYTE mode_status;
	BYTE wifi_status;
	BYTE status;
	//先检查工作模式
	mode_status = Get_Mode();
	switch(mode_status){
		//STA模式  需要检查连接是否正常
		case 2:
			//检查wifi连接
			wifi_status = Get_WSLK();
			switch(wifi_status){
				case 0:
					//wifi连接正常 检查服务器连接(ping)
					ShowLine(0,266);
					Wifi_HTTPD_GET();
					Wifi_ReStart();
    				ClearBuff2();
					status =20;
					break;
				case 1:
					//转到ap模式
					//Wifi_AP();
					//Wifi_ReStart();
    				//ClearBuff2();
					//ShowLine(0,269);
					ShowLine(0,265);
					status =21;
					break;
				case 2:
					ShowLine(0,269);
					status=22;
					break;
				case 3:
					ShowLine(0,272);
					status=23;
					break;
			}
			break;
		//AP模式  需要转换成STA模式
		case 1:
			status = 10;
			ShowLine(0,265);
			break;
		//APSTA模式 表示设备正在不断重新连接wifi
		case 4:
			status =40;
			ShowLine(0,267);
			break;
		//发生错误
		case 3:
			status =3;
			ShowLine(0,273);
			break;
		default:
			break;
	}
	return status;

}

//==================LCD处理================
void Screen_refresh()
{
	Screen_Num = 0;
	if(LCD_ID != 0xff)
	{
		if(DATA_ID != 0xff)
		{
			Screen_Array[Screen_Num] = 4;//DATA_ID;
			Screen_Num++;
		}
		if(ADC_ID != 0xff)
		{
			Screen_Array[Screen_Num] = 3;//ADC_ID;
			Screen_Num++;
		}
		if(EXTRA_ID != 0xff)
		{
			Screen_Array[Screen_Num] = 6;//EXTRA_ID;
			Screen_Num++;
		}
	}
	Screen_Count = 0;
	Screen_Fresh_Count = 0;
	Screen_Fresh_flag = 0;
}
/*********************************
line:行数，从0开始 440 458为显示缓存
start：要显示的字符在EEPROM的开始位置
虚拟行说明：
	行号                       意义
	 0（256）                  故障说明
	 1（257）                  数据类初始化倒计时说明
	 2（258）                  ADC类初始化倒计时说明
	 3（259）                  重新启动说明  
	 4 (260)                   设置成功说明 
	 5 (261)                   不具备匹配的功能 																  
	 6 (262)          		   全行空白
	 7 (263)				   服务器连接成功
	 8 (264)			       服务器连接失败
	 7 (265)       			   等待用户设置wifi名字和密码
	 8 (266)                   wifi连接配置成功
	 9 (267)                   wifi连接重试中
	 10(268)                   以默认参数连接wifi
	 11(269)                   wifi连接失败
	 12(270)                   服务器主机错误
	 13(271)                   服务器侦测超时
	 14(272)                   回复错误
	 15(273)                   测试接收数据
	 16(274)                   握手信息
	 17(275)                   回复数据
*********************************/
void ShowLine(BYTE line,WORD start)
{
	BYTE i;
	WORD j;
	Pro_0_0* p;
	bit sign;
	BYTE replace[8];
	BYTE replace_count=0;
	WORD temp;
	p = &(pro.Pro_Struct);
	if(line ==0)
	{
		j = 440;
	}
	if(line == 1)
	{
		j = 458;
	}
	sign = 0;		               //不需要更新	 
	//检查下数据是否需要更新
    if((start>=256)&&(start<287))				 
	{
	    switch(start){
			case 257:
				temp = (WORD)EEPROM_Buffer[142];
				WordToStr(temp,0);
				replace[0] = Recv_Buff1[0];
				replace[1] = Recv_Buff1[1];
				replace[2] = 0x20;
				break;
			case 258:
				temp = (WORD)EEPROM_Buffer[86];
				WordToStr(temp,0);
				replace[0] = str_i[2];
				replace[1] = str_i[3];
				replace[2] = str_i[4];
				break;
			case 273:
				replace[0] = Recv_Buff2[0];//EEPROM_Buffer[160]+0x30;//
				replace[1] = Recv_Buff2[1];//EEPROM_Buffer[161]+0x30;//
				replace[2] = Recv_Buff2[2];//0x20;//
				replace[3] = Recv_Buff2[3];//0x20;//
				replace[4] = Recv_Buff2[4];//EEPROM_Buffer[160]+0x30;//
				replace[5] = Recv_Buff2[5];//EEPROM_Buffer[161]+0x30;//
				replace[6] = Recv_Buff2[6];//0x20;//
				replace[7] = Recv_Buff2[7];//0x20;//
				break;
			case 274:
				temp = ((WORD)Remote_Addr[0]<<8)+(WORD)Remote_Addr[1];
				WordToStr(temp,0);
				replace[0] = str_i[0];
				replace[1] = str_i[1];
				replace[2] = str_i[2];
				replace[3] = str_i[3];
				replace[4] = str_i[4];
				break;
		}
		if(EEPROM_Buffer[1] == 0x14){
			for(i=0;i<18;i++)
			{
				if(EEPROM_Buffer[j+i] != INFO_14432[start-256][i])
				{
					if(INFO_14432[start-256][i]!=0x00)
						EEPROM_Buffer[j+i] = INFO_14432[start-256][i];
					else{
						EEPROM_Buffer[j+i] = replace[replace_count];
						replace_count++;
					}
						
					sign = 1;
				}
			}
		}else if(EEPROM_Buffer[1] == 0x13)
		{
			for(i=0;i<16;i++)
			{
				if(EEPROM_Buffer[j+i] != INFO_1620[start-256][i])
				{
					if(INFO_1620[start-256][i]!=0x00)
						EEPROM_Buffer[j+i] = INFO_1620[start-256][i];
					else{
						EEPROM_Buffer[j+i] = replace[replace_count];
						replace_count++;
					}
					sign = 1;
				}
			}
		}
				
	}
	else
	{
		for(i=0;i<EEPROM_Buffer[25];i++)
		{
			if(EEPROM_Buffer[j+i]!=EEPROM_Buffer[start+i])
			{
				EEPROM_Buffer[j+i] = EEPROM_Buffer[start+i];
				sign = 1;
			}	
		}
	}
    if(sign)
	{
		LcdWriteCmd(EEPROM_Buffer[line+26]);
		for(i=0;i<EEPROM_Buffer[25];i++)
		{
			LcdWriteDat(EEPROM_Buffer[j+i]);	
		}
		if(start>256)
		{
			EEPROM_Buffer[line+30] = start - 256;
		}
		else
		{
			EEPROM_Buffer[line+30] = 0;	
		}
	}
}


//==================协议解析================
//a5 5a 
void ClearPro_Buffer(){
	BYTE i;
	for(i=0;i<MaxRecvBuff2;i++){
		pro.Pro_Buff[0] = 0x00;	
	}
}

BYTE Parse(BYTE HAddr,BYTE LAddr,BYTE num)
{
	BYTE i;
	BYTE temp;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	//http1.1协议空回复
	if(pro.Pro_Buff[0] == 0x30){
		return 11;
	}
	//http1.1协议有数据回复
	if((pro.Pro_Buff[0]>0x30)&&(pro.Pro_Buff[0]<=0x39)){
		//将数据整理成raw data
		temp = num;
		for(i=0;i<num;i++){
			if(pro.Pro_Buff[i]==0xa5){
				temp = i;
			}
		}
		if(temp == num){
			return 12;
		}else{
			for(i=temp;i<num;i++){
				pro.Pro_Buff[i-temp] = pro.Pro_Buff[i];	
			}
		}	
	}
	if((p->Mark_Head[0]!=0xa5)||(p->Mark_Head[1]!=0x5a))
	{   
		return 1;                
	}
	if((p->Des_Addr[0]!=HAddr)||(p->Des_Addr[1]!=LAddr))
	{
		return 2;
	}
	//序列号检查
	if(p->Seq_Num!=0xff)
	{
	}
	if((p->Payload_Num+9)>num)
	{
		return 3;
	}
	return 0;
}

void Command_01()
{
	BYTE i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	//头处理
 	p->Mark_Head[0] = 0xa5;
 	p->Mark_Head[1] = 0x5a;
	p->Des_Addr[0] = 0x00;
	p->Des_Addr[1] = 0x01;
	p->Src_Addr[0] = Src_Addr[0];
 	p->Src_Addr[1] = Src_Addr[1];
	p->Command = 0x01;
	p->Seq_Num = 0;
	p->Payload_Num = 0;
	if(Send_Pri2<=3)
	{
		for(i=0;i<p->Payload_Num+9;i++)
	 	{
	 		Send_Buff2[i] = pro.Pro_Buff[i]; 
	 	}
	 	Send_Num2 = p->Payload_Num +9;
		Send_Pri2 = 3;
	}
				
}

//一次写入50字节
BYTE Command_07()
{
	WORD i;
	BYTE j;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==50)
	{
		i = (((WORD)(p->Payload[0]))<<8)+(WORD)(p->Payload[1]);
		if(i<=462)
		{
			for(j=0;j<30;j++)
			{
				EEPROM_Buffer[i+j] = p->Payload[j+2];
			}
			return 0;
		}else
		{
			return 4;
		}		
	}else
	{
		return 5;
	}
}
//配置相关参数
BYTE Command_09()
{
	WORD i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==50)
	{
		switch(p->Payload[0])
		{
			case 0x01:	
			case 0x02:
			case 0x08:
			case 0x09:
				EEPROM_Buffer[3] = p->Payload[0];
				for(i=0;i<34;i++)
				{
					if(p->Payload[i+1]!=0xff)
					{
						EEPROM_Buffer[i+48] = p->Payload[i+1];
					}
				}	
				EEPROM_Buffer[87] = p->Payload[49];
				break;
			case 0x03:
			case 0x05:
			case 0x06:
				EEPROM_Buffer[4] = p->Payload[0];
				for(i=0;i<34;i++)
				{
					if(p->Payload[i+1]!=0xff)
					{
						EEPROM_Buffer[i+104] = p->Payload[i+1];
					}
				}
				EEPROM_Buffer[143] = p->Payload[49];
				break;
			case 0x04:
			case 0x07:
				EEPROM_Buffer[6] = p->Payload[0];
				//补充类
				for(i=0;i<14;i++)
			    {
					if(p->Payload[i+3]!=0xff)
					{
						EEPROM_Buffer[i+408] = p->Payload[i+3];
					}
				}
				for(i=0;i<18;i++)
				{
					if(p->Payload[i+17]!=0xff)
					{
						EEPROM_Buffer[i+318] = p->Payload[i+17];
					}
				}
				break;
		    default:
				break;
		}
		switch(p->Payload[0])
		{
			case 0x01:
				EEPROM_Buffer[82] = 0x01;            //1秒采集间隔
				EEPROM_Buffer[83] = 0x32;            //启动时间
				EEPROM_Buffer[91] = 0x00;
			   	EEPROM_Buffer[92] = 0x64;
				EEPROM_Buffer[93] = 0x00;
				EEPROM_Buffer[94] = 0x00;
				break;
			case 0x02:
				EEPROM_Buffer[82] = 0x01;            //1秒采集间隔
				EEPROM_Buffer[83] = 0x05;            //启动时间
				EEPROM_Buffer[91] = 0x03;
			   	EEPROM_Buffer[92] = 0xe8;
				EEPROM_Buffer[93] = 0x00;
				EEPROM_Buffer[94] = 0x00;
				EEPROM_Buffer[96] = 0x10;		    //超过4.3认为100%
			   	EEPROM_Buffer[97] = 0xe3;
				EEPROM_Buffer[98] = 0x04;		    //低于1.1认为0 低于1认为故障
				EEPROM_Buffer[99] = 0x4c;
				break;
			case 0x03:			
				EEPROM_Buffer[83] = 0x05;            //启动时间
				break;
			case 0x04:
				break;
			case 0x05:
				EEPROM_Buffer[83] = 0x05;            //启动时间
				break;
			case 0x06:
				EEPROM_Buffer[83] = 0x05;            //启动时间
				break;
			case 0x07:
				break;
			case 0x08:
				EEPROM_Buffer[82] = p->Payload[35];         //采集间隔
				EEPROM_Buffer[83] = 0x05;            //启动时间
				EEPROM_Buffer[100] = p->Payload[36];         //电平意义
				EEPROM_Buffer[101] = p->Payload[37];         //判决次数
				EEPROM_Buffer[102] = p->Payload[38];         //判决门限
				EEPROM_Buffer[103] = p->Payload[39];         //判决次数门限 多少次算成功判决
				EEPROM_Buffer[91] = 0x00;
			   	EEPROM_Buffer[92] = 0x00;
				EEPROM_Buffer[93] = 0x00;
				EEPROM_Buffer[94] = 0x00;
				break;
			case 0x09:
				EEPROM_Buffer[82] = p->Payload[35];         //采集间隔
				EEPROM_Buffer[83] = 0x05;            //启动时间
				EEPROM_Buffer[91] = 0x13;
			   	EEPROM_Buffer[92] = 0xe2;
				EEPROM_Buffer[93] = 0x00;
				EEPROM_Buffer[94] = 0x00;
				break;
			default:
				break;
		}
		return 0;
	}
	else
	{
		return 5;
	}
}
//获取相关参数
BYTE Command_0F()
{
	WORD i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==1)
	{
		if(p->Payload[0] == EEPROM_Buffer[3])
		{
			p->Payload[1] = EEPROM_Buffer[3];
			for(i=0;i<16;i++)
			{
				p->Payload[i+2] = EEPROM_Buffer[i+48];
			}
			//若是08类，填写测试级别
			p->Payload[18] = EEPROM_Buffer[82];
			p->Payload[19] = EEPROM_Buffer[100];
			p->Payload[20] = EEPROM_Buffer[101];
			p->Payload[21] = EEPROM_Buffer[102];
			p->Payload[22] = EEPROM_Buffer[103];
			return 0;
		}else if(p->Payload[0] == EEPROM_Buffer[4])	
		{
			p->Payload[1] = EEPROM_Buffer[4];
			for(i=0;i<16;i++)
			{
				p->Payload[i+2] = EEPROM_Buffer[i+104];
			}
			return 0;
		}else if(p->Payload[0] == EEPROM_Buffer[6])		  
		{
			p->Payload[1] = EEPROM_Buffer[4];
			p->Payload[2] = EEPROM_Buffer[104];
			p->Payload[3] = EEPROM_Buffer[105];
			for(i=0;i<14;i++)
			{
				p->Payload[i+4] = EEPROM_Buffer[i+408];
			}
			return 0;
		}else
		{
			return 6;
		}
	}
	else
	{
		return 5;
	}
}

BYTE Command_11()
{
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==0)
	{
		EEPROM_Buffer[34] = 0;					     //初始状态各行都不刷新
		EEPROM_Buffer[35] = 0;
		EEPROM_Buffer[36] = 0;
		EEPROM_Buffer[37] = 0;
		ADC_P_Init();
		DATA_P_Init();
		EXTRA_P_Init();
		IapEraseSector(0);                            //先擦后写
		WriteSector(0,EEPROM_Buffer);                 //EEPROM写入
		return 0;		
	}else
	{
		return 5;
	}
}
//采集和按次定时上传处理+报警检测开闭+故障、报警上传+临时解除警报+门限处理+........
BYTE Command_13()
{
	Pro_0_0* p;
	WORD i;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==30)
	{
		if(p->Payload[0] == EEPROM_Buffer[3])
		{
			for(i=0;i<8;i++)
			{
				if(p->Payload[i+1]!=0xff)
					EEPROM_Buffer[i+48] = p->Payload[i+1];
			}
			if(p->Payload[9] == 0x01)              //配置门限值
			{
				for(i=0;i<8;i++)
				{
					EEPROM_Buffer[i+56] = p->Payload[i+10];	
				}
			}
			//记录上传设置
			if(p->Payload[18]!=0xff)
				EEPROM_Buffer[95] = p->Payload[18];
			//记录上传地址
			if(p->Payload[19]!=0xff)
				EEPROM_Buffer[301] = p->Payload[19];
			if(p->Payload[20]!=0xff)
				EEPROM_Buffer[302] = p->Payload[20];
			//08类传感器参数
			if(p->Payload[21]!=0xff)
				EEPROM_Buffer[82] = p->Payload[21];
			if(p->Payload[22]!=0xff)
				EEPROM_Buffer[100] = p->Payload[22];
			if(p->Payload[23]!=0xff)
				EEPROM_Buffer[101] = p->Payload[23];
			if(p->Payload[24]!=0xff)
				EEPROM_Buffer[102] = p->Payload[24];
			if(p->Payload[25]!=0xff)
				EEPROM_Buffer[103] = p->Payload[25];
			return 0;	
		}else if(p->Payload[0] == EEPROM_Buffer[4])
		{
			for(i=0;i<8;i++)
			{
				if(p->Payload[i+1]!=0xff)
					EEPROM_Buffer[i+104] = p->Payload[i+1];
			}
			if(p->Payload[9] == 0x01)              //配置门限值
			{
				for(i=0;i<8;i++)
				{
					EEPROM_Buffer[i+112] = p->Payload[i+10];
				}	
			}
			//记录上传设置
			if(p->Payload[18]!=0xff)
				EEPROM_Buffer[151] = p->Payload[18];
			//记录上传地址
			if(p->Payload[19]!=0xff)
				EEPROM_Buffer[301] = p->Payload[19];
			if(p->Payload[20]!=0xff)
				EEPROM_Buffer[302] = p->Payload[20];
			return 0;	
		} else if(p->Payload[0] == EEPROM_Buffer[6])
		{
			if(p->Payload[1] !=0xff)
				EEPROM_Buffer[104] = p->Payload[1];
			if(p->Payload[2] !=0xff)
				EEPROM_Buffer[105] = p->Payload[2];
			for(i=0;i<6;i++)
			{
				if(p->Payload[i+3]!=0xff)
					EEPROM_Buffer[i+408] = p->Payload[i+3];
			}
			if(p->Payload[9] == 0x01)              //配置门限值
			{
				for(i=0;i<8;i++)
				{
					EEPROM_Buffer[i+414] = p->Payload[i+10];
				}	
			}
			//记录上传设置
			if(p->Payload[18]!=0xff)
				EEPROM_Buffer[151] = p->Payload[18];
			//记录上传地址
			if(p->Payload[19]!=0xff)
				EEPROM_Buffer[301] = p->Payload[19];
			if(p->Payload[20]!=0xff)
				EEPROM_Buffer[302] = p->Payload[20];
			return 0;	
		}
		else
		{
			return 6;
		}
	}
	else
	{
		return 5;
	}
}
//
BYTE Command_15()
{
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==3)
	{
		if(p->Payload[0] == 0x00)
			EEPROM_Buffer[3] = 0xff;
		if(p->Payload[1] == 0x00)
	    	EEPROM_Buffer[4] = 0xff;
		if(p->Payload[2] == 0x00)
			EEPROM_Buffer[6] = 0xff;
		return 0;
	}
	else
	{
		return 5;
	}
} 
//LOGO和显示字符修改
BYTE Command_17()
{
	WORD i;
	BYTE j,k;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==20)
	{
		i = ((WORD)(p->Payload[0])<<8)+(WORD)(p->Payload[1]);
		switch(i)
		{
			case 64:		
			case 120:				
			case 318:				
			case 336:				
			case 354:				
			case 372:			
			case 390:
				k=0;
				break;
			default:
				k=1;
				break;
		}
		if(k==0)
		{
			for(j=0;j<18;j++)
			{
				EEPROM_Buffer[i+j] = p->Payload[j+2];
			}
			return 0;	
		}
		else
		{
			return 4;
		}
	}
	else
	{
		return 5;
	}	
}
//心跳设置
BYTE Command_19()
{
	BYTE i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==5)
	{
		for(i=0;i<5;i++)
		{
			EEPROM_Buffer[i+296] = p->Payload[i];
		}
		if((EEPROM_Buffer[296]&0x02)==0x02)
		{
			Heart_Time = ((WORD)(EEPROM_Buffer[297])<<8)+(WORD)EEPROM_Buffer[298];
			Heart_Count = 0;
		}
		return 0;
	}
	else
	{
		return 5;
	}
}
//设置家庭路由器
BYTE Command_1b()
{
	BYTE i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==42)
	{
		for(i=0;i<42;i++)
		{
			EEPROM_Buffer[i+208] = p->Payload[i];
		}
		return 0;
	}
	else
	{
		return 5;
	}
}
//设置远程服务器
BYTE Command_1d()
{
	BYTE i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==28)
	{
		for(i=0;i<28;i++)
		{
			EEPROM_Buffer[i+250] = p->Payload[i];
		}
		return 0;
	}
	else
	{
		return 5;
	}
}
//获取工作状态
BYTE Command_1f()
{
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	if(p->Payload_Num==0)
	{
		p->Payload[1] = EEPROM_Buffer[53];
		p->Payload[2] = EEPROM_Buffer[84];
		p->Payload[3] = EEPROM_Buffer[86];
		p->Payload[4] = ADC_Count;
		p->Payload[5] = EEPROM_Buffer[88];
		p->Payload[6] = EEPROM_Buffer[89];
		p->Payload[7] = EEPROM_Buffer[90];
		p->Payload[8] = EEPROM_Buffer[95];

		p->Payload[9] = EEPROM_Buffer[109];
		p->Payload[10] = EEPROM_Buffer[140];
		p->Payload[11] = EEPROM_Buffer[142];
		p->Payload[12] = DATA_Count;
		p->Payload[13] = EEPROM_Buffer[144];
		p->Payload[14] = EEPROM_Buffer[145];
		p->Payload[15] = EEPROM_Buffer[146];
		p->Payload[16] = EEPROM_Buffer[151];
	   
	    p->Payload[17] = EEPROM_Buffer[411]; 
		
		p->Payload[18] = (BYTE)(Heart_Count>>8);
		p->Payload[19] = (BYTE)(Heart_Count); 
		return 0;
	}	
	else
	{
		return 5;
	}
}

//心跳处理，最高优先级
void Heart_Process() 
{
	BYTE num,i;
	Pro_0_0* p;
	p = &(pro.Pro_Struct);
	//头处理
	 p->Mark_Head[0] = 0xa5;
	 p->Mark_Head[1] = 0x5a;
	 //心跳地址
	 p->Des_Addr[0] = EEPROM_Buffer[299];
	 p->Des_Addr[1] = EEPROM_Buffer[300];
	 //本地地址写入
	 p->Src_Addr[0] = Src_Addr[0];
	 p->Src_Addr[1] = Src_Addr[1];
	 p->Seq_Num = Seq_Number;
	 Seq_Number++;
	 p->Command = 0x30;                                         //上传数据
	 //上传32字节的板子和用户信息
	 for(i=0;i<8;i++)
	 {
	 	p->Payload[i] = EEPROM_Buffer[i];
	 }
	 for(i=0;i<24;i++)
	 {
	 	p->Payload[i+8] = 0xff;
	 }
	 num = 32;
	 p->Payload_Num = num;			                           //载荷长度
	 if(Send_Pri2<=4)
	 {
	 	for(i=0;i<num+9;i++)
	 	{
	 		Send_Buff2[i] = pro.Pro_Buff[i]; 
	 	}
	 	Send_Num2 = num +9;
		Send_Pri2 = 4;
	 }
	 EEPROM_Buffer[301]++;
}
